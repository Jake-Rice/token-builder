{"ast":null,"code":"// https://github.com/Ethan-Arrowood/undici-fetch\n'use strict';\n\nconst {\n  Response,\n  makeNetworkError,\n  filterResponse,\n  makeResponse\n} = require('./response');\n\nconst {\n  Headers\n} = require('./headers');\n\nconst {\n  Request,\n  makeRequest\n} = require('./request');\n\nconst zlib = require('zlib');\n\nconst {\n  ServiceWorkerGlobalScope,\n  Window,\n  matchRequestIntegrity,\n  makePolicyContainer,\n  clonePolicyContainer,\n  requestBadPort,\n  TAOCheck,\n  appendRequestOriginHeader,\n  responseLocationURL,\n  requestCurrentURL,\n  setRequestReferrerPolicyOnRedirect,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  createOpaqueTimingInfo,\n  appendFetchMetadata,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  determineRequestsReferrer,\n  coarsenedSharedCurrentTime,\n  createDeferredPromise,\n  isBlobLike,\n  CORBCheck,\n  sameOrigin\n} = require('./util');\n\nconst {\n  kState,\n  kHeaders,\n  kGuard,\n  kRealm\n} = require('./symbols');\n\nconst {\n  AbortError\n} = require('../core/errors');\n\nconst assert = require('assert');\n\nconst {\n  safelyExtractBody,\n  extractBody\n} = require('./body');\n\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  safeMethods,\n  requestBodyHeader,\n  subresource\n} = require('./constants');\n\nconst {\n  kHeadersList\n} = require('../core/symbols');\n\nconst EE = require('events');\n\nconst {\n  PassThrough,\n  pipeline\n} = require('stream');\n\nconst {\n  isErrored,\n  isReadable\n} = require('../core/util');\n\nconst {\n  kIsMockActive\n} = require('../mock/mock-symbols');\n\nconst {\n  dataURLProcessor\n} = require('./dataURL');\n/** @type {import('buffer').resolveObjectURL} */\n\n\nlet resolveObjectURL;\nlet ReadableStream;\n\nclass Fetch extends EE {\n  constructor(dispatcher) {\n    super();\n    this.dispatcher = dispatcher;\n    this.terminated = null;\n    this.connection = null;\n    this.dump = false;\n  }\n\n  terminate() {\n    let {\n      reason,\n      aborted\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.terminated) {\n      return;\n    }\n\n    this.terminated = {\n      aborted,\n      reason\n    };\n    this.connection?.destroy(reason);\n    this.emit('terminated', reason);\n  }\n\n} // https://fetch.spec.whatwg.org/#fetch-method\n\n\nasync function fetch() {\n  if (arguments.length < 1) {\n    throw new TypeError(`Failed to execute 'fetch' on 'Window': 1 argument required, but only ${arguments.length} present.`);\n  }\n\n  if (arguments.length >= 1 && typeof (arguments.length <= 1 ? undefined : arguments[1]) !== 'object' && (arguments.length <= 1 ? undefined : arguments[1]) !== undefined) {\n    throw new TypeError(\"Failed to execute 'fetch' on 'Window': cannot convert to dictionary.\");\n  }\n\n  const resource = arguments.length <= 0 ? undefined : arguments[0];\n  const init = arguments.length >= 1 ? (arguments.length <= 1 ? undefined : arguments[1]) ?? {} : {};\n  const context = new Fetch(this); // 1. Let p be a new promise.\n\n  const p = createDeferredPromise(); // 2. Let requestObject be the result of invoking the initial value of\n  // Request as constructor with input and init as arguments. If this throws\n  // an exception, reject p with it and return p.\n\n  const requestObject = new Request(resource, init); // 3. Let request be requestObject’s request.\n\n  const request = requestObject[kState]; // 4. If requestObject’s signal’s aborted flag is set, then:\n\n  if (requestObject.signal.aborted) {\n    // 1. Abort fetch with p, request, and null.\n    abortFetch.call(context, p, request, null); // 2. Return p.\n\n    return p.promise;\n  } // 5. Let globalObject be request’s client’s global object.\n  // TODO: What if request.client is null?\n\n\n  const globalObject = request.client?.globalObject; // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n  // request’s service-workers mode to \"none\".\n\n  if (globalObject instanceof ServiceWorkerGlobalScope) {\n    request.serviceWorkers = 'none';\n  } // 7. Let responseObject be null.\n\n\n  let responseObject = null; // 8. Let relevantRealm be this’s relevant Realm.\n\n  const relevantRealm = null; // 9. Let locallyAborted be false.\n\n  let locallyAborted = false; // 10. Add the following abort steps to requestObject’s signal:\n\n  requestObject.signal.addEventListener('abort', () => {\n    // 1. Set locallyAborted to true.\n    locallyAborted = true; // 2. Abort fetch with p, request, and responseObject.\n\n    abortFetch.call(context, p, request, responseObject); // 3. Terminate the ongoing fetch with the aborted flag set.\n\n    context.terminate({\n      aborted: true\n    });\n  }, {\n    once: true\n  }); // 11. Let handleFetchDone given response response be to finalize and\n  // report timing with response, globalObject, and \"fetch\".\n\n  const handleFetchDone = response => finalizeAndReportTiming(response, 'fetch'); // 12. Fetch request with processResponseEndOfBody set to handleFetchDone,\n  // and processResponse given response being these substeps:\n\n\n  const processResponse = response => {\n    // 1. If locallyAborted is true, terminate these substeps.\n    if (locallyAborted) {\n      return;\n    } // 2. If response’s aborted flag is set, then abort fetch with p,\n    // request, and responseObject, and terminate these substeps.\n\n\n    if (response.aborted) {\n      abortFetch.call(context, p, request, responseObject);\n      return;\n    } // 3. If response is a network error, then reject p with a TypeError\n    // and terminate these substeps.\n\n\n    if (response.type === 'error') {\n      p.reject(Object.assign(new TypeError('fetch failed'), {\n        cause: response.error\n      }));\n      return;\n    } // 4. Set responseObject to the result of creating a Response object,\n    // given response, \"immutable\", and relevantRealm.\n\n\n    responseObject = new Response();\n    responseObject[kState] = response;\n    responseObject[kRealm] = relevantRealm;\n    responseObject[kHeaders][kHeadersList] = response.headersList;\n    responseObject[kHeaders][kGuard] = 'immutable';\n    responseObject[kHeaders][kRealm] = relevantRealm; // 5. Resolve p with responseObject.\n\n    p.resolve(responseObject);\n  };\n\n  fetching.call(context, {\n    request,\n    processResponseEndOfBody: handleFetchDone,\n    processResponse\n  }).catch(err => {\n    p.reject(err);\n  }); // 13. Return p.\n\n  return p.promise;\n} // https://fetch.spec.whatwg.org/#finalize-and-report-timing\n\n\nfunction finalizeAndReportTiming(response) {\n  let initiatorType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'other';\n\n  // 1. If response is an aborted network error, then return.\n  if (response.type === 'error' && response.aborted) {\n    return;\n  } // 2. If response’s URL list is null or empty, then return.\n\n\n  if (!response.urlList?.length) {\n    return;\n  } // 3. Let originalURL be response’s URL list[0].\n\n\n  const originalURL = response.urlList[0]; // 4. Let timingInfo be response’s timing info.\n\n  let timingInfo = response.timingInfo; // 5. Let cacheState be response’s cache state.\n\n  let cacheState = response.cacheState; // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.\n\n  if (!/^https?:/.test(originalURL.protocol)) {\n    return;\n  } // 7. If timingInfo is null, then return.\n\n\n  if (timingInfo === null) {\n    return;\n  } // 8. If response’s timing allow passed flag is not set, then:\n\n\n  if (!timingInfo.timingAllowPassed) {\n    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n    timingInfo = createOpaqueTimingInfo({\n      startTime: timingInfo.startTime\n    }); //  2. Set cacheState to the empty string.\n\n    cacheState = '';\n  } // 9. Set timingInfo’s end time to the coarsened shared current time\n  // given global’s relevant settings object’s cross-origin isolated\n  // capability.\n  // TODO: given global’s relevant settings object’s cross-origin isolated\n  // capability?\n\n\n  response.timingInfo.endTime = coarsenedSharedCurrentTime(); // 10. Set response’s timing info to timingInfo.\n\n  response.timingInfo = timingInfo; // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n  // global, and cacheState.\n\n  markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);\n} // https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\n\n\nfunction markResourceTiming() {// TODO\n} // https://fetch.spec.whatwg.org/#abort-fetch\n\n\nfunction abortFetch(p, request, responseObject) {\n  // 1. Let error be an \"AbortError\" DOMException.\n  const error = new AbortError(); // 2. Reject promise with error.\n\n  p.reject(error); // 3. If request’s body is not null and is readable, then cancel request’s\n  // body with error.\n\n  if (request.body != null && isReadable(request.body?.stream)) {\n    request.body.stream.cancel(error).catch(err => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return;\n      }\n\n      throw err;\n    });\n  } // 4. If responseObject is null, then return.\n\n\n  if (responseObject == null) {\n    return;\n  } // 5. Let response be responseObject’s response.\n\n\n  const response = responseObject[kState]; // 6. If response’s body is not null and is readable, then error response’s\n  // body with error.\n\n  if (response.body != null && isReadable(response.body?.stream)) {\n    response.body.stream.cancel(error).catch(err => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return;\n      }\n\n      throw err;\n    });\n  }\n} // https://fetch.spec.whatwg.org/#fetching\n\n\nfunction fetching(_ref) {\n  let {\n    request,\n    processRequestBodyChunkLength,\n    processRequestEndOfBody,\n    processResponse,\n    processResponseEndOfBody,\n    processResponseConsumeBody,\n    useParallelQueue = false\n  } = _ref;\n  // 1. Let taskDestination be null.\n  let taskDestination = null; // 2. Let crossOriginIsolatedCapability be false.\n\n  let crossOriginIsolatedCapability = false; // 3. If request’s client is non-null, then:\n\n  if (request.client != null) {\n    // 1. Set taskDestination to request’s client’s global object.\n    taskDestination = request.client.globalObject; // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin\n    // isolated capability.\n\n    crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;\n  } // 4. If useParallelQueue is true, then set taskDestination to the result of\n  // starting a new parallel queue.\n  // TODO\n  // 5. Let timingInfo be a new fetch timing info whose start time and\n  // post-redirect start time are the coarsened shared current time given\n  // crossOriginIsolatedCapability.\n\n\n  const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);\n  const timingInfo = createOpaqueTimingInfo({\n    startTime: currenTime\n  }); // 6. Let fetchParams be a new fetch params whose\n  // request is request,\n  // timing info is timingInfo,\n  // process request body chunk length is processRequestBodyChunkLength,\n  // process request end-of-body is processRequestEndOfBody,\n  // process response is processResponse,\n  // process response consume body is processResponseConsumeBody,\n  // process response end-of-body is processResponseEndOfBody,\n  // task destination is taskDestination,\n  // and cross-origin isolated capability is crossOriginIsolatedCapability.\n\n  const fetchParams = {\n    request,\n    timingInfo,\n    processRequestBodyChunkLength,\n    processRequestEndOfBody,\n    processResponse,\n    processResponseConsumeBody,\n    processResponseEndOfBody,\n    taskDestination,\n    crossOriginIsolatedCapability\n  }; // 7. If request’s body is a byte sequence, then set request’s body to the\n  // first return value of safely extracting request’s body.\n  // NOTE: Since fetching is only called from fetch, body should already be\n  // extracted.\n\n  assert(!request.body || request.body.stream); // 8. If request’s window is \"client\", then set request’s window to request’s\n  // client, if request’s client’s global object is a Window object; otherwise\n  // \"no-window\".\n\n  if (request.window === 'client') {\n    // TODO: What if request.client is null?\n    request.window = request.client?.globalObject instanceof Window ? request.client : 'no-window';\n  } // 9. If request’s origin is \"client\", then set request’s origin to request’s\n  // client’s origin.\n\n\n  if (request.origin === 'client') {\n    // TODO: What if request.client is null?\n    request.origin = request.client?.origin;\n  } // 10. If request’s policy container is \"client\", then:\n\n\n  if (request.policyContainer === 'client') {\n    // 1. If request’s client is non-null, then set request’s policy\n    // container to a clone of request’s client’s policy container. [HTML]\n    if (request.client != null) {\n      request.policyContainer = clonePolicyContainer(request.client.policyContainer);\n    } else {\n      // 2. Otherwise, set request’s policy container to a new policy\n      // container.\n      request.policyContainer = makePolicyContainer();\n    }\n  } // 11. If request’s header list does not contain `Accept`, then:\n\n\n  if (!request.headersList.has('accept')) {\n    // 1. Let value be `*/*`.\n    const value = '*/*'; // 2. A user agent should set value to the first matching statement, if\n    // any, switching on request’s destination:\n    // \"document\"\n    // \"frame\"\n    // \"iframe\"\n    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n    // \"image\"\n    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n    // \"style\"\n    // `text/css,*/*;q=0.1`\n    // TODO\n    // 3. Append `Accept`/value to request’s header list.\n\n    request.headersList.append('accept', value);\n  } // 12. If request’s header list does not contain `Accept-Language`, then\n  // user agents should append `Accept-Language`/an appropriate value to\n  // request’s header list.\n\n\n  if (!request.headersList.has('accept-language')) {\n    request.headersList.append('accept-language', '*');\n  } // 13. If request’s priority is null, then use request’s initiator and\n  // destination appropriately in setting request’s priority to a\n  // user-agent-defined object.\n\n\n  if (request.priority === null) {// TODO\n  } // 14. If request is a subresource request, then:\n\n\n  if (subresource.includes(request.destination)) {// 1. Let record be a new fetch record consisting of request and this\n    // instance of the fetch algorithm.\n    // TODO\n    // 2. Append record to request’s client’s fetch group list of fetch\n    // records.\n    // TODO\n  } // 15. Run main fetch given fetchParams.\n\n\n  return mainFetch.call(this, fetchParams);\n} // https://fetch.spec.whatwg.org/#concept-main-fetch\n\n\nasync function mainFetch(fetchParams) {\n  let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const context = this; // 1. Let request be fetchParams’s request.\n\n  const request = fetchParams.request; // 2. Let response be null.\n\n  let response = null; // 3. If request’s local-URLs-only flag is set and request’s current URL is\n  // not local, then set response to a network error.\n\n  if (request.localURLsOnly && !/^(about|blob|data):/.test(requestCurrentURL(request).protocol)) {\n    response = makeNetworkError('local URLs only');\n  } // 4. Run report Content Security Policy violations for request.\n  // TODO\n  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n\n\n  tryUpgradeRequestToAPotentiallyTrustworthyURL(request); // 6. If should request be blocked due to a bad port, should fetching request\n  // be blocked as mixed content, or should request be blocked by Content\n  // Security Policy returns blocked, then set response to a network error.\n\n  if (requestBadPort(request) === 'blocked') {\n    response = makeNetworkError('bad port');\n  } // TODO: should fetching request be blocked as mixed content?\n  // TODO: should request be blocked by Content Security Policy?\n  // 7. If request’s referrer policy is the empty string, then set request’s\n  // referrer policy to request’s policy container’s referrer policy.\n\n\n  if (request.referrerPolicy === '') {\n    request.referrerPolicy = request.policyContainer.referrerPolicy;\n  } // 8. If request’s referrer is not \"no-referrer\", then set request’s\n  // referrer to the result of invoking determine request’s referrer.\n\n\n  if (request.referrer !== 'no-referrer') {\n    request.referrer = determineRequestsReferrer(request);\n  } // 9. Set request’s current URL’s scheme to \"https\" if all of the following\n  // conditions are true:\n  // - request’s current URL’s scheme is \"http\"\n  // - request’s current URL’s host is a domain\n  // - Matching request’s current URL’s host per Known HSTS Host Domain Name\n  //   Matching results in either a superdomain match with an asserted\n  //   includeSubDomains directive or a congruent match (with or without an\n  //   asserted includeSubDomains directive). [HSTS]\n  // TODO\n  // 10. If recursive is false, then run the remaining steps in parallel.\n  // TODO\n  // 11. If response is null, then set response to the result of running\n  // the steps corresponding to the first matching statement:\n\n\n  if (response === null) {\n    response = await (async () => {\n      const currentURL = requestCurrentURL(request);\n\n      if ( // - request’s current URL’s origin is same origin with request’s origin,\n      //   and request’s response tainting is \"basic\"\n      sameOrigin(currentURL, request.url) && request.responseTainting === 'basic' || // request’s current URL’s scheme is \"data\"\n      currentURL.protocol === 'data:' || // - request’s mode is \"navigate\" or \"websocket\"\n      request.mode === 'navigate' || request.mode === 'websocket') {\n        // 1. Set request’s response tainting to \"basic\".\n        request.responseTainting = 'basic'; // 2. Return the result of running scheme fetch given fetchParams.\n\n        return await schemeFetch.call(this, fetchParams);\n      } // request’s mode is \"same-origin\"\n\n\n      if (request.mode === 'same-origin') {\n        // 1. Return a network error.\n        return makeNetworkError('request mode cannot be \"same-origin\"');\n      } // request’s mode is \"no-cors\"\n\n\n      if (request.mode === 'no-cors') {\n        // 1. If request’s redirect mode is not \"follow\", then return a network\n        // error.\n        if (request.redirect !== 'follow') {\n          return makeNetworkError('redirect mode cannot be \"follow\" for \"no-cors\" request');\n        } // 2. Set request’s response tainting to \"opaque\".\n\n\n        request.responseTainting = 'opaque'; // 3. Let noCorsResponse be the result of running scheme fetch given\n        // fetchParams.\n\n        const noCorsResponse = await schemeFetch.call(this, fetchParams); // 4. If noCorsResponse is a filtered response or the CORB check with\n        // request and noCorsResponse returns allowed, then return noCorsResponse.\n\n        if (noCorsResponse.status === 0 || CORBCheck(request, noCorsResponse) === 'allowed') {\n          return noCorsResponse;\n        } // 5. Return a new response whose status is noCorsResponse’s status.\n\n\n        return makeResponse({\n          status: noCorsResponse.status\n        });\n      } // request’s current URL’s scheme is not an HTTP(S) scheme\n\n\n      if (!/^https?:/.test(requestCurrentURL(request).protocol)) {\n        // Return a network error.\n        return makeNetworkError('URL scheme must be a HTTP(S) scheme');\n      } // - request’s use-CORS-preflight flag is set\n      // - request’s unsafe-request flag is set and either request’s method is\n      //   not a CORS-safelisted method or CORS-unsafe request-header names with\n      //   request’s header list is not empty\n      //    1. Set request’s response tainting to \"cors\".\n      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n      //    given fetchParams and true.\n      //    3. If corsWithPreflightResponse is a network error, then clear cache\n      //    entries using request.\n      //    4. Return corsWithPreflightResponse.\n      // TODO\n      // Otherwise\n      //    1. Set request’s response tainting to \"cors\".\n\n\n      request.responseTainting = 'cors'; //    2. Return the result of running HTTP fetch given fetchParams.\n\n      return await httpFetch.call(this, fetchParams).catch(err => makeNetworkError(err));\n    })();\n  } // 12. If recursive is true, then return response.\n\n\n  if (recursive) {\n    return response;\n  } // 13. If response is not a network error and response is not a filtered\n  // response, then:\n\n\n  if (response.status !== 0 && !response.internalResponse) {\n    // If request’s response tainting is \"cors\", then:\n    if (request.responseTainting === 'cors') {// 1. Let headerNames be the result of extracting header list values\n      // given `Access-Control-Expose-Headers` and response’s header list.\n      // TODO\n      // 2. If request’s credentials mode is not \"include\" and headerNames\n      // contains `*`, then set response’s CORS-exposed header-name list to\n      // all unique header names in response’s header list.\n      // TODO\n      // 3. Otherwise, if headerNames is not null or failure, then set\n      // response’s CORS-exposed header-name list to headerNames.\n      // TODO\n    } // Set response to the following filtered response with response as its\n    // internal response, depending on request’s response tainting:\n\n\n    if (request.responseTainting === 'basic') {\n      response = filterResponse(response, 'basic');\n    } else if (request.responseTainting === 'cors') {\n      response = filterResponse(response, 'cors');\n    } else if (request.responseTainting === 'opaque') {\n      response = filterResponse(response, 'opaque');\n    } else {\n      assert(false);\n    }\n  } // 14. Let internalResponse be response, if response is a network error,\n  // and response’s internal response otherwise.\n\n\n  let internalResponse = response.status === 0 ? response : response.internalResponse; // 15. If internalResponse’s URL list is empty, then set it to a clone of\n  // request’s URL list.\n\n  if (internalResponse.urlList.length === 0) {\n    internalResponse.urlList.push(...request.urlList);\n  } // 16. If request’s timing allow failed flag is unset, then set\n  // internalResponse’s timing allow passed flag.\n\n\n  if (!request.timingAllowFailed) {\n    response.timingAllowPassed = true;\n  } // 17. If response is not a network error and any of the following returns\n  // blocked\n  // - should internalResponse to request be blocked as mixed content\n  // - should internalResponse to request be blocked by Content Security Policy\n  // - should internalResponse to request be blocked due to its MIME type\n  // - should internalResponse to request be blocked due to nosniff\n  // TODO\n  // 18. If response’s type is \"opaque\", internalResponse’s status is 206,\n  // internalResponse’s range-requested flag is set, and request’s header\n  // list does not contain `Range`, then set response and internalResponse\n  // to a network error.\n\n\n  if (response.type === 'opaque' && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.has('range')) {\n    response = internalResponse = makeNetworkError();\n  } // 19. If response is not a network error and either request’s method is\n  // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,\n  // set internalResponse’s body to null and disregard any enqueuing toward\n  // it (if any).\n\n\n  if (response.status !== 0 && (request.method === 'HEAD' || request.method === 'CONNECT' || nullBodyStatus.includes(internalResponse.status))) {\n    internalResponse.body = null;\n    context.dump = true;\n  } // 20. If request’s integrity metadata is not the empty string, then:\n\n\n  if (request.integrity) {\n    // 1. Let processBodyError be this step: run fetch finale given fetchParams\n    // and a network error.\n    const processBodyError = reason => fetchFinale.call(context, fetchParams, makeNetworkError(reason)); // 2. If request’s response tainting is \"opaque\", or response’s body is null,\n    // then run processBodyError and abort these steps.\n\n\n    if (request.responseTainting === 'opaque' || response.body == null) {\n      processBodyError(response.error);\n      return;\n    } // 3. Let processBody given bytes be these steps:\n\n\n    const processBody = bytes => {\n      // 1. If bytes do not match request’s integrity metadata,\n      // then run processBodyError and abort these steps. [SRI]\n      if (!matchRequestIntegrity(request, bytes)) {\n        processBodyError('integrity mismatch');\n        return;\n      } // 2. Set response’s body to the first return value of safely\n      // extracting bytes.\n\n\n      response.body = safelyExtractBody(bytes)[0]; // 3. Run fetch finale given fetchParams and response.\n\n      fetchFinale.call(context, fetchParams, response);\n    }; // 4. Fully read response’s body given processBody and processBodyError.\n\n\n    try {\n      processBody(await response.arrayBuffer());\n    } catch (err) {\n      processBodyError(err);\n    }\n  } else {\n    // 21. Otherwise, run fetch finale given fetchParams and response.\n    fetchFinale.call(context, fetchParams, response);\n  }\n} // https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\n\n\nasync function schemeFetch(fetchParams) {\n  const context = this; // let request be fetchParams’s request\n\n  const {\n    request\n  } = fetchParams;\n  const {\n    protocol: scheme,\n    pathname: path\n  } = new URL(requestCurrentURL(request)); // switch on request’s current URL’s scheme, and run the associated steps:\n\n  switch (scheme) {\n    case 'about:':\n      {\n        // If request’s current URL’s path is the string \"blank\", then return a new response\n        // whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) », \n        // and body is the empty byte sequence. \n        if (path === 'blank') {\n          const resp = makeResponse({\n            statusText: 'OK',\n            headersList: ['content-type', 'text/html;charset=utf-8']\n          });\n          resp.urlList = [new URL('about:blank')];\n          return resp;\n        } // Otherwise, return a network error.\n\n\n        return makeNetworkError('invalid path called');\n      }\n\n    case 'blob:':\n      {\n        resolveObjectURL ??= require('buffer').resolveObjectURL;\n        context.on('terminated', onRequestAborted); // 1. Run these steps, but abort when the ongoing fetch is terminated: \n        //  1a. Let blob be request’s current URL’s blob URL entry’s object.\n        //      https://w3c.github.io/FileAPI/#blob-url-entry\n        //      P.S. Thank God this method is available in node.\n\n        const currentURL = requestCurrentURL(request); // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n        // Buffer.resolveObjectURL does not ignore URL queries.\n\n        if (currentURL.search.length !== 0) {\n          return makeNetworkError('NetworkError when attempting to fetch resource.');\n        }\n\n        const blob = resolveObjectURL(currentURL.toString()); //  2a. If request’s method is not `GET` or blob is not a Blob object, then return a network error. [FILEAPI]\n\n        if (request.method !== 'GET' || !isBlobLike(blob)) {\n          return makeNetworkError('invalid method');\n        } //  3a. Let response be a new response whose status message is `OK`. \n\n\n        const response = makeResponse({\n          statusText: 'OK',\n          urlList: [currentURL]\n        }); //  4a. Append (`Content-Length`, blob’s size attribute value) to response’s header list.\n\n        response.headersList.set('content-length', `${blob.size}`); //  5a. Append (`Content-Type`, blob’s type attribute value) to response’s header list.\n\n        response.headersList.set('content-type', blob.type); //  6a. Set response’s body to the result of performing the read operation on blob.\n\n        response.body = extractBody(blob)[0]; // since the request has not been aborted, we can safely remove the listener.\n\n        context.off('terminated', onRequestAborted); //  7a. Return response.\n\n        return response; // 2. If aborted, then:\n\n        function onRequestAborted() {\n          // 1. Let aborted be the termination’s aborted flag.\n          const aborted = context.terminated.aborted; // 2. If aborted is set, then return an aborted network error.\n\n          if (aborted) {\n            return makeNetworkError(new AbortError());\n          } // 3. Return a network error.\n\n\n          return makeNetworkError(context.terminated.reason);\n        }\n      }\n\n    case 'data:':\n      {\n        // 1. Let dataURLStruct be the result of running the\n        //    data: URL processor on request’s current URL.\n        const currentURL = requestCurrentURL(request);\n        const dataURLStruct = dataURLProcessor(currentURL); // 2. If dataURLStruct is failure, then return a\n        //    network error.\n\n        if (dataURLStruct === 'failure') {\n          return makeNetworkError('failed to fetch the data URL');\n        } // 3. Let mimeType be dataURLStruct’s MIME type, serialized.\n\n\n        const {\n          mimeType\n        } = dataURLStruct;\n        /** @type {string} */\n\n        let contentType = `${mimeType.type}/${mimeType.subtype}`;\n        const contentTypeParams = [];\n\n        if (mimeType.parameters.size > 0) {\n          contentType += ';';\n        }\n\n        for (const [key, value] of mimeType.parameters) {\n          if (value.length > 0) {\n            contentTypeParams.push(`${key}=${value}`);\n          } else {\n            contentTypeParams.push(key);\n          }\n        }\n\n        contentType += contentTypeParams.join(','); // 4. Return a response whose status message is `OK`,\n        //    header list is « (`Content-Type`, mimeType) »,\n        //    and body is dataURLStruct’s body.\n\n        return makeResponse({\n          statusText: 'OK',\n          headersList: ['content-type', contentType],\n          body: dataURLStruct.body\n        });\n      }\n\n    case 'file:':\n      {\n        // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n        // When in doubt, return a network error.\n        return makeNetworkError('not implemented... yet...');\n      }\n\n    case 'http:':\n    case 'https:':\n      {\n        // Return the result of running HTTP fetch given fetchParams.\n        return await httpFetch.call(this, fetchParams).catch(err => makeNetworkError(err));\n      }\n\n    default:\n      {\n        return makeNetworkError('unknown scheme');\n      }\n  }\n} // https://fetch.spec.whatwg.org/#finalize-response\n\n\nfunction finalizeResponse(fetchParams, response) {\n  // 1. Set fetchParams’s request’s done flag.\n  fetchParams.request.done = true; // 2, If fetchParams’s process response done is not null, then queue a fetch\n  // task to run fetchParams’s process response done given response, with\n  // fetchParams’s task destination.\n\n  if (fetchParams.processResponseDone != null) {\n    fetchParams.processResponseDone(response);\n  }\n} // https://fetch.spec.whatwg.org/#fetch-finale\n\n\nfunction fetchFinale(fetchParams, response) {\n  const context = this; // 1. If response is a network error, then:\n\n  if (response.type === 'error') {\n    // 1. Set response’s URL list to « fetchParams’s request’s URL list[0] ».\n    response.urlList = [fetchParams.request.urlList[0]]; // 2. Set response’s timing info to the result of creating an opaque timing\n    // info for fetchParams’s timing info.\n\n    response.timingInfo = createOpaqueTimingInfo({\n      startTime: fetchParams.timingInfo.startTime\n    });\n  } // 2. Let processResponseEndOfBody be the following steps:\n  // TODO\n  // 3. If fetchParams’s process response is non-null, then queue a fetch task\n  // to run fetchParams’s process response given response, with fetchParams’s\n  // task destination.\n\n\n  if (fetchParams.processResponse != null) {\n    fetchParams.processResponse(response);\n  } // 4. If fetchParams’s process response is non-null, then queue a fetch task\n  // to run fetchParams’s process response given response, with fetchParams’s\n  // task destination.\n  // TODO\n  // 5. If response’s body is null, then run processResponseEndOfBody.\n  // TODO\n  // 6. Otherwise:\n  // TODO\n  // 7. If fetchParams’s process response consume body is non-null, then:\n  // TODO\n  // TODO: This is a workaround. Until the above has been implemented, i.e.\n  // we need to either fully consume the body or terminate the fetch.\n\n\n  if (response.type === 'error') {\n    context.terminate({\n      reason: response.error\n    });\n  }\n} // https://fetch.spec.whatwg.org/#http-fetch\n\n\nasync function httpFetch(fetchParams) {\n  const context = this; // 1. Let request be fetchParams’s request.\n\n  const request = fetchParams.request; // 2. Let response be null.\n\n  let response = null; // 3. Let actualResponse be null.\n\n  let actualResponse = null; // 4. Let timingInfo be fetchParams’s timing info.\n\n  const timingInfo = fetchParams.timingInfo; // 5. If request’s service-workers mode is \"all\", then:\n\n  if (request.serviceWorkers === 'all') {// TODO\n  } // 6. If response is null, then:\n\n\n  if (response === null) {\n    // 1. If makeCORSPreflight is true and one of these conditions is true:\n    // TODO\n    // 2. If request’s redirect mode is \"follow\", then set request’s\n    // service-workers mode to \"none\".\n    if (request.redirect === 'follow') {\n      request.serviceWorkers = 'none';\n    } // 3. Set response and actualResponse to the result of running\n    // HTTP-network-or-cache fetch given fetchParams.\n\n\n    actualResponse = response = await httpNetworkOrCacheFetch.call(this, fetchParams); // 4. If request’s response tainting is \"cors\" and a CORS check\n    // for request and response returns failure, then return a network error.\n\n    if (request.responseTainting === 'cors' && corsCheck(request, response) === 'failure') {\n      return makeNetworkError('cors failure');\n    } // 5. If the TAO check for request and response returns failure, then set\n    // request’s timing allow failed flag.\n\n\n    if (TAOCheck(request, response) === 'failure') {\n      request.timingAllowFailed = true;\n    }\n  } // 7. If either request’s response tainting or response’s type\n  // is \"opaque\", and the cross-origin resource policy check with\n  // request’s origin, request’s client, request’s destination,\n  // and actualResponse returns blocked, then return a network error.\n\n\n  if ((request.responseTainting === 'opaque' || response.type === 'opaque') && crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === 'blocked') {\n    return makeNetworkError('blocked');\n  } // 8. If actualResponse’s status is a redirect status, then:\n\n\n  if (redirectStatus.includes(actualResponse.status)) {\n    // 1. If actualResponse’s status is not 303, request’s body is not null,\n    // and the connection uses HTTP/2, then user agents may, and are even\n    // encouraged to, transmit an RST_STREAM frame.\n    // See, https://github.com/whatwg/fetch/issues/1288\n    context.connection.destroy(); // 2. Switch on request’s redirect mode:\n\n    if (request.redirect === 'error') {\n      // Set response to a network error.\n      response = makeNetworkError();\n    } else if (request.redirect === 'manual') {\n      // Set response to an opaque-redirect filtered response whose internal\n      // response is actualResponse.\n      // NOTE(spec): On the web this would return an `opaqueredirect` response,\n      // but that doesn't make sense server side.\n      // See https://github.com/nodejs/undici/issues/1193.\n      response = actualResponse;\n    } else if (request.redirect === 'follow') {\n      // Set response to the result of running HTTP-redirect fetch given\n      // fetchParams and response.\n      response = await httpRedirectFetch.call(this, fetchParams, response);\n    } else {\n      assert(false);\n    }\n  } // 9. Set response’s timing info to timingInfo.\n\n\n  response.timingInfo = timingInfo; // 10. Return response.\n\n  return response;\n} // https://fetch.spec.whatwg.org/#http-redirect-fetch\n\n\nasync function httpRedirectFetch(fetchParams, response) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request; // 2. Let actualResponse be response, if response is not a filtered response,\n  // and response’s internal response otherwise.\n\n  const actualResponse = response.internalResponse ? response.internalResponse : response; // 3. Let locationURL be actualResponse’s location URL given request’s current\n  // URL’s fragment.\n\n  let locationURL;\n\n  try {\n    locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash); // 4. If locationURL is null, then return response.\n\n    if (locationURL == null) {\n      return response;\n    }\n  } catch (err) {\n    // 5. If locationURL is failure, then return a network error.\n    return makeNetworkError(err);\n  } // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network\n  // error.\n\n\n  if (!/^https?:/.test(locationURL.protocol)) {\n    return makeNetworkError('URL scheme must be a HTTP(S) scheme');\n  } // 7. If request’s redirect count is twenty, return a network error.\n\n\n  if (request.redirectCount === 20) {\n    return makeNetworkError('redirect count exceeded');\n  } // 8. Increase request’s redirect count by one.\n\n\n  request.redirectCount += 1; // 9. If request’s mode is \"cors\", locationURL includes credentials, and\n  // request’s origin is not same origin with locationURL’s origin, then return\n  //  a network error.\n\n  if (request.mode === 'cors' && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {\n    return makeNetworkError('cross origin not allowed for request mode \"cors\"');\n  } // 10. If request’s response tainting is \"cors\" and locationURL includes\n  // credentials, then return a network error.\n\n\n  if (request.responseTainting === 'cors' && (locationURL.username || locationURL.password)) {\n    return makeNetworkError('URL cannot contain credentials for request mode \"cors\"');\n  } // 11. If actualResponse’s status is not 303, request’s body is non-null,\n  // and request’s body’s source is null, then return a network error.\n\n\n  if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {\n    return makeNetworkError();\n  } // 12. If one of the following is true\n  // - actualResponse’s status is 301 or 302 and request’s method is `POST`\n  // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`\n\n\n  if ([301, 302].includes(actualResponse.status) && request.method === 'POST' || actualResponse.status === 303 && !['GET', 'HEADER'].includes(request.method)) {\n    // then:\n    // 1. Set request’s method to `GET` and request’s body to null.\n    request.method = 'GET';\n    request.body = null; // 2. For each headerName of request-body-header name, delete headerName from\n    // request’s header list.\n\n    for (const headerName of requestBodyHeader) {\n      request.headersList.delete(headerName);\n    }\n  } // 13. If request’s body is non-null, then set request’s body to the first return\n  // value of safely extracting request’s body’s source.\n\n\n  if (request.body != null) {\n    assert(request.body.source);\n    request.body = safelyExtractBody(request.body.source)[0];\n  } // 14. Let timingInfo be fetchParams’s timing info.\n\n\n  const timingInfo = fetchParams.timingInfo; // 15. Set timingInfo’s redirect end time and post-redirect start time to the\n  // coarsened shared current time given fetchParams’s cross-origin isolated\n  // capability.\n\n  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability); // 16. If timingInfo’s redirect start time is 0, then set timingInfo’s\n  //  redirect start time to timingInfo’s start time.\n\n  if (timingInfo.redirectStartTime === 0) {\n    timingInfo.redirectStartTime = timingInfo.startTime;\n  } // 17. Append locationURL to request’s URL list.\n\n\n  request.urlList.push(locationURL); // 18. Invoke set request’s referrer policy on redirect on request and\n  // actualResponse.\n\n  setRequestReferrerPolicyOnRedirect(request, actualResponse); // 19. Return the result of running main fetch given fetchParams and true.\n\n  return mainFetch.call(this, fetchParams, true);\n} // https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\n\n\nasync function httpNetworkOrCacheFetch(fetchParams) {\n  let isAuthenticationFetch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let isNewConnectionFetch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const context = this; // 1. Let request be fetchParams’s request.\n\n  const request = fetchParams.request; // 2. Let httpFetchParams be null.\n\n  let httpFetchParams = null; // 3. Let httpRequest be null.\n\n  let httpRequest = null; // 4. Let response be null.\n\n  let response = null; // 5. Let storedResponse be null.\n  // TODO: cache\n  // 6. Let httpCache be null.\n\n  const httpCache = null; // 7. Let the revalidatingFlag be unset.\n\n  const revalidatingFlag = false; // 8. Run these steps, but abort when the ongoing fetch is terminated:\n  //    1. If request’s window is \"no-window\" and request’s redirect mode is\n  //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n  //    request.\n\n  if (request.window === 'no-window' && request.redirect === 'error') {\n    httpFetchParams = fetchParams;\n    httpRequest = request;\n  } else {\n    // Otherwise:\n    // 1. Set httpRequest to a clone of request.\n    httpRequest = makeRequest(request); // 2. Set httpFetchParams to a copy of fetchParams.\n\n    httpFetchParams = { ...fetchParams\n    }; // 3. Set httpFetchParams’s request to httpRequest.\n\n    httpFetchParams.request = httpRequest;\n  } //    3. Let includeCredentials be true if one of\n\n\n  const includeCredentials = request.credentials === 'include' || request.credentials === 'same-origin' && request.responseTainting === 'basic'; //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s\n  //    body is non-null; otherwise null.\n\n  const contentLength = httpRequest.body ? httpRequest.body.length : null; //    5. Let contentLengthHeaderValue be null.\n\n  let contentLengthHeaderValue = null; //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or\n  //    `PUT`, then set contentLengthHeaderValue to `0`.\n\n  if (httpRequest.body == null && ['POST', 'PUT'].includes(httpRequest.method)) {\n    contentLengthHeaderValue = '0';\n  } //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n  //    contentLength, serialized and isomorphic encoded.\n\n\n  if (contentLength != null) {\n    // TODO: isomorphic encoded\n    contentLengthHeaderValue = String(contentLength);\n  } //    8. If contentLengthHeaderValue is non-null, then append\n  //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header\n  //    list.\n\n\n  if (contentLengthHeaderValue != null) {\n    httpRequest.headersList.append('content-length', contentLengthHeaderValue);\n  } //    9. If contentLength is non-null and httpRequest’s keepalive is true,\n  //    then:\n\n\n  if (contentLength != null && httpRequest.keepalive) {// NOTE: keepalive is a noop outside of browser context.\n  } //    10 .If httpRequest’s referrer is a URL, then append\n  //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,\n  //     to httpRequest’s header list.\n\n\n  if (httpRequest.referrer instanceof URL) {\n    // TODO: isomorphic encoded\n    httpRequest.headersList.append('referer', httpRequest.referrer.href);\n  } //    11. Append a request `Origin` header for httpRequest.\n\n\n  appendRequestOriginHeader(httpRequest); //    12. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n\n  appendFetchMetadata(httpRequest); //    13. If httpRequest’s header list does not contain `User-Agent`, then\n  //    user agents should append `User-Agent`/default `User-Agent` value to\n  //    httpRequest’s header list.\n\n  if (!httpRequest.headersList.has('user-agent')) {\n    httpRequest.headersList.append('user-agent', 'undici');\n  } //    14. If httpRequest’s cache mode is \"default\" and httpRequest’s header\n  //    list contains `If-Modified-Since`, `If-None-Match`,\n  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n  //    httpRequest’s cache mode to \"no-store\".\n\n\n  if (httpRequest.cache === 'default' && (httpRequest.headersList.has('if-modified-since') || httpRequest.headersList.has('if-none-match') || httpRequest.headersList.has('if-unmodified-since') || httpRequest.headersList.has('if-match') || httpRequest.headersList.has('if-range'))) {\n    httpRequest.cache = 'no-store';\n  } //    15. If httpRequest’s cache mode is \"no-cache\", httpRequest’s prevent\n  //    no-cache cache-control header modification flag is unset, and\n  //    httpRequest’s header list does not contain `Cache-Control`, then append\n  //    `Cache-Control`/`max-age=0` to httpRequest’s header list.\n\n\n  if (httpRequest.cache === 'no-cache' && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.has('cache-control')) {\n    httpRequest.headersList.append('cache-control', 'max-age=0');\n  } //    16. If httpRequest’s cache mode is \"no-store\" or \"reload\", then:\n\n\n  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {\n    // 1. If httpRequest’s header list does not contain `Pragma`, then append\n    // `Pragma`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.has('pragma')) {\n      httpRequest.headersList.append('pragma', 'no-cache');\n    } // 2. If httpRequest’s header list does not contain `Cache-Control`,\n    // then append `Cache-Control`/`no-cache` to httpRequest’s header list.\n\n\n    if (!httpRequest.headersList.has('cache-control')) {\n      httpRequest.headersList.append('cache-control', 'no-cache');\n    }\n  } //    17. If httpRequest’s header list contains `Range`, then append\n  //    `Accept-Encoding`/`identity` to httpRequest’s header list.\n\n\n  if (httpRequest.headersList.has('range')) {\n    httpRequest.headersList.append('accept-encoding', 'identity');\n  } //    18. Modify httpRequest’s header list per HTTP. Do not append a given\n  //    header if httpRequest’s header list contains that header’s name.\n  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n\n\n  if (!httpRequest.headersList.has('accept-encoding')) {\n    if (/^https:/.test(requestCurrentURL(httpRequest).protocol)) {\n      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate');\n    } else {\n      httpRequest.headersList.append('accept-encoding', 'gzip, deflate');\n    }\n  } //    19. If includeCredentials is true, then:\n\n\n  if (includeCredentials) {// 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequest’s header list does not contain `Authorization`, then:\n    // TODO: credentials\n  } //    20. If there’s a proxy-authentication entry, use it as appropriate.\n  //    TODO: proxy-authentication\n  //    21. Set httpCache to the result of determining the HTTP cache\n  //    partition, given httpRequest.\n  //    TODO: cache\n  //    22. If httpCache is null, then set httpRequest’s cache mode to\n  //    \"no-store\".\n\n\n  if (httpCache == null) {\n    httpRequest.cache = 'no-store';\n  } //    23. If httpRequest’s cache mode is neither \"no-store\" nor \"reload\",\n  //    then:\n\n\n  if (httpRequest.mode !== 'no-store' && httpRequest.mode !== 'reload') {// TODO: cache\n  } // 9. If aborted, then:\n  // TODO\n  // 10. If response is null, then:\n\n\n  if (response == null) {\n    // 1. If httpRequest’s cache mode is \"only-if-cached\", then return a\n    // network error.\n    if (httpRequest.mode === 'only-if-cached') {\n      return makeNetworkError('only if cached');\n    } // 2. Let forwardResponse be the result of running HTTP-network fetch\n    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n\n\n    const forwardResponse = await httpNetworkFetch.call(this, httpFetchParams, includeCredentials, isNewConnectionFetch); // 3. If httpRequest’s method is unsafe and forwardResponse’s status is\n    // in the range 200 to 399, inclusive, invalidate appropriate stored\n    // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n    // Caching, and set storedResponse to null. [HTTP-CACHING]\n\n    if (!safeMethods.includes(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {// TODO: cache\n    } // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,\n    // then:\n\n\n    if (revalidatingFlag && forwardResponse.status === 304) {// TODO: cache\n    } // 5. If response is null, then:\n\n\n    if (response == null) {\n      // 1. Set response to forwardResponse.\n      response = forwardResponse; // 2. Store httpRequest and forwardResponse in httpCache, as per the\n      // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n      // TODO: cache\n    }\n  } // 11. Set response’s URL list to a clone of httpRequest’s URL list.\n\n\n  response.urlList = [...httpRequest.urlList]; // 12. If httpRequest’s header list contains `Range`, then set response’s\n  // range-requested flag.\n\n  if (httpRequest.headersList.has('range')) {\n    response.rangeRequested = true;\n  } // 13. If response’s status is 401, httpRequest’s response tainting is not\n  // \"cors\", includeCredentials is true, and request’s window is an environment\n  // settings object, then:\n  // TODO\n  // 14. If response’s status is 407, then:\n\n\n  if (response.status === 407) {\n    // 1. If request’s window is \"no-window\", then return a network error.\n    if (request.window === 'no-window') {\n      return makeNetworkError();\n    } // 2. ???\n    // 3. If the ongoing fetch is terminated, then:\n\n\n    if (context.terminated) {\n      // 1. Let aborted be the termination’s aborted flag.\n      const aborted = context.terminated.aborted; // 2. If aborted is set, then return an aborted network error.\n\n      if (aborted) {\n        return makeNetworkError(new AbortError());\n      } // 3. Return a network error.\n\n\n      return makeNetworkError(context.terminated.reason);\n    } // 4. Prompt the end user as appropriate in request’s window and store\n    // the result as a proxy-authentication entry. [HTTP-AUTH]\n    // TODO: Invoke some kind of callback?\n    // 5. Set response to the result of running HTTP-network-or-cache fetch given\n    // fetchParams.\n    // TODO\n\n\n    return makeNetworkError('proxy authentication required');\n  } // 15. If all of the following are true\n\n\n  if ( // response’s status is 421\n  response.status === 421 && // isNewConnectionFetch is false\n  !isNewConnectionFetch && ( // request’s body is null, or request’s body is non-null and request’s body’s source is non-null\n  request.body == null || request.body.source != null)) {\n    // then:\n    // 1. If the ongoing fetch is terminated, then:\n    if (context.terminated) {\n      // 1. Let aborted be the termination’s aborted flag.\n      const aborted = context.terminated.aborted; // 2. If aborted is set, then return an aborted network error.\n\n      if (aborted) {\n        return makeNetworkError(new AbortError());\n      } // 3. Return a network error.\n\n\n      return makeNetworkError(context.terminated.reason);\n    } // 2. Set response to the result of running HTTP-network-or-cache\n    // fetch given fetchParams, isAuthenticationFetch, and true.\n    // TODO (spec): The spec doesn't specify this but we need to cancel\n    // the active response before we can start a new one.\n    // https://github.com/whatwg/fetch/issues/1293\n\n\n    context.connection.destroy();\n    response = await httpNetworkOrCacheFetch.call(this, fetchParams, isAuthenticationFetch, true);\n  } // 16. If isAuthenticationFetch is true, then create an authentication entry\n\n\n  if (isAuthenticationFetch) {// TODO\n  } // 17. Return response.\n\n\n  return response;\n} // https://fetch.spec.whatwg.org/#http-network-fetch\n\n\nfunction httpNetworkFetch(fetchParams) {\n  let includeCredentials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let forceNewConnection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const context = this;\n  return new Promise(resolve => {\n    assert(!context.connection || context.connection.destroyed);\n    context.connection = {\n      abort: null,\n      destroyed: false,\n\n      destroy(err) {\n        if (!this.destroyed) {\n          this.destroyed = true;\n          this.abort?.(err ?? new AbortError());\n        }\n      }\n\n    }; // 1. Let request be fetchParams’s request.\n\n    const request = fetchParams.request; // 2. Let response be null.\n\n    let response = null; // 3. Let timingInfo be fetchParams’s timing info.\n\n    const timingInfo = fetchParams.timingInfo; // 4. Let httpCache be the result of determining the HTTP cache partition,\n    // given request.\n    // TODO: cache\n\n    const httpCache = null; // 5. If httpCache is null, then set request’s cache mode to \"no-store\".\n\n    if (httpCache == null) {\n      request.cache = 'no-store';\n    } // 6. Let networkPartitionKey be the result of determining the network\n    // partition key given request.\n    // TODO\n    // 7. Switch on request’s mode:\n\n\n    if (request.mode === 'websocket') {// Let connection be the result of obtaining a WebSocket connection,\n      // given request’s current URL.\n      // TODO\n    } else {// Let connection be the result of obtaining a connection, given\n      // networkPartitionKey, request’s current URL’s origin,\n      // includeCredentials, and forceNewConnection.\n      // TODO\n    } // 8. Run these steps, but abort when the ongoing fetch is terminated:\n    // TODO: When do we cleanup this listener?\n\n\n    context.on('terminated', onRequestAborted); //    5. Set response to the result of making an HTTP request over connection\n    //    using request with the following caveats:\n    //    Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n    //    [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n    //    If request’s body is non-null, and request’s body’s source is null,\n    //    then the user agent may have a buffer of up to 64 kibibytes and store\n    //    a part of request’s body in that buffer. If the user agent reads from\n    //    request’s body beyond that buffer’s size and the user agent needs to\n    //    resend request, then instead return a network error.\n    //    TODO\n    //    Set timingInfo’s final network-response start time to the coarsened\n    //    shared current time given fetchParams’s cross-origin isolated capability,\n    //    immediately after the user agent’s HTTP parser receives the first byte\n    //    of the response (e.g., frame header bytes for HTTP/2 or response status\n    //    line for HTTP/1.x).\n    //    TODO\n    //    Wait until all the headers are transmitted.\n    //    Any responses whose status is in the range 100 to 199, inclusive,\n    //    and is not 101, are to be ignored, except for the purposes of setting\n    //    timingInfo’s final network-response start time above.\n    //    If request’s header list contains `Transfer-Encoding`/`chunked` and\n    //    response is transferred via HTTP/1.0 or older, then return a network\n    //    error.\n    //    If the HTTP request results in a TLS client certificate dialog, then:\n    //        1. If request’s window is an environment settings object, make the\n    //        dialog available in request’s window.\n    //        2. Otherwise, return a network error.\n    // To transmit request’s body body, run these steps:\n\n    const body = async function* () {\n      try {\n        // 1. If body is null and fetchParams’s process request end-of-body is\n        // non-null, then queue a fetch task given fetchParams’s process request\n        // end-of-body and fetchParams’s task destination.\n        if (request.body === null) {\n          fetchParams.processEndOfBody?.();\n          return;\n        } // 2. Otherwise, if body is non-null:\n        //    1. Let processBodyChunk given bytes be these steps:\n\n\n        for await (const bytes of request.body.stream) {\n          // 1. If the ongoing fetch is terminated, then abort these steps.\n          if (context.terminated) {\n            return;\n          } // 2. Run this step in parallel: transmit bytes.\n\n\n          yield bytes; // 3. If fetchParams’s process request body is non-null, then run\n          // fetchParams’s process request body given bytes’s length.\n\n          fetchParams.processRequestBody?.(bytes.byteLength);\n        } // 2. Let processEndOfBody be these steps:\n        //    1. If the ongoing fetch is terminated, then abort these steps.\n\n\n        if (context.terminated) {\n          return;\n        } //    2. If fetchParams’s process request end-of-body is non-null,\n        //    then run fetchParams’s process request end-of-body.\n\n\n        fetchParams.processRequestEndOfBody?.();\n      } catch (e) {\n        // 3. Let processBodyError given e be these steps:\n        //    1. If the ongoing fetch is terminated, then abort these steps.\n        if (context.terminated) {\n          return;\n        } //    2. If e is an \"AbortError\" DOMException, then terminate the ongoing fetch with the aborted flag set.\n        //    3. Otherwise, terminate the ongoing fetch.\n\n\n        context.terminate({\n          aborted: e.name === 'AbortError',\n          reason: e\n        });\n      }\n    }(); // 9. If aborted, then:\n\n\n    function onRequestAborted() {\n      // 1. Let aborted be the termination’s aborted flag.\n      const aborted = this.terminated.aborted; // 2. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n\n      this.connection.destroy(); // 3. If aborted is set, then return an aborted network error.\n\n      if (aborted) {\n        return resolve(makeNetworkError(new AbortError()));\n      } // 4. Return a network error.\n\n\n      return resolve(makeNetworkError(this.terminated.reason));\n    } // 10. Let pullAlgorithm be an action that resumes the ongoing fetch\n    // if it is suspended.\n\n\n    let pullAlgorithm; // 11. Let cancelAlgorithm be an action that terminates the ongoing\n    // fetch with the aborted flag set.\n\n    const cancelAlgorithm = () => {\n      context.terminate({\n        aborted: true\n      });\n    }; // 12. Let highWaterMark be a non-negative, non-NaN number, chosen by\n    // the user agent.\n\n\n    const highWaterMark = 64 * 1024; // Same as nodejs fs streams.\n    // 13. Let sizeAlgorithm be an algorithm that accepts a chunk object\n    // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n    // TODO\n    // 14. Let stream be a new ReadableStream.\n    // 15. Set up stream with pullAlgorithm set to pullAlgorithm,\n    // cancelAlgorithm set to cancelAlgorithm, highWaterMark set to\n    // highWaterMark, and sizeAlgorithm set to sizeAlgorithm.\n\n    if (!ReadableStream) {\n      ReadableStream = require('stream/web').ReadableStream;\n    }\n\n    let pullResolve;\n    const stream = new ReadableStream({\n      async start(controller) {\n        context.controller = controller;\n      },\n\n      async pull(controller) {\n        if (!pullAlgorithm) {\n          await new Promise(resolve => {\n            pullResolve = resolve;\n          });\n        }\n\n        await pullAlgorithm(controller);\n      },\n\n      async cancel(reason) {\n        await cancelAlgorithm(reason);\n      }\n\n    }, {\n      highWaterMark\n    }); // 16. Run these steps, but abort when the ongoing fetch is terminated:\n    // TODO\n    // 17. If aborted, then:\n    // TODO: How can this happen? The steps above are not async?\n    // 18. Run these steps in parallel:\n    //    1. Run these steps, but abort when the ongoing fetch is terminated:\n    //        1. While true:\n    //            1. If one or more bytes have been transmitted from response’s\n    //            message body, then:\n    //            NOTE: See onHeaders\n    //            2. Otherwise, if the bytes transmission for response’s message\n    //            body is done normally and stream is readable, then close stream,\n    //            finalize response for fetchParams and response, and abort these\n    //            in-parallel steps.\n    //            NOTE: See onHeaders\n    //    2. If aborted, then:\n\n    function onResponseAborted() {\n      // 1. Let aborted be the termination’s aborted flag.\n      const aborted = this.terminated.aborted; // 2. If aborted is set, then:\n\n      if (aborted) {\n        // 1. Set response’s aborted flag.\n        response.aborted = true; // 2. If stream is readable, error stream with an \"AbortError\" DOMException.\n\n        if (isReadable(stream)) {\n          this.controller.error(new AbortError());\n        }\n      } else {\n        // 3. Otherwise, if stream is readable, error stream with a TypeError.\n        if (isReadable(stream)) {\n          this.controller.error(new TypeError('terminated'));\n        }\n      } // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n\n\n      this.connection.destroy();\n    } // 19. Return response.\n    // NOTE: See onHeaders\n    // Implementation\n\n\n    const url = requestCurrentURL(request);\n    context.dispatcher.dispatch({\n      path: url.pathname + url.search,\n      origin: url.origin,\n      method: request.method,\n      body: context.dispatcher[kIsMockActive] ? request.body && request.body.source : body,\n      headers: request.headersList,\n      maxRedirections: 0\n    }, {\n      decoder: null,\n      abort: null,\n      context,\n\n      onConnect(abort) {\n        // TODO (fix): Do we need connection here?\n        const {\n          connection\n        } = this.context;\n\n        if (connection.destroyed) {\n          abort(new AbortError());\n        } else {\n          this.abort = connection.abort = abort;\n        }\n      },\n\n      onHeaders(status, headersList, resume, statusText) {\n        if (status < 200) {\n          return;\n        }\n\n        const headers = new Headers();\n\n        for (let n = 0; n < headersList.length; n += 2) {\n          headers.append(headersList[n + 0].toString(), headersList[n + 1].toString());\n        }\n\n        response = makeResponse({\n          status,\n          statusText,\n          headersList: headers[kHeadersList],\n          body: {\n            stream\n          }\n        });\n        this.context.on('terminated', onResponseAborted);\n        const codings = headers.get('content-encoding')?.toLowerCase().split(',').map(x => x.trim()) ?? [];\n        const decoders = []; // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n\n        for (const coding of codings) {\n          if (/(x-)?gzip/.test(coding)) {\n            decoders.push(zlib.createGunzip());\n          } else if (/(x-)?deflate/.test(coding)) {\n            decoders.push(zlib.createInflate());\n          } else if (coding === 'br') {\n            decoders.push(zlib.createBrotliDecompress());\n          } else {\n            decoders.length = 0;\n            break;\n          }\n        }\n\n        if (decoders.length > 1) {\n          pipeline(...decoders, () => {});\n        } else if (decoders.length === 0) {\n          // TODO (perf): Avoid intermediate.\n          decoders.push(new PassThrough());\n        }\n\n        this.decoder = decoders[0].on('drain', resume);\n        const iterator = decoders[decoders.length - 1][Symbol.asyncIterator]();\n\n        pullAlgorithm = async controller => {\n          // 4. Set bytes to the result of handling content codings given\n          // codings and bytes.\n          let bytes;\n\n          try {\n            const {\n              done,\n              value\n            } = await iterator.next();\n            bytes = done ? undefined : value;\n          } catch (err) {\n            if (this.decoder.writableEnded && !timingInfo.encodedBodySize) {\n              // zlib doesn't like empty streams.\n              bytes = undefined;\n            } else {\n              bytes = err;\n            }\n          }\n\n          if (bytes === undefined) {\n            // 2. Otherwise, if the bytes transmission for response’s message\n            // body is done normally and stream is readable, then close\n            // stream, finalize response for fetchParams and response, and\n            // abort these in-parallel steps.\n            finalizeResponse(fetchParams, response);\n            controller.close();\n            return;\n          } // 5. Increase timingInfo’s decoded body size by bytes’s length.\n\n\n          timingInfo.decodedBodySize += bytes?.byteLength ?? 0; // 6. If bytes is failure, then terminate the ongoing fetch.\n\n          if (bytes instanceof Error) {\n            this.context.terminate({\n              reason: bytes\n            });\n            return;\n          } // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n          // into stream.\n\n\n          controller.enqueue(new Uint8Array(bytes)); // 8. If stream is errored, then terminate the ongoing fetch.\n\n          if (isErrored(stream)) {\n            this.context.terminate();\n            return;\n          } // 9. If stream doesn’t need more data ask the user agent to suspend\n          // the ongoing fetch.\n\n\n          return controller.desiredSize > 0;\n        };\n\n        if (pullResolve) {\n          pullResolve();\n          pullResolve = null;\n        }\n\n        resolve(response);\n        return true;\n      },\n\n      onData(chunk) {\n        if (this.context.dump) {\n          return;\n        } //  1. If one or more bytes have been transmitted from response’s\n        //  message body, then:\n        // 1. Let bytes be the transmitted bytes.\n\n\n        const bytes = chunk; // 2. Let codings be the result of extracting header list values\n        // given `Content-Encoding` and response’s header list.\n        // See pullAlgorithm.\n        // 3. Increase timingInfo’s encoded body size by bytes’s length.\n\n        timingInfo.encodedBodySize += bytes.byteLength; // 4. See pullAlgorithm...\n\n        return this.decoder.write(bytes);\n      },\n\n      onComplete() {\n        this.decoder.end();\n      },\n\n      onError(error) {\n        this.decoder?.destroy(error);\n        this.context.terminate({\n          reason: error\n        });\n\n        if (!response) {\n          resolve(makeNetworkError(error));\n        }\n      }\n\n    });\n  });\n}\n\nmodule.exports = fetch;","map":{"version":3,"sources":["/Users/jake/workspace/token-builder/node_modules/undici/lib/fetch/index.js"],"names":["Response","makeNetworkError","filterResponse","makeResponse","require","Headers","Request","makeRequest","zlib","ServiceWorkerGlobalScope","Window","matchRequestIntegrity","makePolicyContainer","clonePolicyContainer","requestBadPort","TAOCheck","appendRequestOriginHeader","responseLocationURL","requestCurrentURL","setRequestReferrerPolicyOnRedirect","tryUpgradeRequestToAPotentiallyTrustworthyURL","createOpaqueTimingInfo","appendFetchMetadata","corsCheck","crossOriginResourcePolicyCheck","determineRequestsReferrer","coarsenedSharedCurrentTime","createDeferredPromise","isBlobLike","CORBCheck","sameOrigin","kState","kHeaders","kGuard","kRealm","AbortError","assert","safelyExtractBody","extractBody","redirectStatus","nullBodyStatus","safeMethods","requestBodyHeader","subresource","kHeadersList","EE","PassThrough","pipeline","isErrored","isReadable","kIsMockActive","dataURLProcessor","resolveObjectURL","ReadableStream","Fetch","constructor","dispatcher","terminated","connection","dump","terminate","reason","aborted","destroy","emit","fetch","length","TypeError","undefined","resource","init","context","p","requestObject","request","signal","abortFetch","call","promise","globalObject","client","serviceWorkers","responseObject","relevantRealm","locallyAborted","addEventListener","once","handleFetchDone","response","finalizeAndReportTiming","processResponse","type","reject","Object","assign","cause","error","headersList","resolve","fetching","processResponseEndOfBody","catch","err","initiatorType","urlList","originalURL","timingInfo","cacheState","test","protocol","timingAllowPassed","startTime","endTime","markResourceTiming","globalThis","body","stream","cancel","code","processRequestBodyChunkLength","processRequestEndOfBody","processResponseConsumeBody","useParallelQueue","taskDestination","crossOriginIsolatedCapability","currenTime","fetchParams","window","origin","policyContainer","has","value","append","priority","includes","destination","mainFetch","recursive","localURLsOnly","referrerPolicy","referrer","currentURL","url","responseTainting","mode","schemeFetch","redirect","noCorsResponse","status","httpFetch","internalResponse","push","timingAllowFailed","rangeRequested","headers","method","integrity","processBodyError","fetchFinale","processBody","bytes","arrayBuffer","scheme","pathname","path","URL","resp","statusText","on","onRequestAborted","search","blob","toString","set","size","off","dataURLStruct","mimeType","contentType","subtype","contentTypeParams","parameters","key","join","finalizeResponse","done","processResponseDone","actualResponse","httpNetworkOrCacheFetch","httpRedirectFetch","locationURL","hash","redirectCount","username","password","source","headerName","delete","redirectEndTime","postRedirectStartTime","redirectStartTime","isAuthenticationFetch","isNewConnectionFetch","httpFetchParams","httpRequest","httpCache","revalidatingFlag","includeCredentials","credentials","contentLength","contentLengthHeaderValue","String","keepalive","href","cache","preventNoCacheCacheControlHeaderModification","forwardResponse","httpNetworkFetch","forceNewConnection","Promise","destroyed","abort","processEndOfBody","processRequestBody","byteLength","e","name","pullAlgorithm","cancelAlgorithm","highWaterMark","pullResolve","start","controller","pull","onResponseAborted","dispatch","maxRedirections","decoder","onConnect","onHeaders","resume","n","codings","get","toLowerCase","split","map","x","trim","decoders","coding","createGunzip","createInflate","createBrotliDecompress","iterator","Symbol","asyncIterator","next","writableEnded","encodedBodySize","close","decodedBodySize","Error","enqueue","Uint8Array","desiredSize","onData","chunk","write","onComplete","end","onError","module","exports"],"mappings":"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","sourcesContent":["// https://github.com/Ethan-Arrowood/undici-fetch\n\n'use strict'\n\nconst {\n  Response,\n  makeNetworkError,\n  filterResponse,\n  makeResponse\n} = require('./response')\nconst { Headers } = require('./headers')\nconst { Request, makeRequest } = require('./request')\nconst zlib = require('zlib')\nconst {\n  ServiceWorkerGlobalScope,\n  Window,\n  matchRequestIntegrity,\n  makePolicyContainer,\n  clonePolicyContainer,\n  requestBadPort,\n  TAOCheck,\n  appendRequestOriginHeader,\n  responseLocationURL,\n  requestCurrentURL,\n  setRequestReferrerPolicyOnRedirect,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  createOpaqueTimingInfo,\n  appendFetchMetadata,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  determineRequestsReferrer,\n  coarsenedSharedCurrentTime,\n  createDeferredPromise,\n  isBlobLike,\n  CORBCheck,\n  sameOrigin\n} = require('./util')\nconst { kState, kHeaders, kGuard, kRealm } = require('./symbols')\nconst { AbortError } = require('../core/errors')\nconst assert = require('assert')\nconst { safelyExtractBody, extractBody } = require('./body')\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  safeMethods,\n  requestBodyHeader,\n  subresource\n} = require('./constants')\nconst { kHeadersList } = require('../core/symbols')\nconst EE = require('events')\nconst { PassThrough, pipeline } = require('stream')\nconst { isErrored, isReadable } = require('../core/util')\nconst { kIsMockActive } = require('../mock/mock-symbols')\nconst { dataURLProcessor } = require('./dataURL')\n\n/** @type {import('buffer').resolveObjectURL} */\nlet resolveObjectURL\nlet ReadableStream\n\nclass Fetch extends EE {\n  constructor (dispatcher) {\n    super()\n\n    this.dispatcher = dispatcher\n    this.terminated = null\n    this.connection = null\n    this.dump = false\n  }\n\n  terminate ({ reason, aborted } = {}) {\n    if (this.terminated) {\n      return\n    }\n    this.terminated = { aborted, reason }\n\n    this.connection?.destroy(reason)\n\n    this.emit('terminated', reason)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-method\nasync function fetch (...args) {\n  if (args.length < 1) {\n    throw new TypeError(\n      `Failed to execute 'fetch' on 'Window': 1 argument required, but only ${args.length} present.`\n    )\n  }\n  if (\n    args.length >= 1 &&\n    typeof args[1] !== 'object' &&\n    args[1] !== undefined\n  ) {\n    throw new TypeError(\n      \"Failed to execute 'fetch' on 'Window': cannot convert to dictionary.\"\n    )\n  }\n\n  const resource = args[0]\n  const init = args.length >= 1 ? args[1] ?? {} : {}\n\n  const context = new Fetch(this)\n\n  // 1. Let p be a new promise.\n  const p = createDeferredPromise()\n\n  // 2. Let requestObject be the result of invoking the initial value of\n  // Request as constructor with input and init as arguments. If this throws\n  // an exception, reject p with it and return p.\n  const requestObject = new Request(resource, init)\n\n  // 3. Let request be requestObject’s request.\n  const request = requestObject[kState]\n\n  // 4. If requestObject’s signal’s aborted flag is set, then:\n  if (requestObject.signal.aborted) {\n    // 1. Abort fetch with p, request, and null.\n    abortFetch.call(context, p, request, null)\n\n    // 2. Return p.\n    return p.promise\n  }\n\n  // 5. Let globalObject be request’s client’s global object.\n  // TODO: What if request.client is null?\n  const globalObject = request.client?.globalObject\n\n  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n  // request’s service-workers mode to \"none\".\n  if (globalObject instanceof ServiceWorkerGlobalScope) {\n    request.serviceWorkers = 'none'\n  }\n\n  // 7. Let responseObject be null.\n  let responseObject = null\n\n  // 8. Let relevantRealm be this’s relevant Realm.\n  const relevantRealm = null\n\n  // 9. Let locallyAborted be false.\n  let locallyAborted = false\n\n  // 10. Add the following abort steps to requestObject’s signal:\n  requestObject.signal.addEventListener(\n    'abort',\n    () => {\n      // 1. Set locallyAborted to true.\n      locallyAborted = true\n\n      // 2. Abort fetch with p, request, and responseObject.\n      abortFetch.call(context, p, request, responseObject)\n\n      // 3. Terminate the ongoing fetch with the aborted flag set.\n      context.terminate({ aborted: true })\n    },\n    { once: true }\n  )\n\n  // 11. Let handleFetchDone given response response be to finalize and\n  // report timing with response, globalObject, and \"fetch\".\n  const handleFetchDone = (response) =>\n    finalizeAndReportTiming(response, 'fetch')\n\n  // 12. Fetch request with processResponseEndOfBody set to handleFetchDone,\n  // and processResponse given response being these substeps:\n  const processResponse = (response) => {\n    // 1. If locallyAborted is true, terminate these substeps.\n    if (locallyAborted) {\n      return\n    }\n\n    // 2. If response’s aborted flag is set, then abort fetch with p,\n    // request, and responseObject, and terminate these substeps.\n    if (response.aborted) {\n      abortFetch.call(context, p, request, responseObject)\n      return\n    }\n\n    // 3. If response is a network error, then reject p with a TypeError\n    // and terminate these substeps.\n    if (response.type === 'error') {\n      p.reject(\n        Object.assign(new TypeError('fetch failed'), { cause: response.error })\n      )\n      return\n    }\n\n    // 4. Set responseObject to the result of creating a Response object,\n    // given response, \"immutable\", and relevantRealm.\n    responseObject = new Response()\n    responseObject[kState] = response\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kHeadersList] = response.headersList\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 5. Resolve p with responseObject.\n    p.resolve(responseObject)\n  }\n\n  fetching\n    .call(context, {\n      request,\n      processResponseEndOfBody: handleFetchDone,\n      processResponse\n    })\n    .catch((err) => {\n      p.reject(err)\n    })\n\n  // 13. Return p.\n  return p.promise\n}\n\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming (response, initiatorType = 'other') {\n  // 1. If response is an aborted network error, then return.\n  if (response.type === 'error' && response.aborted) {\n    return\n  }\n\n  // 2. If response’s URL list is null or empty, then return.\n  if (!response.urlList?.length) {\n    return\n  }\n\n  // 3. Let originalURL be response’s URL list[0].\n  const originalURL = response.urlList[0]\n\n  // 4. Let timingInfo be response’s timing info.\n  let timingInfo = response.timingInfo\n\n  // 5. Let cacheState be response’s cache state.\n  let cacheState = response.cacheState\n\n  // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.\n  if (!/^https?:/.test(originalURL.protocol)) {\n    return\n  }\n\n  // 7. If timingInfo is null, then return.\n  if (timingInfo === null) {\n    return\n  }\n\n  // 8. If response’s timing allow passed flag is not set, then:\n  if (!timingInfo.timingAllowPassed) {\n    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n    timingInfo = createOpaqueTimingInfo({\n      startTime: timingInfo.startTime\n    })\n\n    //  2. Set cacheState to the empty string.\n    cacheState = ''\n  }\n\n  // 9. Set timingInfo’s end time to the coarsened shared current time\n  // given global’s relevant settings object’s cross-origin isolated\n  // capability.\n  // TODO: given global’s relevant settings object’s cross-origin isolated\n  // capability?\n  response.timingInfo.endTime = coarsenedSharedCurrentTime()\n\n  // 10. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n  // global, and cacheState.\n  markResourceTiming(\n    timingInfo,\n    originalURL,\n    initiatorType,\n    globalThis,\n    cacheState\n  )\n}\n\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nfunction markResourceTiming () {\n  // TODO\n}\n\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch (p, request, responseObject) {\n  // 1. Let error be an \"AbortError\" DOMException.\n  const error = new AbortError()\n\n  // 2. Reject promise with error.\n  p.reject(error)\n\n  // 3. If request’s body is not null and is readable, then cancel request’s\n  // body with error.\n  if (request.body != null && isReadable(request.body?.stream)) {\n    request.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n\n  // 4. If responseObject is null, then return.\n  if (responseObject == null) {\n    return\n  }\n\n  // 5. Let response be responseObject’s response.\n  const response = responseObject[kState]\n\n  // 6. If response’s body is not null and is readable, then error response’s\n  // body with error.\n  if (response.body != null && isReadable(response.body?.stream)) {\n    response.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching ({\n  request,\n  processRequestBodyChunkLength,\n  processRequestEndOfBody,\n  processResponse,\n  processResponseEndOfBody,\n  processResponseConsumeBody,\n  useParallelQueue = false,\n}) {\n  // 1. Let taskDestination be null.\n  let taskDestination = null\n\n  // 2. Let crossOriginIsolatedCapability be false.\n  let crossOriginIsolatedCapability = false\n\n  // 3. If request’s client is non-null, then:\n  if (request.client != null) {\n    // 1. Set taskDestination to request’s client’s global object.\n    taskDestination = request.client.globalObject\n\n    // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin\n    // isolated capability.\n    crossOriginIsolatedCapability =\n      request.client.crossOriginIsolatedCapability\n  }\n\n  // 4. If useParallelQueue is true, then set taskDestination to the result of\n  // starting a new parallel queue.\n  // TODO\n\n  // 5. Let timingInfo be a new fetch timing info whose start time and\n  // post-redirect start time are the coarsened shared current time given\n  // crossOriginIsolatedCapability.\n  const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability)\n  const timingInfo = createOpaqueTimingInfo({\n    startTime: currenTime\n  })\n\n  // 6. Let fetchParams be a new fetch params whose\n  // request is request,\n  // timing info is timingInfo,\n  // process request body chunk length is processRequestBodyChunkLength,\n  // process request end-of-body is processRequestEndOfBody,\n  // process response is processResponse,\n  // process response consume body is processResponseConsumeBody,\n  // process response end-of-body is processResponseEndOfBody,\n  // task destination is taskDestination,\n  // and cross-origin isolated capability is crossOriginIsolatedCapability.\n  const fetchParams = {\n    request,\n    timingInfo,\n    processRequestBodyChunkLength,\n    processRequestEndOfBody,\n    processResponse,\n    processResponseConsumeBody,\n    processResponseEndOfBody,\n    taskDestination,\n    crossOriginIsolatedCapability\n  }\n\n  // 7. If request’s body is a byte sequence, then set request’s body to the\n  // first return value of safely extracting request’s body.\n  // NOTE: Since fetching is only called from fetch, body should already be\n  // extracted.\n  assert(!request.body || request.body.stream)\n\n  // 8. If request’s window is \"client\", then set request’s window to request’s\n  // client, if request’s client’s global object is a Window object; otherwise\n  // \"no-window\".\n  if (request.window === 'client') {\n    // TODO: What if request.client is null?\n    request.window =\n      request.client?.globalObject instanceof Window\n        ? request.client\n        : 'no-window'\n  }\n\n  // 9. If request’s origin is \"client\", then set request’s origin to request’s\n  // client’s origin.\n  if (request.origin === 'client') {\n    // TODO: What if request.client is null?\n    request.origin = request.client?.origin\n  }\n\n  // 10. If request’s policy container is \"client\", then:\n  if (request.policyContainer === 'client') {\n    // 1. If request’s client is non-null, then set request’s policy\n    // container to a clone of request’s client’s policy container. [HTML]\n    if (request.client != null) {\n      request.policyContainer = clonePolicyContainer(\n        request.client.policyContainer\n      )\n    } else {\n      // 2. Otherwise, set request’s policy container to a new policy\n      // container.\n      request.policyContainer = makePolicyContainer()\n    }\n  }\n\n  // 11. If request’s header list does not contain `Accept`, then:\n  if (!request.headersList.has('accept')) {\n    // 1. Let value be `*/*`.\n    const value = '*/*'\n\n    // 2. A user agent should set value to the first matching statement, if\n    // any, switching on request’s destination:\n    // \"document\"\n    // \"frame\"\n    // \"iframe\"\n    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n    // \"image\"\n    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n    // \"style\"\n    // `text/css,*/*;q=0.1`\n    // TODO\n\n    // 3. Append `Accept`/value to request’s header list.\n    request.headersList.append('accept', value)\n  }\n\n  // 12. If request’s header list does not contain `Accept-Language`, then\n  // user agents should append `Accept-Language`/an appropriate value to\n  // request’s header list.\n  if (!request.headersList.has('accept-language')) {\n    request.headersList.append('accept-language', '*')\n  }\n\n  // 13. If request’s priority is null, then use request’s initiator and\n  // destination appropriately in setting request’s priority to a\n  // user-agent-defined object.\n  if (request.priority === null) {\n    // TODO\n  }\n\n  // 14. If request is a subresource request, then:\n  if (subresource.includes(request.destination)) {\n    // 1. Let record be a new fetch record consisting of request and this\n    // instance of the fetch algorithm.\n    // TODO\n    // 2. Append record to request’s client’s fetch group list of fetch\n    // records.\n    // TODO\n  }\n\n  // 15. Run main fetch given fetchParams.\n  return mainFetch.call(this, fetchParams)\n}\n\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch (fetchParams, recursive = false) {\n  const context = this\n\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. If request’s local-URLs-only flag is set and request’s current URL is\n  // not local, then set response to a network error.\n  if (\n    request.localURLsOnly &&\n    !/^(about|blob|data):/.test(requestCurrentURL(request).protocol)\n  ) {\n    response = makeNetworkError('local URLs only')\n  }\n\n  // 4. Run report Content Security Policy violations for request.\n  // TODO\n\n  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n  tryUpgradeRequestToAPotentiallyTrustworthyURL(request)\n\n  // 6. If should request be blocked due to a bad port, should fetching request\n  // be blocked as mixed content, or should request be blocked by Content\n  // Security Policy returns blocked, then set response to a network error.\n  if (requestBadPort(request) === 'blocked') {\n    response = makeNetworkError('bad port')\n  }\n  // TODO: should fetching request be blocked as mixed content?\n  // TODO: should request be blocked by Content Security Policy?\n\n  // 7. If request’s referrer policy is the empty string, then set request’s\n  // referrer policy to request’s policy container’s referrer policy.\n  if (request.referrerPolicy === '') {\n    request.referrerPolicy = request.policyContainer.referrerPolicy\n  }\n\n  // 8. If request’s referrer is not \"no-referrer\", then set request’s\n  // referrer to the result of invoking determine request’s referrer.\n  if (request.referrer !== 'no-referrer') {\n    request.referrer = determineRequestsReferrer(request)\n  }\n\n  // 9. Set request’s current URL’s scheme to \"https\" if all of the following\n  // conditions are true:\n  // - request’s current URL’s scheme is \"http\"\n  // - request’s current URL’s host is a domain\n  // - Matching request’s current URL’s host per Known HSTS Host Domain Name\n  //   Matching results in either a superdomain match with an asserted\n  //   includeSubDomains directive or a congruent match (with or without an\n  //   asserted includeSubDomains directive). [HSTS]\n  // TODO\n\n  // 10. If recursive is false, then run the remaining steps in parallel.\n  // TODO\n\n  // 11. If response is null, then set response to the result of running\n  // the steps corresponding to the first matching statement:\n  if (response === null) {\n    response = await (async () => {\n      const currentURL = requestCurrentURL(request)\n\n      if (\n        // - request’s current URL’s origin is same origin with request’s origin,\n        //   and request’s response tainting is \"basic\"\n        (sameOrigin(currentURL, request.url) && request.responseTainting === 'basic') ||\n        // request’s current URL’s scheme is \"data\"\n        (currentURL.protocol === 'data:') ||\n        // - request’s mode is \"navigate\" or \"websocket\"\n        (request.mode === 'navigate' || request.mode === 'websocket')\n      ) {\n        // 1. Set request’s response tainting to \"basic\".\n        request.responseTainting = 'basic'\n\n        // 2. Return the result of running scheme fetch given fetchParams.\n        return await schemeFetch\n          .call(this, fetchParams)\n      }\n\n      // request’s mode is \"same-origin\"\n      if (request.mode === 'same-origin') {\n        // 1. Return a network error.\n        return makeNetworkError('request mode cannot be \"same-origin\"')\n      }\n\n      // request’s mode is \"no-cors\"\n      if (request.mode === 'no-cors') {\n        // 1. If request’s redirect mode is not \"follow\", then return a network\n        // error.\n        if (request.redirect !== 'follow') {\n          return makeNetworkError(\n            'redirect mode cannot be \"follow\" for \"no-cors\" request'\n          )\n        }\n\n        // 2. Set request’s response tainting to \"opaque\".\n        request.responseTainting = 'opaque'\n\n        // 3. Let noCorsResponse be the result of running scheme fetch given\n        // fetchParams.\n        const noCorsResponse = await schemeFetch\n          .call(this, fetchParams)\n\n        // 4. If noCorsResponse is a filtered response or the CORB check with\n        // request and noCorsResponse returns allowed, then return noCorsResponse.\n        if (noCorsResponse.status === 0 || CORBCheck(request, noCorsResponse) === 'allowed') {\n          return noCorsResponse\n        }\n\n        // 5. Return a new response whose status is noCorsResponse’s status.\n        return makeResponse({ status: noCorsResponse.status })\n      }\n\n      // request’s current URL’s scheme is not an HTTP(S) scheme\n      if (!/^https?:/.test(requestCurrentURL(request).protocol)) {\n        // Return a network error.\n        return makeNetworkError('URL scheme must be a HTTP(S) scheme')\n      }\n\n      // - request’s use-CORS-preflight flag is set\n      // - request’s unsafe-request flag is set and either request’s method is\n      //   not a CORS-safelisted method or CORS-unsafe request-header names with\n      //   request’s header list is not empty\n      //    1. Set request’s response tainting to \"cors\".\n      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n      //    given fetchParams and true.\n      //    3. If corsWithPreflightResponse is a network error, then clear cache\n      //    entries using request.\n      //    4. Return corsWithPreflightResponse.\n      // TODO\n\n      // Otherwise\n      //    1. Set request’s response tainting to \"cors\".\n      request.responseTainting = 'cors'\n\n      //    2. Return the result of running HTTP fetch given fetchParams.\n      return await httpFetch\n        .call(this, fetchParams)\n        .catch((err) => makeNetworkError(err))\n    })()\n  }\n\n  // 12. If recursive is true, then return response.\n  if (recursive) {\n    return response\n  }\n\n  // 13. If response is not a network error and response is not a filtered\n  // response, then:\n  if (response.status !== 0 && !response.internalResponse) {\n    // If request’s response tainting is \"cors\", then:\n    if (request.responseTainting === 'cors') {\n      // 1. Let headerNames be the result of extracting header list values\n      // given `Access-Control-Expose-Headers` and response’s header list.\n      // TODO\n      // 2. If request’s credentials mode is not \"include\" and headerNames\n      // contains `*`, then set response’s CORS-exposed header-name list to\n      // all unique header names in response’s header list.\n      // TODO\n      // 3. Otherwise, if headerNames is not null or failure, then set\n      // response’s CORS-exposed header-name list to headerNames.\n      // TODO\n    }\n\n    // Set response to the following filtered response with response as its\n    // internal response, depending on request’s response tainting:\n    if (request.responseTainting === 'basic') {\n      response = filterResponse(response, 'basic')\n    } else if (request.responseTainting === 'cors') {\n      response = filterResponse(response, 'cors')\n    } else if (request.responseTainting === 'opaque') {\n      response = filterResponse(response, 'opaque')\n    } else {\n      assert(false)\n    }\n  }\n\n  // 14. Let internalResponse be response, if response is a network error,\n  // and response’s internal response otherwise.\n  let internalResponse =\n    response.status === 0 ? response : response.internalResponse\n\n  // 15. If internalResponse’s URL list is empty, then set it to a clone of\n  // request’s URL list.\n  if (internalResponse.urlList.length === 0) {\n    internalResponse.urlList.push(...request.urlList)\n  }\n\n  // 16. If request’s timing allow failed flag is unset, then set\n  // internalResponse’s timing allow passed flag.\n  if (!request.timingAllowFailed) {\n    response.timingAllowPassed = true\n  }\n\n  // 17. If response is not a network error and any of the following returns\n  // blocked\n  // - should internalResponse to request be blocked as mixed content\n  // - should internalResponse to request be blocked by Content Security Policy\n  // - should internalResponse to request be blocked due to its MIME type\n  // - should internalResponse to request be blocked due to nosniff\n  // TODO\n\n  // 18. If response’s type is \"opaque\", internalResponse’s status is 206,\n  // internalResponse’s range-requested flag is set, and request’s header\n  // list does not contain `Range`, then set response and internalResponse\n  // to a network error.\n  if (\n    response.type === 'opaque' &&\n    internalResponse.status === 206 &&\n    internalResponse.rangeRequested &&\n    !request.headers.has('range')\n  ) {\n    response = internalResponse = makeNetworkError()\n  }\n\n  // 19. If response is not a network error and either request’s method is\n  // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,\n  // set internalResponse’s body to null and disregard any enqueuing toward\n  // it (if any).\n  if (\n    response.status !== 0 &&\n    (request.method === 'HEAD' ||\n      request.method === 'CONNECT' ||\n      nullBodyStatus.includes(internalResponse.status))\n  ) {\n    internalResponse.body = null\n    context.dump = true\n  }\n\n  // 20. If request’s integrity metadata is not the empty string, then:\n  if (request.integrity) {\n    // 1. Let processBodyError be this step: run fetch finale given fetchParams\n    // and a network error.\n    const processBodyError = (reason) =>\n      fetchFinale.call(context, fetchParams, makeNetworkError(reason))\n\n    // 2. If request’s response tainting is \"opaque\", or response’s body is null,\n    // then run processBodyError and abort these steps.\n    if (request.responseTainting === 'opaque' || response.body == null) {\n      processBodyError(response.error)\n      return\n    }\n\n    // 3. Let processBody given bytes be these steps:\n    const processBody = (bytes) => {\n      // 1. If bytes do not match request’s integrity metadata,\n      // then run processBodyError and abort these steps. [SRI]\n      if (!matchRequestIntegrity(request, bytes)) {\n        processBodyError('integrity mismatch')\n        return\n      }\n\n      // 2. Set response’s body to the first return value of safely\n      // extracting bytes.\n      response.body = safelyExtractBody(bytes)[0]\n\n      // 3. Run fetch finale given fetchParams and response.\n      fetchFinale.call(context, fetchParams, response)\n    }\n\n    // 4. Fully read response’s body given processBody and processBodyError.\n    try {\n      processBody(await response.arrayBuffer())\n    } catch (err) {\n      processBodyError(err)\n    }\n  } else {\n    // 21. Otherwise, run fetch finale given fetchParams and response.\n    fetchFinale.call(context, fetchParams, response)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nasync function schemeFetch (fetchParams) {\n  const context = this\n\n  // let request be fetchParams’s request\n  const { request } = fetchParams\n\n  const {\n    protocol: scheme,\n    pathname: path\n  } = new URL(requestCurrentURL(request))\n\n  // switch on request’s current URL’s scheme, and run the associated steps:\n  switch (scheme) {\n    case 'about:': {\n      // If request’s current URL’s path is the string \"blank\", then return a new response\n      // whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) », \n      // and body is the empty byte sequence. \n      if (path === 'blank') {\n        const resp = makeResponse({\n          statusText: 'OK',\n          headersList: [\n            'content-type', 'text/html;charset=utf-8'\n          ]\n        })\n        \n        resp.urlList = [new URL('about:blank')]\n        return resp\n      }\n\n      // Otherwise, return a network error.\n      return makeNetworkError('invalid path called')\n    }\n    case 'blob:': {\n      resolveObjectURL ??= require('buffer').resolveObjectURL\n\n      context.on('terminated', onRequestAborted)\n\n      // 1. Run these steps, but abort when the ongoing fetch is terminated: \n      //  1a. Let blob be request’s current URL’s blob URL entry’s object.\n      //      https://w3c.github.io/FileAPI/#blob-url-entry\n      //      P.S. Thank God this method is available in node.\n      const currentURL = requestCurrentURL(request)\n      \n      // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n      // Buffer.resolveObjectURL does not ignore URL queries.\n      if (currentURL.search.length !== 0) {\n        return makeNetworkError('NetworkError when attempting to fetch resource.')\n      }\n\n      const blob = resolveObjectURL(currentURL.toString())\n\n      //  2a. If request’s method is not `GET` or blob is not a Blob object, then return a network error. [FILEAPI]\n      if (request.method !== 'GET' || !isBlobLike(blob)) {\n        return makeNetworkError('invalid method')\n      }\n\n      //  3a. Let response be a new response whose status message is `OK`. \n      const response = makeResponse({ statusText: 'OK', urlList: [currentURL] })\n\n      //  4a. Append (`Content-Length`, blob’s size attribute value) to response’s header list.\n      response.headersList.set('content-length', `${blob.size}`)\n\n      //  5a. Append (`Content-Type`, blob’s type attribute value) to response’s header list.\n      response.headersList.set('content-type', blob.type)\n\n      //  6a. Set response’s body to the result of performing the read operation on blob.\n      response.body = extractBody(blob)[0]\n\n      // since the request has not been aborted, we can safely remove the listener.\n      context.off('terminated', onRequestAborted)\n\n      //  7a. Return response.\n      return response\n\n      // 2. If aborted, then:\n      function onRequestAborted () {\n        // 1. Let aborted be the termination’s aborted flag.\n        const aborted = context.terminated.aborted\n\n        // 2. If aborted is set, then return an aborted network error.\n        if (aborted) {\n          return makeNetworkError(new AbortError())\n        }\n\n        // 3. Return a network error.\n        return makeNetworkError(context.terminated.reason)\n      }\n    }\n    case 'data:': {\n      // 1. Let dataURLStruct be the result of running the\n      //    data: URL processor on request’s current URL.\n      const currentURL = requestCurrentURL(request)\n      const dataURLStruct = dataURLProcessor(currentURL)\n\n      // 2. If dataURLStruct is failure, then return a\n      //    network error.\n      if (dataURLStruct === 'failure') {\n        return makeNetworkError('failed to fetch the data URL')\n      }\n\n      // 3. Let mimeType be dataURLStruct’s MIME type, serialized.\n      const { mimeType } = dataURLStruct\n\n      /** @type {string} */\n      let contentType = `${mimeType.type}/${mimeType.subtype}`\n      const contentTypeParams = []\n\n      if (mimeType.parameters.size > 0) {\n        contentType += ';'\n      }\n\n      for (const [key, value] of mimeType.parameters) {\n        if (value.length > 0) {\n          contentTypeParams.push(`${key}=${value}`)\n        } else {\n          contentTypeParams.push(key)\n        }\n      }\n\n      contentType += contentTypeParams.join(',')\n\n      // 4. Return a response whose status message is `OK`,\n      //    header list is « (`Content-Type`, mimeType) »,\n      //    and body is dataURLStruct’s body.\n      return makeResponse({\n        statusText: 'OK',\n        headersList: [\n          'content-type', contentType\n        ],\n        body: dataURLStruct.body\n      })\n    }\n    case 'file:': {\n      // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n      // When in doubt, return a network error.\n      return makeNetworkError('not implemented... yet...')\n    }\n    case 'http:':\n    case 'https:': {\n      // Return the result of running HTTP fetch given fetchParams.\n\n      return await httpFetch\n        .call(this, fetchParams)\n        .catch((err) => makeNetworkError(err))\n    }\n    default: {\n      return makeNetworkError('unknown scheme')\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse (fetchParams, response) {\n  // 1. Set fetchParams’s request’s done flag.\n  fetchParams.request.done = true\n\n  // 2, If fetchParams’s process response done is not null, then queue a fetch\n  // task to run fetchParams’s process response done given response, with\n  // fetchParams’s task destination.\n  if (fetchParams.processResponseDone != null) {\n    fetchParams.processResponseDone(response)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction fetchFinale (fetchParams, response) {\n  const context = this\n\n  // 1. If response is a network error, then:\n  if (response.type === 'error') {\n    // 1. Set response’s URL list to « fetchParams’s request’s URL list[0] ».\n    response.urlList = [fetchParams.request.urlList[0]]\n\n    // 2. Set response’s timing info to the result of creating an opaque timing\n    // info for fetchParams’s timing info.\n    response.timingInfo = createOpaqueTimingInfo({\n      startTime: fetchParams.timingInfo.startTime\n    })\n  }\n\n  // 2. Let processResponseEndOfBody be the following steps:\n  // TODO\n\n  // 3. If fetchParams’s process response is non-null, then queue a fetch task\n  // to run fetchParams’s process response given response, with fetchParams’s\n  // task destination.\n  if (fetchParams.processResponse != null) {\n    fetchParams.processResponse(response)\n  }\n\n  // 4. If fetchParams’s process response is non-null, then queue a fetch task\n  // to run fetchParams’s process response given response, with fetchParams’s\n  // task destination.\n  // TODO\n\n  // 5. If response’s body is null, then run processResponseEndOfBody.\n  // TODO\n\n  // 6. Otherwise:\n  // TODO\n\n  // 7. If fetchParams’s process response consume body is non-null, then:\n  // TODO\n\n  // TODO: This is a workaround. Until the above has been implemented, i.e.\n  // we need to either fully consume the body or terminate the fetch.\n  if (response.type === 'error') {\n    context.terminate({ reason: response.error })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch (fetchParams) {\n  const context = this\n\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let actualResponse be null.\n  let actualResponse = null\n\n  // 4. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 5. If request’s service-workers mode is \"all\", then:\n  if (request.serviceWorkers === 'all') {\n    // TODO\n  }\n\n  // 6. If response is null, then:\n  if (response === null) {\n    // 1. If makeCORSPreflight is true and one of these conditions is true:\n    // TODO\n\n    // 2. If request’s redirect mode is \"follow\", then set request’s\n    // service-workers mode to \"none\".\n    if (request.redirect === 'follow') {\n      request.serviceWorkers = 'none'\n    }\n\n    // 3. Set response and actualResponse to the result of running\n    // HTTP-network-or-cache fetch given fetchParams.\n    actualResponse = response = await httpNetworkOrCacheFetch.call(\n      this,\n      fetchParams\n    )\n\n    // 4. If request’s response tainting is \"cors\" and a CORS check\n    // for request and response returns failure, then return a network error.\n    if (\n      request.responseTainting === 'cors' &&\n      corsCheck(request, response) === 'failure'\n    ) {\n      return makeNetworkError('cors failure')\n    }\n\n    // 5. If the TAO check for request and response returns failure, then set\n    // request’s timing allow failed flag.\n    if (TAOCheck(request, response) === 'failure') {\n      request.timingAllowFailed = true\n    }\n  }\n\n  // 7. If either request’s response tainting or response’s type\n  // is \"opaque\", and the cross-origin resource policy check with\n  // request’s origin, request’s client, request’s destination,\n  // and actualResponse returns blocked, then return a network error.\n  if (\n    (request.responseTainting === 'opaque' || response.type === 'opaque') &&\n    crossOriginResourcePolicyCheck(\n      request.origin,\n      request.client,\n      request.destination,\n      actualResponse\n    ) === 'blocked'\n  ) {\n    return makeNetworkError('blocked')\n  }\n\n  // 8. If actualResponse’s status is a redirect status, then:\n  if (redirectStatus.includes(actualResponse.status)) {\n    // 1. If actualResponse’s status is not 303, request’s body is not null,\n    // and the connection uses HTTP/2, then user agents may, and are even\n    // encouraged to, transmit an RST_STREAM frame.\n    // See, https://github.com/whatwg/fetch/issues/1288\n    context.connection.destroy()\n\n    // 2. Switch on request’s redirect mode:\n    if (request.redirect === 'error') {\n      // Set response to a network error.\n      response = makeNetworkError()\n    } else if (request.redirect === 'manual') {\n      // Set response to an opaque-redirect filtered response whose internal\n      // response is actualResponse.\n      // NOTE(spec): On the web this would return an `opaqueredirect` response,\n      // but that doesn't make sense server side.\n      // See https://github.com/nodejs/undici/issues/1193.\n      response = actualResponse\n    } else if (request.redirect === 'follow') {\n      // Set response to the result of running HTTP-redirect fetch given\n      // fetchParams and response.\n      response = await httpRedirectFetch.call(this, fetchParams, response)\n    } else {\n      assert(false)\n    }\n  }\n\n  // 9. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 10. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nasync function httpRedirectFetch (fetchParams, response) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let actualResponse be response, if response is not a filtered response,\n  // and response’s internal response otherwise.\n  const actualResponse = response.internalResponse\n    ? response.internalResponse\n    : response\n\n  // 3. Let locationURL be actualResponse’s location URL given request’s current\n  // URL’s fragment.\n  let locationURL\n\n  try {\n    locationURL = responseLocationURL(\n      actualResponse,\n      requestCurrentURL(request).hash\n    )\n\n    // 4. If locationURL is null, then return response.\n    if (locationURL == null) {\n      return response\n    }\n  } catch (err) {\n    // 5. If locationURL is failure, then return a network error.\n    return makeNetworkError(err)\n  }\n\n  // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network\n  // error.\n  if (!/^https?:/.test(locationURL.protocol)) {\n    return makeNetworkError('URL scheme must be a HTTP(S) scheme')\n  }\n\n  // 7. If request’s redirect count is twenty, return a network error.\n  if (request.redirectCount === 20) {\n    return makeNetworkError('redirect count exceeded')\n  }\n\n  // 8. Increase request’s redirect count by one.\n  request.redirectCount += 1\n\n  // 9. If request’s mode is \"cors\", locationURL includes credentials, and\n  // request’s origin is not same origin with locationURL’s origin, then return\n  //  a network error.\n  if (\n    request.mode === 'cors' &&\n    (locationURL.username || locationURL.password) &&\n    !sameOrigin(request, locationURL)\n  ) {\n    return makeNetworkError('cross origin not allowed for request mode \"cors\"')\n  }\n\n  // 10. If request’s response tainting is \"cors\" and locationURL includes\n  // credentials, then return a network error.\n  if (\n    request.responseTainting === 'cors' &&\n    (locationURL.username || locationURL.password)\n  ) {\n    return makeNetworkError(\n      'URL cannot contain credentials for request mode \"cors\"'\n    )\n  }\n\n  // 11. If actualResponse’s status is not 303, request’s body is non-null,\n  // and request’s body’s source is null, then return a network error.\n  if (\n    actualResponse.status !== 303 &&\n    request.body != null &&\n    request.body.source == null\n  ) {\n    return makeNetworkError()\n  }\n\n  // 12. If one of the following is true\n  // - actualResponse’s status is 301 or 302 and request’s method is `POST`\n  // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`\n  if (\n    ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||\n    (actualResponse.status === 303 &&\n      !['GET', 'HEADER'].includes(request.method))\n  ) {\n    // then:\n    // 1. Set request’s method to `GET` and request’s body to null.\n    request.method = 'GET'\n    request.body = null\n\n    // 2. For each headerName of request-body-header name, delete headerName from\n    // request’s header list.\n    for (const headerName of requestBodyHeader) {\n      request.headersList.delete(headerName)\n    }\n  }\n\n  // 13. If request’s body is non-null, then set request’s body to the first return\n  // value of safely extracting request’s body’s source.\n  if (request.body != null) {\n    assert(request.body.source)\n    request.body = safelyExtractBody(request.body.source)[0]\n  }\n\n  // 14. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 15. Set timingInfo’s redirect end time and post-redirect start time to the\n  // coarsened shared current time given fetchParams’s cross-origin isolated\n  // capability.\n  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =\n    coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n\n  // 16. If timingInfo’s redirect start time is 0, then set timingInfo’s\n  //  redirect start time to timingInfo’s start time.\n  if (timingInfo.redirectStartTime === 0) {\n    timingInfo.redirectStartTime = timingInfo.startTime\n  }\n\n  // 17. Append locationURL to request’s URL list.\n  request.urlList.push(locationURL)\n\n  // 18. Invoke set request’s referrer policy on redirect on request and\n  // actualResponse.\n  setRequestReferrerPolicyOnRedirect(request, actualResponse)\n\n  // 19. Return the result of running main fetch given fetchParams and true.\n  return mainFetch.call(this, fetchParams, true)\n}\n\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch (\n  fetchParams,\n  isAuthenticationFetch = false,\n  isNewConnectionFetch = false\n) {\n  const context = this\n\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let httpFetchParams be null.\n  let httpFetchParams = null\n\n  // 3. Let httpRequest be null.\n  let httpRequest = null\n\n  // 4. Let response be null.\n  let response = null\n\n  // 5. Let storedResponse be null.\n  // TODO: cache\n\n  // 6. Let httpCache be null.\n  const httpCache = null\n\n  // 7. Let the revalidatingFlag be unset.\n  const revalidatingFlag = false\n\n  // 8. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If request’s window is \"no-window\" and request’s redirect mode is\n  //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n  //    request.\n  if (request.window === 'no-window' && request.redirect === 'error') {\n    httpFetchParams = fetchParams\n    httpRequest = request\n  } else {\n    // Otherwise:\n\n    // 1. Set httpRequest to a clone of request.\n    httpRequest = makeRequest(request)\n\n    // 2. Set httpFetchParams to a copy of fetchParams.\n    httpFetchParams = { ...fetchParams }\n\n    // 3. Set httpFetchParams’s request to httpRequest.\n    httpFetchParams.request = httpRequest\n  }\n\n  //    3. Let includeCredentials be true if one of\n  const includeCredentials =\n    request.credentials === 'include' ||\n    (request.credentials === 'same-origin' &&\n      request.responseTainting === 'basic')\n\n  //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s\n  //    body is non-null; otherwise null.\n  const contentLength = httpRequest.body ? httpRequest.body.length : null\n\n  //    5. Let contentLengthHeaderValue be null.\n  let contentLengthHeaderValue = null\n\n  //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or\n  //    `PUT`, then set contentLengthHeaderValue to `0`.\n  if (\n    httpRequest.body == null &&\n    ['POST', 'PUT'].includes(httpRequest.method)\n  ) {\n    contentLengthHeaderValue = '0'\n  }\n\n  //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n  //    contentLength, serialized and isomorphic encoded.\n  if (contentLength != null) {\n    // TODO: isomorphic encoded\n    contentLengthHeaderValue = String(contentLength)\n  }\n\n  //    8. If contentLengthHeaderValue is non-null, then append\n  //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header\n  //    list.\n  if (contentLengthHeaderValue != null) {\n    httpRequest.headersList.append('content-length', contentLengthHeaderValue)\n  }\n\n  //    9. If contentLength is non-null and httpRequest’s keepalive is true,\n  //    then:\n  if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n  }\n\n  //    10 .If httpRequest’s referrer is a URL, then append\n  //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,\n  //     to httpRequest’s header list.\n  if (httpRequest.referrer instanceof URL) {\n    // TODO: isomorphic encoded\n    httpRequest.headersList.append('referer', httpRequest.referrer.href)\n  }\n\n  //    11. Append a request `Origin` header for httpRequest.\n  appendRequestOriginHeader(httpRequest)\n\n  //    12. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n  appendFetchMetadata(httpRequest)\n\n  //    13. If httpRequest’s header list does not contain `User-Agent`, then\n  //    user agents should append `User-Agent`/default `User-Agent` value to\n  //    httpRequest’s header list.\n  if (!httpRequest.headersList.has('user-agent')) {\n    httpRequest.headersList.append('user-agent', 'undici')\n  }\n\n  //    14. If httpRequest’s cache mode is \"default\" and httpRequest’s header\n  //    list contains `If-Modified-Since`, `If-None-Match`,\n  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n  //    httpRequest’s cache mode to \"no-store\".\n  if (\n    httpRequest.cache === 'default' &&\n    (httpRequest.headersList.has('if-modified-since') ||\n      httpRequest.headersList.has('if-none-match') ||\n      httpRequest.headersList.has('if-unmodified-since') ||\n      httpRequest.headersList.has('if-match') ||\n      httpRequest.headersList.has('if-range'))\n  ) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    15. If httpRequest’s cache mode is \"no-cache\", httpRequest’s prevent\n  //    no-cache cache-control header modification flag is unset, and\n  //    httpRequest’s header list does not contain `Cache-Control`, then append\n  //    `Cache-Control`/`max-age=0` to httpRequest’s header list.\n  if (\n    httpRequest.cache === 'no-cache' &&\n    !httpRequest.preventNoCacheCacheControlHeaderModification &&\n    !httpRequest.headersList.has('cache-control')\n  ) {\n    httpRequest.headersList.append('cache-control', 'max-age=0')\n  }\n\n  //    16. If httpRequest’s cache mode is \"no-store\" or \"reload\", then:\n  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {\n    // 1. If httpRequest’s header list does not contain `Pragma`, then append\n    // `Pragma`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.has('pragma')) {\n      httpRequest.headersList.append('pragma', 'no-cache')\n    }\n\n    // 2. If httpRequest’s header list does not contain `Cache-Control`,\n    // then append `Cache-Control`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.has('cache-control')) {\n      httpRequest.headersList.append('cache-control', 'no-cache')\n    }\n  }\n\n  //    17. If httpRequest’s header list contains `Range`, then append\n  //    `Accept-Encoding`/`identity` to httpRequest’s header list.\n  if (httpRequest.headersList.has('range')) {\n    httpRequest.headersList.append('accept-encoding', 'identity')\n  }\n\n  //    18. Modify httpRequest’s header list per HTTP. Do not append a given\n  //    header if httpRequest’s header list contains that header’s name.\n  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n  if (!httpRequest.headersList.has('accept-encoding')) {\n    if (/^https:/.test(requestCurrentURL(httpRequest).protocol)) {\n      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate')\n    } else {\n      httpRequest.headersList.append('accept-encoding', 'gzip, deflate')\n    }\n  }\n\n  //    19. If includeCredentials is true, then:\n  if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequest’s header list does not contain `Authorization`, then:\n    // TODO: credentials\n  }\n\n  //    20. If there’s a proxy-authentication entry, use it as appropriate.\n  //    TODO: proxy-authentication\n\n  //    21. Set httpCache to the result of determining the HTTP cache\n  //    partition, given httpRequest.\n  //    TODO: cache\n\n  //    22. If httpCache is null, then set httpRequest’s cache mode to\n  //    \"no-store\".\n  if (httpCache == null) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    23. If httpRequest’s cache mode is neither \"no-store\" nor \"reload\",\n  //    then:\n  if (httpRequest.mode !== 'no-store' && httpRequest.mode !== 'reload') {\n    // TODO: cache\n  }\n\n  // 9. If aborted, then:\n  // TODO\n\n  // 10. If response is null, then:\n  if (response == null) {\n    // 1. If httpRequest’s cache mode is \"only-if-cached\", then return a\n    // network error.\n    if (httpRequest.mode === 'only-if-cached') {\n      return makeNetworkError('only if cached')\n    }\n\n    // 2. Let forwardResponse be the result of running HTTP-network fetch\n    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n    const forwardResponse = await httpNetworkFetch.call(\n      this,\n      httpFetchParams,\n      includeCredentials,\n      isNewConnectionFetch\n    )\n\n    // 3. If httpRequest’s method is unsafe and forwardResponse’s status is\n    // in the range 200 to 399, inclusive, invalidate appropriate stored\n    // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n    // Caching, and set storedResponse to null. [HTTP-CACHING]\n    if (\n      !safeMethods.includes(httpRequest.method) &&\n      forwardResponse.status >= 200 &&\n      forwardResponse.status <= 399\n    ) {\n      // TODO: cache\n    }\n\n    // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,\n    // then:\n    if (revalidatingFlag && forwardResponse.status === 304) {\n      // TODO: cache\n    }\n\n    // 5. If response is null, then:\n    if (response == null) {\n      // 1. Set response to forwardResponse.\n      response = forwardResponse\n\n      // 2. Store httpRequest and forwardResponse in httpCache, as per the\n      // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n      // TODO: cache\n    }\n  }\n\n  // 11. Set response’s URL list to a clone of httpRequest’s URL list.\n  response.urlList = [...httpRequest.urlList]\n\n  // 12. If httpRequest’s header list contains `Range`, then set response’s\n  // range-requested flag.\n  if (httpRequest.headersList.has('range')) {\n    response.rangeRequested = true\n  }\n\n  // 13. If response’s status is 401, httpRequest’s response tainting is not\n  // \"cors\", includeCredentials is true, and request’s window is an environment\n  // settings object, then:\n  // TODO\n\n  // 14. If response’s status is 407, then:\n  if (response.status === 407) {\n    // 1. If request’s window is \"no-window\", then return a network error.\n    if (request.window === 'no-window') {\n      return makeNetworkError()\n    }\n\n    // 2. ???\n\n    // 3. If the ongoing fetch is terminated, then:\n    if (context.terminated) {\n      // 1. Let aborted be the termination’s aborted flag.\n      const aborted = context.terminated.aborted\n\n      // 2. If aborted is set, then return an aborted network error.\n      if (aborted) {\n        return makeNetworkError(new AbortError())\n      }\n\n      // 3. Return a network error.\n      return makeNetworkError(context.terminated.reason)\n    }\n\n    // 4. Prompt the end user as appropriate in request’s window and store\n    // the result as a proxy-authentication entry. [HTTP-AUTH]\n    // TODO: Invoke some kind of callback?\n\n    // 5. Set response to the result of running HTTP-network-or-cache fetch given\n    // fetchParams.\n    // TODO\n    return makeNetworkError('proxy authentication required')\n  }\n\n  // 15. If all of the following are true\n  if (\n    // response’s status is 421\n    response.status === 421 &&\n    // isNewConnectionFetch is false\n    !isNewConnectionFetch &&\n    // request’s body is null, or request’s body is non-null and request’s body’s source is non-null\n    (request.body == null || request.body.source != null)\n  ) {\n    // then:\n\n    // 1. If the ongoing fetch is terminated, then:\n    if (context.terminated) {\n      // 1. Let aborted be the termination’s aborted flag.\n      const aborted = context.terminated.aborted\n\n      // 2. If aborted is set, then return an aborted network error.\n      if (aborted) {\n        return makeNetworkError(new AbortError())\n      }\n\n      // 3. Return a network error.\n      return makeNetworkError(context.terminated.reason)\n    }\n\n    // 2. Set response to the result of running HTTP-network-or-cache\n    // fetch given fetchParams, isAuthenticationFetch, and true.\n\n    // TODO (spec): The spec doesn't specify this but we need to cancel\n    // the active response before we can start a new one.\n    // https://github.com/whatwg/fetch/issues/1293\n    context.connection.destroy()\n\n    response = await httpNetworkOrCacheFetch.call(\n      this,\n      fetchParams,\n      isAuthenticationFetch,\n      true\n    )\n  }\n\n  // 16. If isAuthenticationFetch is true, then create an authentication entry\n  if (isAuthenticationFetch) {\n    // TODO\n  }\n\n  // 17. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-network-fetch\nfunction httpNetworkFetch (\n  fetchParams,\n  includeCredentials = false,\n  forceNewConnection = false\n) {\n  const context = this\n\n  return new Promise((resolve) => {\n    assert(!context.connection || context.connection.destroyed)\n\n    context.connection = {\n      abort: null,\n      destroyed: false,\n      destroy (err) {\n        if (!this.destroyed) {\n          this.destroyed = true\n          this.abort?.(err ?? new AbortError())\n        }\n      }\n    }\n\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request\n\n    // 2. Let response be null.\n    let response = null\n\n    // 3. Let timingInfo be fetchParams’s timing info.\n    const timingInfo = fetchParams.timingInfo\n\n    // 4. Let httpCache be the result of determining the HTTP cache partition,\n    // given request.\n    // TODO: cache\n    const httpCache = null\n\n    // 5. If httpCache is null, then set request’s cache mode to \"no-store\".\n    if (httpCache == null) {\n      request.cache = 'no-store'\n    }\n\n    // 6. Let networkPartitionKey be the result of determining the network\n    // partition key given request.\n    // TODO\n\n    // 7. Switch on request’s mode:\n    if (request.mode === 'websocket') {\n      // Let connection be the result of obtaining a WebSocket connection,\n      // given request’s current URL.\n      // TODO\n    } else {\n      // Let connection be the result of obtaining a connection, given\n      // networkPartitionKey, request’s current URL’s origin,\n      // includeCredentials, and forceNewConnection.\n      // TODO\n    }\n\n    // 8. Run these steps, but abort when the ongoing fetch is terminated:\n    // TODO: When do we cleanup this listener?\n    context.on('terminated', onRequestAborted)\n\n    //    5. Set response to the result of making an HTTP request over connection\n    //    using request with the following caveats:\n\n    //    Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n    //    [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n\n    //    If request’s body is non-null, and request’s body’s source is null,\n    //    then the user agent may have a buffer of up to 64 kibibytes and store\n    //    a part of request’s body in that buffer. If the user agent reads from\n    //    request’s body beyond that buffer’s size and the user agent needs to\n    //    resend request, then instead return a network error.\n    //    TODO\n\n    //    Set timingInfo’s final network-response start time to the coarsened\n    //    shared current time given fetchParams’s cross-origin isolated capability,\n    //    immediately after the user agent’s HTTP parser receives the first byte\n    //    of the response (e.g., frame header bytes for HTTP/2 or response status\n    //    line for HTTP/1.x).\n    //    TODO\n\n    //    Wait until all the headers are transmitted.\n\n    //    Any responses whose status is in the range 100 to 199, inclusive,\n    //    and is not 101, are to be ignored, except for the purposes of setting\n    //    timingInfo’s final network-response start time above.\n\n    //    If request’s header list contains `Transfer-Encoding`/`chunked` and\n    //    response is transferred via HTTP/1.0 or older, then return a network\n    //    error.\n\n    //    If the HTTP request results in a TLS client certificate dialog, then:\n\n    //        1. If request’s window is an environment settings object, make the\n    //        dialog available in request’s window.\n\n    //        2. Otherwise, return a network error.\n\n    // To transmit request’s body body, run these steps:\n    const body = (async function * () {\n      try {\n        // 1. If body is null and fetchParams’s process request end-of-body is\n        // non-null, then queue a fetch task given fetchParams’s process request\n        // end-of-body and fetchParams’s task destination.\n        if (request.body === null) {\n          fetchParams.processEndOfBody?.()\n          return\n        }\n\n        // 2. Otherwise, if body is non-null:\n\n        //    1. Let processBodyChunk given bytes be these steps:\n        for await (const bytes of request.body.stream) {\n          // 1. If the ongoing fetch is terminated, then abort these steps.\n          if (context.terminated) {\n            return\n          }\n\n          // 2. Run this step in parallel: transmit bytes.\n          yield bytes\n\n          // 3. If fetchParams’s process request body is non-null, then run\n          // fetchParams’s process request body given bytes’s length.\n          fetchParams.processRequestBody?.(bytes.byteLength)\n        }\n\n        // 2. Let processEndOfBody be these steps:\n\n        //    1. If the ongoing fetch is terminated, then abort these steps.\n        if (context.terminated) {\n          return\n        }\n\n        //    2. If fetchParams’s process request end-of-body is non-null,\n        //    then run fetchParams’s process request end-of-body.\n        fetchParams.processRequestEndOfBody?.()\n      } catch (e) {\n        // 3. Let processBodyError given e be these steps:\n\n        //    1. If the ongoing fetch is terminated, then abort these steps.\n        if (context.terminated) {\n          return\n        }\n\n        //    2. If e is an \"AbortError\" DOMException, then terminate the ongoing fetch with the aborted flag set.\n        //    3. Otherwise, terminate the ongoing fetch.\n        context.terminate({\n          aborted: e.name === 'AbortError',\n          reason: e\n        })\n      }\n    })()\n\n    // 9. If aborted, then:\n    function onRequestAborted () {\n      // 1. Let aborted be the termination’s aborted flag.\n      const aborted = this.terminated.aborted\n\n      // 2. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      this.connection.destroy()\n\n      // 3. If aborted is set, then return an aborted network error.\n      if (aborted) {\n        return resolve(makeNetworkError(new AbortError()))\n      }\n\n      // 4. Return a network error.\n      return resolve(makeNetworkError(this.terminated.reason))\n    }\n\n    // 10. Let pullAlgorithm be an action that resumes the ongoing fetch\n    // if it is suspended.\n    let pullAlgorithm\n\n    // 11. Let cancelAlgorithm be an action that terminates the ongoing\n    // fetch with the aborted flag set.\n    const cancelAlgorithm = () => {\n      context.terminate({ aborted: true })\n    }\n\n    // 12. Let highWaterMark be a non-negative, non-NaN number, chosen by\n    // the user agent.\n    const highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n\n    // 13. Let sizeAlgorithm be an algorithm that accepts a chunk object\n    // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n    // TODO\n\n    // 14. Let stream be a new ReadableStream.\n    // 15. Set up stream with pullAlgorithm set to pullAlgorithm,\n    // cancelAlgorithm set to cancelAlgorithm, highWaterMark set to\n    // highWaterMark, and sizeAlgorithm set to sizeAlgorithm.\n    if (!ReadableStream) {\n      ReadableStream = require('stream/web').ReadableStream\n    }\n\n    let pullResolve\n\n    const stream = new ReadableStream(\n      {\n        async start (controller) {\n          context.controller = controller\n        },\n        async pull (controller) {\n          if (!pullAlgorithm) {\n            await new Promise((resolve) => {\n              pullResolve = resolve\n            })\n          }\n          await pullAlgorithm(controller)\n        },\n        async cancel (reason) {\n          await cancelAlgorithm(reason)\n        }\n      },\n      { highWaterMark }\n    )\n\n    // 16. Run these steps, but abort when the ongoing fetch is terminated:\n    // TODO\n\n    // 17. If aborted, then:\n    // TODO: How can this happen? The steps above are not async?\n\n    // 18. Run these steps in parallel:\n    //    1. Run these steps, but abort when the ongoing fetch is terminated:\n    //        1. While true:\n    //            1. If one or more bytes have been transmitted from response’s\n    //            message body, then:\n    //            NOTE: See onHeaders\n    //            2. Otherwise, if the bytes transmission for response’s message\n    //            body is done normally and stream is readable, then close stream,\n    //            finalize response for fetchParams and response, and abort these\n    //            in-parallel steps.\n    //            NOTE: See onHeaders\n\n    //    2. If aborted, then:\n    function onResponseAborted () {\n      // 1. Let aborted be the termination’s aborted flag.\n      const aborted = this.terminated.aborted\n\n      // 2. If aborted is set, then:\n      if (aborted) {\n        // 1. Set response’s aborted flag.\n        response.aborted = true\n\n        // 2. If stream is readable, error stream with an \"AbortError\" DOMException.\n        if (isReadable(stream)) {\n          this.controller.error(new AbortError())\n        }\n      } else {\n        // 3. Otherwise, if stream is readable, error stream with a TypeError.\n        if (isReadable(stream)) {\n          this.controller.error(new TypeError('terminated'))\n        }\n      }\n\n      // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n      this.connection.destroy()\n    }\n\n    // 19. Return response.\n    // NOTE: See onHeaders\n\n    // Implementation\n    const url = requestCurrentURL(request)\n    context.dispatcher.dispatch(\n      {\n        path: url.pathname + url.search,\n        origin: url.origin,\n        method: request.method,\n        body: context.dispatcher[kIsMockActive] ? request.body && request.body.source : body,\n        headers: request.headersList,\n        maxRedirections: 0\n      },\n      {\n        decoder: null,\n        abort: null,\n        context,\n\n        onConnect (abort) {\n          // TODO (fix): Do we need connection here?\n          const { connection } = this.context\n\n          if (connection.destroyed) {\n            abort(new AbortError())\n          } else {\n            this.abort = connection.abort = abort\n          }\n        },\n\n        onHeaders (status, headersList, resume, statusText) {\n          if (status < 200) {\n            return\n          }\n\n          const headers = new Headers()\n          for (let n = 0; n < headersList.length; n += 2) {\n            headers.append(\n              headersList[n + 0].toString(),\n              headersList[n + 1].toString()\n            )\n          }\n\n          response = makeResponse({\n            status,\n            statusText,\n            headersList: headers[kHeadersList],\n            body: { stream }\n          })\n\n          this.context.on('terminated', onResponseAborted)\n\n          const codings =\n            headers\n              .get('content-encoding')\n              ?.toLowerCase()\n              .split(',')\n              .map((x) => x.trim()) ?? []\n\n          const decoders = []\n\n          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n          for (const coding of codings) {\n            if (/(x-)?gzip/.test(coding)) {\n              decoders.push(zlib.createGunzip())\n            } else if (/(x-)?deflate/.test(coding)) {\n              decoders.push(zlib.createInflate())\n            } else if (coding === 'br') {\n              decoders.push(zlib.createBrotliDecompress())\n            } else {\n              decoders.length = 0\n              break\n            }\n          }\n\n          if (decoders.length > 1) {\n            pipeline(...decoders, () => {})\n          } else if (decoders.length === 0) {\n            // TODO (perf): Avoid intermediate.\n            decoders.push(new PassThrough())\n          }\n\n          this.decoder = decoders[0].on('drain', resume)\n\n          const iterator = decoders[decoders.length - 1][Symbol.asyncIterator]()\n\n          pullAlgorithm = async (controller) => {\n            // 4. Set bytes to the result of handling content codings given\n            // codings and bytes.\n            let bytes\n            try {\n              const { done, value } = await iterator.next()\n              bytes = done ? undefined : value\n            } catch (err) {\n              if (this.decoder.writableEnded && !timingInfo.encodedBodySize) {\n                // zlib doesn't like empty streams.\n                bytes = undefined\n              } else {\n                bytes = err\n              }\n            }\n\n            if (bytes === undefined) {\n              // 2. Otherwise, if the bytes transmission for response’s message\n              // body is done normally and stream is readable, then close\n              // stream, finalize response for fetchParams and response, and\n              // abort these in-parallel steps.\n              finalizeResponse(fetchParams, response)\n\n              controller.close()\n\n              return\n            }\n\n            // 5. Increase timingInfo’s decoded body size by bytes’s length.\n            timingInfo.decodedBodySize += bytes?.byteLength ?? 0\n\n            // 6. If bytes is failure, then terminate the ongoing fetch.\n            if (bytes instanceof Error) {\n              this.context.terminate({ reason: bytes })\n              return\n            }\n\n            // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n            // into stream.\n            controller.enqueue(new Uint8Array(bytes))\n\n            // 8. If stream is errored, then terminate the ongoing fetch.\n            if (isErrored(stream)) {\n              this.context.terminate()\n              return\n            }\n\n            // 9. If stream doesn’t need more data ask the user agent to suspend\n            // the ongoing fetch.\n            return controller.desiredSize > 0\n          }\n\n          if (pullResolve) {\n            pullResolve()\n            pullResolve = null\n          }\n\n          resolve(response)\n\n          return true\n        },\n\n        onData (chunk) {\n          if (this.context.dump) {\n            return\n          }\n\n          //  1. If one or more bytes have been transmitted from response’s\n          //  message body, then:\n\n          // 1. Let bytes be the transmitted bytes.\n          const bytes = chunk\n\n          // 2. Let codings be the result of extracting header list values\n          // given `Content-Encoding` and response’s header list.\n          // See pullAlgorithm.\n\n          // 3. Increase timingInfo’s encoded body size by bytes’s length.\n          timingInfo.encodedBodySize += bytes.byteLength\n\n          // 4. See pullAlgorithm...\n\n          return this.decoder.write(bytes)\n        },\n\n        onComplete () {\n          this.decoder.end()\n        },\n\n        onError (error) {\n          this.decoder?.destroy(error)\n\n          this.context.terminate({ reason: error })\n\n          if (!response) {\n            resolve(makeNetworkError(error))\n          }\n        }\n      }\n    )\n  })\n}\n\nmodule.exports = fetch\n"]},"metadata":{},"sourceType":"script"}