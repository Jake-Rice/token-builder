{"ast":null,"code":"'use strict';\n\nconst Readable = require('./readable');\n\nconst {\n  InvalidArgumentError,\n  RequestAbortedError\n} = require('../core/errors');\n\nconst util = require('../core/util');\n\nconst {\n  AsyncResource\n} = require('async_hooks');\n\nconst {\n  addSignal,\n  removeSignal\n} = require('./abort-signal');\n\nclass RequestHandler extends AsyncResource {\n  constructor(opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts');\n    }\n\n    const {\n      signal,\n      method,\n      opaque,\n      body,\n      onInfo,\n      responseHeaders\n    } = opts;\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback');\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method');\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback');\n      }\n\n      super('UNDICI_REQUEST');\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err);\n      }\n\n      throw err;\n    }\n\n    this.responseHeaders = responseHeaders || null;\n    this.opaque = opaque || null;\n    this.callback = callback;\n    this.res = null;\n    this.abort = null;\n    this.body = body;\n    this.trailers = {};\n    this.context = null;\n    this.onInfo = onInfo || null;\n\n    if (util.isStream(body)) {\n      body.on('error', err => {\n        this.onError(err);\n      });\n    }\n\n    addSignal(this, signal);\n  }\n\n  onConnect(abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError();\n    }\n\n    this.abort = abort;\n    this.context = context;\n  }\n\n  onHeaders(statusCode, rawHeaders, resume) {\n    const {\n      callback,\n      opaque,\n      abort,\n      context\n    } = this;\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        this.onInfo({\n          statusCode,\n          headers\n        });\n      }\n\n      return;\n    }\n\n    const parsedHeaders = util.parseHeaders(rawHeaders);\n    const body = new Readable(resume, abort, parsedHeaders['content-type']);\n    this.callback = null;\n    this.res = body;\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers,\n      trailers: this.trailers,\n      opaque,\n      body,\n      context\n    });\n  }\n\n  onData(chunk) {\n    const {\n      res\n    } = this;\n    return res.push(chunk);\n  }\n\n  onComplete(trailers) {\n    const {\n      res\n    } = this;\n    removeSignal(this);\n    util.parseHeaders(trailers, this.trailers);\n    res.push(null);\n  }\n\n  onError(err) {\n    const {\n      res,\n      callback,\n      body,\n      opaque\n    } = this;\n    removeSignal(this);\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null;\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, {\n          opaque\n        });\n      });\n    }\n\n    if (res) {\n      this.res = null; // Ensure all queued handlers are invoked before destroying res.\n\n      queueMicrotask(() => {\n        util.destroy(res, err);\n      });\n    }\n\n    if (body) {\n      this.body = null;\n      util.destroy(body, err);\n    }\n  }\n\n}\n\nfunction request(opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data);\n      });\n    });\n  }\n\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback));\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err;\n    }\n\n    const opaque = opts && opts.opaque;\n    queueMicrotask(() => callback(err, {\n      opaque\n    }));\n  }\n}\n\nmodule.exports = request;","map":{"version":3,"sources":["/Users/jake/workspace/token-builder/node_modules/undici/lib/api/api-request.js"],"names":["Readable","require","InvalidArgumentError","RequestAbortedError","util","AsyncResource","addSignal","removeSignal","RequestHandler","constructor","opts","callback","signal","method","opaque","body","onInfo","responseHeaders","on","addEventListener","err","isStream","destroy","nop","res","abort","trailers","context","onError","onConnect","onHeaders","statusCode","rawHeaders","resume","headers","parseRawHeaders","parseHeaders","parsedHeaders","runInAsyncScope","onData","chunk","push","onComplete","queueMicrotask","request","undefined","Promise","resolve","reject","call","data","dispatch","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Readable = require('./readable')\nconst {\n  InvalidArgumentError,\n  RequestAbortedError\n} = require('../core/errors')\nconst util = require('../core/util')\nconst { AsyncResource } = require('async_hooks')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass RequestHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_REQUEST')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.body = body\n    this.trailers = {}\n    this.context = null\n    this.onInfo = onInfo || null\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume) {\n    const { callback, opaque, abort, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    const parsedHeaders = util.parseHeaders(rawHeaders)\n    const body = new Readable(resume, abort, parsedHeaders['content-type'])\n\n    this.callback = null\n    this.res = body\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers,\n      trailers: this.trailers,\n      opaque,\n      body,\n      context\n    })\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    util.parseHeaders(trailers, this.trailers)\n\n    res.push(null)\n  }\n\n  onError (err) {\n    const { res, callback, body, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (res) {\n      this.res = null\n      // Ensure all queued handlers are invoked before destroying res.\n      queueMicrotask(() => {\n        util.destroy(res, err)\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction request (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = request\n"]},"metadata":{},"sourceType":"script"}