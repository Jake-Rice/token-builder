{"ast":null,"code":"/* globals AbortController */\n'use strict';\n\nconst {\n  extractBody,\n  mixinBody,\n  cloneBody\n} = require('./body');\n\nconst {\n  Headers,\n  fill: fillHeaders,\n  HeadersList\n} = require('./headers');\n\nconst util = require('../core/util');\n\nconst {\n  isValidHTTPToken,\n  EnvironmentSettingsObject,\n  toUSVString\n} = require('./util');\n\nconst {\n  forbiddenMethods,\n  corsSafeListedMethods,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache\n} = require('./constants');\n\nconst {\n  kEnumerableProperty\n} = util;\n\nconst {\n  kHeaders,\n  kSignal,\n  kState,\n  kGuard,\n  kRealm\n} = require('./symbols');\n\nconst {\n  kHeadersList\n} = require('../core/symbols');\n\nconst assert = require('assert');\n\nlet TransformStream;\nconst kInit = Symbol('init');\nconst requestFinalizer = new FinalizationRegistry(_ref => {\n  let {\n    signal,\n    abort\n  } = _ref;\n  signal.removeEventListener('abort', abort);\n}); // https://fetch.spec.whatwg.org/#request-class\n\nclass Request {\n  // https://fetch.spec.whatwg.org/#dom-request\n  constructor() {\n    if ((arguments.length <= 0 ? undefined : arguments[0]) === kInit) {\n      return;\n    }\n\n    if (arguments.length < 1) {\n      throw new TypeError(`Failed to construct 'Request': 1 argument required, but only ${arguments.length} present.`);\n    }\n\n    if (arguments.length >= 1 && typeof (arguments.length <= 1 ? undefined : arguments[1]) !== 'object' && (arguments.length <= 1 ? undefined : arguments[1]) !== undefined) {\n      throw new TypeError(\"Failed to construct 'Request': cannot convert to dictionary.\");\n    }\n\n    const input = (arguments.length <= 0 ? undefined : arguments[0]) instanceof Request ? arguments.length <= 0 ? undefined : arguments[0] : toUSVString(arguments.length <= 0 ? undefined : arguments[0]);\n    const init = arguments.length >= 1 ? (arguments.length <= 1 ? undefined : arguments[1]) ?? {} : {}; // TODO\n\n    this[kRealm] = {\n      settingsObject: {}\n    }; // 1. Let request be null.\n\n    let request = null; // 2. Let fallbackMode be null.\n\n    let fallbackMode = null; // 3. Let baseURL be this’s relevant settings object’s API base URL.\n\n    const baseUrl = this[kRealm].settingsObject.baseUrl; // 4. Let signal be null.\n\n    let signal = null; // 5. If input is a string, then:\n\n    if (typeof input === 'string') {\n      // 1. Let parsedURL be the result of parsing input with baseURL.\n      // 2. If parsedURL is failure, then throw a TypeError.\n      let parsedURL;\n\n      try {\n        parsedURL = new URL(input, baseUrl);\n      } catch (err) {\n        const error = new TypeError('Failed to parse URL from ' + input);\n        error.cause = err;\n        throw error;\n      } // 3. If parsedURL includes credentials, then throw a TypeError.\n\n\n      if (parsedURL.username || parsedURL.password) {\n        throw new TypeError('Request cannot be constructed from a URL that includes credentials: ' + input);\n      } // 4. Set request to a new request whose URL is parsedURL.\n\n\n      request = makeRequest({\n        urlList: [parsedURL]\n      }); // 5. Set fallbackMode to \"cors\".\n\n      fallbackMode = 'cors';\n    } else {\n      // 6. Otherwise:\n      // 7. Assert: input is a Request object.\n      assert(input instanceof Request); // 8. Set request to input’s request.\n\n      request = input[kState]; // 9. Set signal to input’s signal.\n\n      signal = input[kSignal];\n    } // 7. Let origin be this’s relevant settings object’s origin.\n\n\n    const origin = this[kRealm].settingsObject.origin; // 8. Let window be \"client\".\n\n    let window = 'client'; // 9. If request’s window is an environment settings object and its origin\n    // is same origin with origin, then set window to request’s window.\n\n    if (request.window instanceof EnvironmentSettingsObject && sameOrigin(request.window, origin)) {\n      window = request.window;\n    } // 10. If init[\"window\"] exists and is non-null, then throw a TypeError.\n\n\n    if (init.window !== undefined && init.window != null) {\n      throw new TypeError(`'window' option '${window}' must be null`);\n    } // 11. If init[\"window\"] exists, then set window to \"no-window\".\n\n\n    if (init.window !== undefined) {\n      window = 'no-window';\n    } // 12. Set request to a new request with the following properties:\n\n\n    request = makeRequest({\n      // URL request’s URL.\n      // undici implementation note: this is set as the first item in request's urlList in makeRequest\n      // method request’s method.\n      method: request.method,\n      // header list A copy of request’s header list.\n      // undici implementation note: headersList is cloned in makeRequest\n      headersList: request.headersList,\n      // unsafe-request flag Set.\n      unsafeRequest: request.unsafeRequest,\n      // client This’s relevant settings object.\n      client: request.client,\n      // window window.\n      window,\n      // priority request’s priority.\n      priority: request.priority,\n      // origin request’s origin. The propagation of the origin is only significant for navigation requests\n      // being handled by a service worker. In this scenario a request can have an origin that is different\n      // from the current client.\n      origin: request.origin,\n      // referrer request’s referrer.\n      referrer: request.referrer,\n      // referrer policy request’s referrer policy.\n      referrerPolicy: request.referrerPolicy,\n      // mode request’s mode.\n      mode: request.mode,\n      // credentials mode request’s credentials mode.\n      credentials: request.credentials,\n      // cache mode request’s cache mode.\n      cache: request.cache,\n      // redirect mode request’s redirect mode.\n      redirect: request.redirect,\n      // integrity metadata request’s integrity metadata.\n      integrity: request.integrity,\n      // keepalive request’s keepalive.\n      keepalive: request.keepalive,\n      // reload-navigation flag request’s reload-navigation flag.\n      reloadNavigation: request.reloadNavigation,\n      // history-navigation flag request’s history-navigation flag.\n      historyNavigation: request.historyNavigation,\n      // URL list A clone of request’s URL list.\n      // undici implementation note: urlList is cloned in makeRequest\n      urlList: request.urlList\n    }); // 13. If init is not empty, then:\n\n    if (Object.keys(init).length > 0) {\n      // 1. If request’s mode is \"navigate\", then set it to \"same-origin\".\n      if (request.mode === 'navigate') {\n        request.mode = 'same-origin';\n      } // 2. Unset request’s reload-navigation flag.\n\n\n      request.reloadNavigation = false; // 3. Unset request’s history-navigation flag.\n\n      request.historyNavigation = false; // 4. Set request’s origin to \"client\".\n\n      request.origin = 'client'; // 5. Set request’s referrer to \"client\"\n\n      request.referrer = 'client'; // 6. Set request’s referrer policy to the empty string.\n\n      request.referrerPolicy = ''; // 7. Set request’s URL to request’s current URL.\n\n      request.url = request.urlList[request.urlList.length - 1]; // 8. Set request’s URL list to « request’s URL ».\n\n      request.urlList = [request.url];\n    } // 14. If init[\"referrer\"] exists, then:\n\n\n    if (init.referrer !== undefined) {\n      // 1. Let referrer be init[\"referrer\"].\n      const referrer = init.referrer; // 2. If referrer is the empty string, then set request’s referrer to \"no-referrer\".\n\n      if (referrer === '') {\n        request.referrer = 'no-referrer';\n      } else {\n        // 1. Let parsedReferrer be the result of parsing referrer with\n        // baseURL.\n        // 2. If parsedReferrer is failure, then throw a TypeError.\n        let parsedReferrer;\n\n        try {\n          parsedReferrer = new URL(referrer, baseUrl);\n        } catch (err) {\n          const error = new TypeError(`Referrer \"${referrer}\" is not a valid URL.`);\n          error.cause = err;\n          throw error;\n        } // 3. If one of the following is true\n        // parsedReferrer’s cannot-be-a-base-URL is true, scheme is \"about\",\n        // and path contains a single string \"client\"\n        // parsedReferrer’s origin is not same origin with origin\n        // then set request’s referrer to \"client\".\n        // TODO\n        // 4. Otherwise, set request’s referrer to parsedReferrer.\n\n\n        request.referrer = parsedReferrer;\n      }\n    } // 15. If init[\"referrerPolicy\"] exists, then set request’s referrer policy\n    // to it.\n\n\n    if (init.referrerPolicy !== undefined) {\n      request.referrerPolicy = init.referrerPolicy;\n\n      if (!referrerPolicy.includes(request.referrerPolicy)) {\n        throw new TypeError(`Failed to construct 'Request': The provided value '${request.referrerPolicy}' is not a valid enum value of type ReferrerPolicy.`);\n      }\n    } // 16. Let mode be init[\"mode\"] if it exists, and fallbackMode otherwise.\n\n\n    let mode;\n\n    if (init.mode !== undefined) {\n      mode = init.mode;\n\n      if (!requestMode.includes(mode)) {\n        throw new TypeError(`Failed to construct 'Request': The provided value '${request.mode}' is not a valid enum value of type RequestMode.`);\n      }\n    } else {\n      mode = fallbackMode;\n    } // 17. If mode is \"navigate\", then throw a TypeError.\n\n\n    if (mode === 'navigate') {\n      throw new TypeError();\n    } // 18. If mode is non-null, set request’s mode to mode.\n\n\n    if (mode != null) {\n      request.mode = mode;\n    } // 19. If init[\"credentials\"] exists, then set request’s credentials mode\n    // to it.\n\n\n    if (init.credentials !== undefined) {\n      request.credentials = init.credentials;\n\n      if (!requestCredentials.includes(request.credentials)) {\n        throw new TypeError(`Failed to construct 'Request': The provided value '${request.credentials}' is not a valid enum value of type RequestCredentials.`);\n      }\n    } // 18. If init[\"cache\"] exists, then set request’s cache mode to it.\n\n\n    if (init.cache !== undefined) {\n      request.cache = init.cache;\n\n      if (!requestCache.includes(request.cache)) {\n        throw new TypeError(`Failed to construct 'Request': The provided value '${request.cache}' is not a valid enum value of type RequestCache.`);\n      }\n    } // 21. If request’s cache mode is \"only-if-cached\" and request’s mode is\n    // not \"same-origin\", then throw a TypeError.\n\n\n    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {\n      throw new TypeError(\"'only-if-cached' can be set only with 'same-origin' mode\");\n    } // 22. If init[\"redirect\"] exists, then set request’s redirect mode to it.\n\n\n    if (init.redirect !== undefined) {\n      request.redirect = init.redirect;\n\n      if (!requestRedirect.includes(request.redirect)) {\n        throw new TypeError(`Failed to construct 'Request': The provided value '${request.redirect}' is not a valid enum value of type RequestRedirect.`);\n      }\n    } // 23. If init[\"integrity\"] exists, then set request’s integrity metadata to it.\n\n\n    if (init.integrity !== undefined && init.integrity != null) {\n      request.integrity = String(init.integrity);\n    } // 24. If init[\"keepalive\"] exists, then set request’s keepalive to it.\n\n\n    if (init.keepalive !== undefined) {\n      request.keepalive = Boolean(init.keepalive);\n    } // 25. If init[\"method\"] exists, then:\n\n\n    if (init.method !== undefined) {\n      // 1. Let method be init[\"method\"].\n      let method = init.method; // 2. If method is not a method or method is a forbidden method, then\n      // throw a TypeError.\n\n      if (!isValidHTTPToken(init.method)) {\n        throw TypeError(`'${init.method}' is not a valid HTTP method.`);\n      }\n\n      if (forbiddenMethods.indexOf(method.toUpperCase()) !== -1) {\n        throw TypeError(`'${init.method}' HTTP method is unsupported.`);\n      } // 3. Normalize method.\n      // https://fetch.spec.whatwg.org/#concept-method-normalize\n\n\n      method = init.method.toUpperCase(); // 4. Set request’s method to method.\n\n      request.method = method;\n    } // 26. If init[\"signal\"] exists, then set signal to it.\n\n\n    if (init.signal !== undefined) {\n      signal = init.signal;\n    } // 27. Set this’s request to request.\n\n\n    this[kState] = request; // 28. Set this’s signal to a new AbortSignal object with this’s relevant\n    // Realm.\n\n    const ac = new AbortController();\n    this[kSignal] = ac.signal;\n    this[kSignal][kRealm] = this[kRealm]; // 29. If signal is not null, then make this’s signal follow signal.\n\n    if (signal != null) {\n      if (!signal || typeof signal.aborted !== 'boolean' || typeof signal.addEventListener !== 'function') {\n        throw new TypeError(\"Failed to construct 'Request': member signal is not of type AbortSignal.\");\n      }\n\n      if (signal.aborted) {\n        ac.abort();\n      } else {\n        const abort = () => ac.abort();\n\n        signal.addEventListener('abort', abort, {\n          once: true\n        });\n        requestFinalizer.register(this, {\n          signal,\n          abort\n        });\n      }\n    } // 30. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is request’s header list and guard is\n    // \"request\".\n\n\n    this[kHeaders] = new Headers();\n    this[kHeaders][kGuard] = 'request';\n    this[kHeaders][kHeadersList] = request.headersList;\n    this[kHeaders][kRealm] = this[kRealm]; // 31. If this’s request’s mode is \"no-cors\", then:\n\n    if (mode === 'no-cors') {\n      // 1. If this’s request’s method is not a CORS-safelisted method,\n      // then throw a TypeError.\n      if (!corsSafeListedMethods.includes(request.method)) {\n        throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);\n      } // 2. Set this’s headers’s guard to \"request-no-cors\".\n\n\n      this[kHeaders][kGuard] = 'request-no-cors';\n    } // 32. If init is not empty, then:\n\n\n    if (Object.keys(init).length !== 0) {\n      // 1. Let headers be a copy of this’s headers and its associated header\n      // list.\n      let headers = new Headers(this.headers); // 2. If init[\"headers\"] exists, then set headers to init[\"headers\"].\n\n      if (init.headers !== undefined) {\n        headers = init.headers;\n      } // 3. Empty this’s headers’s header list.\n\n\n      this[kState].headersList = new HeadersList();\n      this[kHeaders][kHeadersList] = this[kState].headersList; // 4. If headers is a Headers object, then for each header in its header\n      // list, append header’s name/header’s value to this’s headers.\n\n      if (headers instanceof Headers) {\n        this[kState].headersList.push(...headers[kHeadersList]);\n      } else {\n        // 5. Otherwise, fill this’s headers with headers.\n        fillHeaders(this[kState].headersList, headers);\n      }\n    } // 33. Let inputBody be input’s request’s body if input is a Request\n    // object; otherwise null.\n\n\n    const inputBody = input instanceof Request ? input[kState].body : null; // 34. If either init[\"body\"] exists and is non-null or inputBody is\n    // non-null, and request’s method is `GET` or `HEAD`, then throw a\n    // TypeError.\n\n    if ((init.body !== undefined && init.body != null || inputBody != null) && (request.method === 'GET' || request.method === 'HEAD')) {\n      throw new TypeError('Request with GET/HEAD method cannot have body.');\n    } // 35. Let initBody be null.\n\n\n    let initBody = null; // 36. If init[\"body\"] exists and is non-null, then:\n\n    if (init.body !== undefined && init.body != null) {\n      // 1. Let Content-Type be null.\n      // 2. Set initBody and Content-Type to the result of extracting\n      // init[\"body\"], with keepalive set to request’s keepalive.\n      const [extractedBody, contentType] = extractBody(init.body, request.keepalive);\n      initBody = extractedBody; // 3, If Content-Type is non-null and this’s headers’s header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type to\n      // this’s headers.\n\n      if (contentType && !this[kHeaders].has('content-type')) {\n        this[kHeaders].append('content-type', contentType);\n      }\n    } // 37. Let inputOrInitBody be initBody if it is non-null; otherwise\n    // inputBody.\n\n\n    const inputOrInitBody = initBody ?? inputBody; // 38. If inputOrInitBody is non-null and inputOrInitBody’s source is\n    // null, then:\n\n    if (inputOrInitBody != null && inputOrInitBody.source == null) {\n      // 1. If this’s request’s mode is neither \"same-origin\" nor \"cors\",\n      // then throw a TypeError.\n      if (request.mode !== 'same-origin' && request.mode !== 'cors') {\n        throw new TypeError('If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"');\n      } // 2. Set this’s request’s use-CORS-preflight flag.\n\n\n      request.useCORSPreflightFlag = true;\n    } // 39. Let finalBody be inputOrInitBody.\n\n\n    let finalBody = inputOrInitBody; // 40. If initBody is null and inputBody is non-null, then:\n\n    if (initBody == null && inputBody != null) {\n      // 1. If input is unusable, then throw a TypeError.\n      if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {\n        throw new TypeError('Cannot construct a Request with a Request object that has already been used.');\n      } // 2. Set finalBody to the result of creating a proxy for inputBody.\n\n\n      if (!TransformStream) {\n        TransformStream = require('stream/web').TransformStream;\n      } // https://streams.spec.whatwg.org/#readablestream-create-a-proxy\n\n\n      const identityTransform = new TransformStream();\n      inputBody.stream.pipeThrough(identityTransform);\n      finalBody = {\n        source: inputBody.source,\n        length: inputBody.length,\n        stream: identityTransform.readable\n      };\n    } // 41. Set this’s request’s body to finalBody.\n\n\n    this[kState].body = finalBody;\n  }\n\n  get [Symbol.toStringTag]() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    return this.constructor.name;\n  } // Returns request’s HTTP method, which is \"GET\" by default.\n\n\n  get method() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The method getter steps are to return this’s request’s method.\n\n\n    return this[kState].method;\n  } // Returns the URL of request as a string.\n\n\n  get url() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The url getter steps are to return this’s request’s URL, serialized.\n\n\n    return this[kState].url.toString();\n  } // Returns a Headers object consisting of the headers associated with request.\n  // Note that headers added in the network layer by the user agent will not\n  // be accounted for in this object, e.g., the \"Host\" header.\n\n\n  get headers() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The headers getter steps are to return this’s headers.\n\n\n    return this[kHeaders];\n  } // Returns the kind of resource requested by request, e.g., \"document\"\n  // or \"script\".\n\n\n  get destination() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The destination getter are to return this’s request’s destination.\n\n\n    return this[kState].destination;\n  } // Returns the referrer of request. Its value can be a same-origin URL if\n  // explicitly set in init, the empty string to indicate no referrer, and\n  // \"about:client\" when defaulting to the global’s default. This is used\n  // during fetching to determine the value of the `Referer` header of the\n  // request being made.\n\n\n  get referrer() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // 1. If this’s request’s referrer is \"no-referrer\", then return the\n    // empty string.\n\n\n    if (this[kState].referrer === 'no-referrer') {\n      return '';\n    } // 2. If this’s request’s referrer is \"client\", then return\n    // \"about:client\".\n\n\n    if (this[kState].referrer === 'client') {\n      return 'about:client';\n    } // Return this’s request’s referrer, serialized.\n\n\n    return this[kState].referrer.toString();\n  } // Returns the referrer policy associated with request.\n  // This is used during fetching to compute the value of the request’s\n  // referrer.\n\n\n  get referrerPolicy() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The referrerPolicy getter steps are to return this’s request’s referrer policy.\n\n\n    return this[kState].referrerPolicy;\n  } // Returns the mode associated with request, which is a string indicating\n  // whether the request will use CORS, or will be restricted to same-origin\n  // URLs.\n\n\n  get mode() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The mode getter steps are to return this’s request’s mode.\n\n\n    return this[kState].mode;\n  } // Returns the credentials mode associated with request,\n  // which is a string indicating whether credentials will be sent with the\n  // request always, never, or only when sent to a same-origin URL.\n\n\n  get credentials() {\n    // The credentials getter steps are to return this’s request’s credentials mode.\n    return this[kState].credentials;\n  } // Returns the cache mode associated with request,\n  // which is a string indicating how the request will\n  // interact with the browser’s cache when fetching.\n\n\n  get cache() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The cache getter steps are to return this’s request’s cache mode.\n\n\n    return this[kState].cache;\n  } // Returns the redirect mode associated with request,\n  // which is a string indicating how redirects for the\n  // request will be handled during fetching. A request\n  // will follow redirects by default.\n\n\n  get redirect() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The redirect getter steps are to return this’s request’s redirect mode.\n\n\n    return this[kState].redirect;\n  } // Returns request’s subresource integrity metadata, which is a\n  // cryptographic hash of the resource being fetched. Its value\n  // consists of multiple hashes separated by whitespace. [SRI]\n\n\n  get integrity() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The integrity getter steps are to return this’s request’s integrity\n    // metadata.\n\n\n    return this[kState].integrity;\n  } // Returns a boolean indicating whether or not request can outlive the\n  // global in which it was created.\n\n\n  get keepalive() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The keepalive getter steps are to return this’s request’s keepalive.\n\n\n    return this[kState].keepalive;\n  } // Returns a boolean indicating whether or not request is for a reload\n  // navigation.\n\n\n  get isReloadNavigation() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The isReloadNavigation getter steps are to return true if this’s\n    // request’s reload-navigation flag is set; otherwise false.\n\n\n    return this[kState].reloadNavigation;\n  } // Returns a boolean indicating whether or not request is for a history\n  // navigation (a.k.a. back-foward navigation).\n\n\n  get isHistoryNavigation() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The isHistoryNavigation getter steps are to return true if this’s request’s\n    // history-navigation flag is set; otherwise false.\n\n\n    return this[kState].historyNavigation;\n  } // Returns the signal associated with request, which is an AbortSignal\n  // object indicating whether or not request has been aborted, and its\n  // abort event handler.\n\n\n  get signal() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // The signal getter steps are to return this’s signal.\n\n\n    return this[kSignal];\n  } // Returns a clone of request.\n\n\n  clone() {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation');\n    } // 1. If this is unusable, then throw a TypeError.\n\n\n    if (this.bodyUsed || this.body && this.body.locked) {\n      throw new TypeError('unusable');\n    } // 2. Let clonedRequest be the result of cloning this’s request.\n\n\n    const clonedRequest = cloneRequest(this[kState]); // 3. Let clonedRequestObject be the result of creating a Request object,\n    // given clonedRequest, this’s headers’s guard, and this’s relevant Realm.\n\n    const clonedRequestObject = new Request(kInit);\n    clonedRequestObject[kState] = clonedRequest;\n    clonedRequestObject[kRealm] = this[kRealm];\n    clonedRequestObject[kHeaders] = new Headers();\n    clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;\n    clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];\n    clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm]; // 4. Make clonedRequestObject’s signal follow this’s signal.\n\n    const ac = new AbortController();\n\n    if (this.signal.aborted) {\n      ac.abort();\n    } else {\n      this.signal.addEventListener('abort', function () {\n        ac.abort();\n      }, {\n        once: true\n      });\n    }\n\n    clonedRequestObject[kSignal] = ac.signal; // 4. Return clonedRequestObject.\n\n    return clonedRequestObject;\n  }\n\n}\n\nmixinBody(Request.prototype);\n\nfunction makeRequest(init) {\n  // https://fetch.spec.whatwg.org/#requests\n  const request = {\n    method: 'GET',\n    localURLsOnly: false,\n    unsafeRequest: false,\n    body: null,\n    client: null,\n    reservedClient: null,\n    replacesClientId: '',\n    window: 'client',\n    keepalive: false,\n    serviceWorkers: 'all',\n    initiator: '',\n    destination: '',\n    priority: null,\n    origin: 'client',\n    policyContainer: 'client',\n    referrer: 'client',\n    referrerPolicy: '',\n    mode: 'no-cors',\n    useCORSPreflightFlag: false,\n    credentials: 'same-origin',\n    useCredentials: false,\n    cache: 'default',\n    redirect: 'follow',\n    integrity: '',\n    cryptoGraphicsNonceMetadata: '',\n    parserMetadata: '',\n    reloadNavigation: false,\n    historyNavigation: false,\n    userActivation: false,\n    taintedOrigin: false,\n    redirectCount: 0,\n    responseTainting: 'basic',\n    preventNoCacheCacheControlHeaderModification: false,\n    done: false,\n    timingAllowFailed: false,\n    ...init,\n    headersList: init.headersList ? new HeadersList(...init.headersList) : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList.map(url => new URL(url))] : []\n  };\n  request.url = request.urlList[0];\n  return request;\n} // https://fetch.spec.whatwg.org/#concept-request-clone\n\n\nfunction cloneRequest(request) {\n  // To clone a request request, run these steps:\n  // 1. Let newRequest be a copy of request, except for its body.\n  const newRequest = makeRequest({ ...request,\n    body: null\n  }); // 2. If request’s body is non-null, set newRequest’s body to the\n  // result of cloning request’s body.\n\n  if (request.body != null) {\n    newRequest.body = cloneBody(request.body);\n  } // 3. Return newRequest.\n\n\n  return newRequest;\n}\n\nObject.defineProperties(Request.prototype, {\n  method: kEnumerableProperty,\n  url: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  signal: kEnumerableProperty\n});\nmodule.exports = {\n  Request,\n  makeRequest\n};","map":{"version":3,"sources":["/Users/jake/workspace/token-builder/node_modules/undici/lib/fetch/request.js"],"names":["extractBody","mixinBody","cloneBody","require","Headers","fill","fillHeaders","HeadersList","util","isValidHTTPToken","EnvironmentSettingsObject","toUSVString","forbiddenMethods","corsSafeListedMethods","referrerPolicy","requestRedirect","requestMode","requestCredentials","requestCache","kEnumerableProperty","kHeaders","kSignal","kState","kGuard","kRealm","kHeadersList","assert","TransformStream","kInit","Symbol","requestFinalizer","FinalizationRegistry","signal","abort","removeEventListener","Request","constructor","length","TypeError","undefined","input","init","settingsObject","request","fallbackMode","baseUrl","parsedURL","URL","err","error","cause","username","password","makeRequest","urlList","origin","window","sameOrigin","method","headersList","unsafeRequest","client","priority","referrer","mode","credentials","cache","redirect","integrity","keepalive","reloadNavigation","historyNavigation","Object","keys","url","parsedReferrer","includes","String","Boolean","indexOf","toUpperCase","ac","AbortController","aborted","addEventListener","once","register","headers","push","inputBody","body","initBody","extractedBody","contentType","has","append","inputOrInitBody","source","useCORSPreflightFlag","finalBody","isDisturbed","stream","locked","identityTransform","pipeThrough","readable","toStringTag","name","toString","destination","isReloadNavigation","isHistoryNavigation","clone","bodyUsed","clonedRequest","cloneRequest","clonedRequestObject","prototype","localURLsOnly","reservedClient","replacesClientId","serviceWorkers","initiator","policyContainer","useCredentials","cryptoGraphicsNonceMetadata","parserMetadata","userActivation","taintedOrigin","redirectCount","responseTainting","preventNoCacheCacheControlHeaderModification","done","timingAllowFailed","map","newRequest","defineProperties","module","exports"],"mappings":"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","sourcesContent":["/* globals AbortController */\n\n'use strict'\n\nconst { extractBody, mixinBody, cloneBody } = require('./body')\nconst { Headers, fill: fillHeaders, HeadersList } = require('./headers')\nconst util = require('../core/util')\nconst {\n  isValidHTTPToken,\n  EnvironmentSettingsObject,\n  toUSVString\n} = require('./util')\nconst {\n  forbiddenMethods,\n  corsSafeListedMethods,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache\n} = require('./constants')\nconst { kEnumerableProperty } = util\nconst { kHeaders, kSignal, kState, kGuard, kRealm } = require('./symbols')\nconst { kHeadersList } = require('../core/symbols')\nconst assert = require('assert')\n\nlet TransformStream\n\nconst kInit = Symbol('init')\n\nconst requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {\n  signal.removeEventListener('abort', abort)\n})\n\n// https://fetch.spec.whatwg.org/#request-class\nclass Request {\n  // https://fetch.spec.whatwg.org/#dom-request\n  constructor (...args) {\n    if (args[0] === kInit) {\n      return\n    }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to construct 'Request': 1 argument required, but only ${args.length} present.`\n      )\n    }\n    if (\n      args.length >= 1 &&\n      typeof args[1] !== 'object' &&\n      args[1] !== undefined\n    ) {\n      throw new TypeError(\n        \"Failed to construct 'Request': cannot convert to dictionary.\"\n      )\n    }\n    const input = args[0] instanceof Request ? args[0] : toUSVString(args[0])\n    const init = args.length >= 1 ? args[1] ?? {} : {}\n\n    // TODO\n    this[kRealm] = { settingsObject: {} }\n\n    // 1. Let request be null.\n    let request = null\n\n    // 2. Let fallbackMode be null.\n    let fallbackMode = null\n\n    // 3. Let baseURL be this’s relevant settings object’s API base URL.\n    const baseUrl = this[kRealm].settingsObject.baseUrl\n\n    // 4. Let signal be null.\n    let signal = null\n\n    // 5. If input is a string, then:\n    if (typeof input === 'string') {\n      // 1. Let parsedURL be the result of parsing input with baseURL.\n      // 2. If parsedURL is failure, then throw a TypeError.\n      let parsedURL\n      try {\n        parsedURL = new URL(input, baseUrl)\n      } catch (err) {\n        const error = new TypeError('Failed to parse URL from ' + input)\n        error.cause = err\n        throw error\n      }\n\n      // 3. If parsedURL includes credentials, then throw a TypeError.\n      if (parsedURL.username || parsedURL.password) {\n        throw new TypeError(\n          'Request cannot be constructed from a URL that includes credentials: ' +\n            input\n        )\n      }\n\n      // 4. Set request to a new request whose URL is parsedURL.\n      request = makeRequest({ urlList: [parsedURL] })\n\n      // 5. Set fallbackMode to \"cors\".\n      fallbackMode = 'cors'\n    } else {\n      // 6. Otherwise:\n\n      // 7. Assert: input is a Request object.\n      assert(input instanceof Request)\n\n      // 8. Set request to input’s request.\n      request = input[kState]\n\n      // 9. Set signal to input’s signal.\n      signal = input[kSignal]\n    }\n\n    // 7. Let origin be this’s relevant settings object’s origin.\n    const origin = this[kRealm].settingsObject.origin\n\n    // 8. Let window be \"client\".\n    let window = 'client'\n\n    // 9. If request’s window is an environment settings object and its origin\n    // is same origin with origin, then set window to request’s window.\n    if (\n      request.window instanceof EnvironmentSettingsObject &&\n      sameOrigin(request.window, origin)\n    ) {\n      window = request.window\n    }\n\n    // 10. If init[\"window\"] exists and is non-null, then throw a TypeError.\n    if (init.window !== undefined && init.window != null) {\n      throw new TypeError(`'window' option '${window}' must be null`)\n    }\n\n    // 11. If init[\"window\"] exists, then set window to \"no-window\".\n    if (init.window !== undefined) {\n      window = 'no-window'\n    }\n\n    // 12. Set request to a new request with the following properties:\n    request = makeRequest({\n      // URL request’s URL.\n      // undici implementation note: this is set as the first item in request's urlList in makeRequest\n      // method request’s method.\n      method: request.method,\n      // header list A copy of request’s header list.\n      // undici implementation note: headersList is cloned in makeRequest\n      headersList: request.headersList,\n      // unsafe-request flag Set.\n      unsafeRequest: request.unsafeRequest,\n      // client This’s relevant settings object.\n      client: request.client,\n      // window window.\n      window,\n      // priority request’s priority.\n      priority: request.priority,\n      // origin request’s origin. The propagation of the origin is only significant for navigation requests\n      // being handled by a service worker. In this scenario a request can have an origin that is different\n      // from the current client.\n      origin: request.origin,\n      // referrer request’s referrer.\n      referrer: request.referrer,\n      // referrer policy request’s referrer policy.\n      referrerPolicy: request.referrerPolicy,\n      // mode request’s mode.\n      mode: request.mode,\n      // credentials mode request’s credentials mode.\n      credentials: request.credentials,\n      // cache mode request’s cache mode.\n      cache: request.cache,\n      // redirect mode request’s redirect mode.\n      redirect: request.redirect,\n      // integrity metadata request’s integrity metadata.\n      integrity: request.integrity,\n      // keepalive request’s keepalive.\n      keepalive: request.keepalive,\n      // reload-navigation flag request’s reload-navigation flag.\n      reloadNavigation: request.reloadNavigation,\n      // history-navigation flag request’s history-navigation flag.\n      historyNavigation: request.historyNavigation,\n      // URL list A clone of request’s URL list.\n      // undici implementation note: urlList is cloned in makeRequest\n      urlList: request.urlList\n    })\n\n    // 13. If init is not empty, then:\n    if (Object.keys(init).length > 0) {\n      // 1. If request’s mode is \"navigate\", then set it to \"same-origin\".\n      if (request.mode === 'navigate') {\n        request.mode = 'same-origin'\n      }\n\n      // 2. Unset request’s reload-navigation flag.\n      request.reloadNavigation = false\n\n      // 3. Unset request’s history-navigation flag.\n      request.historyNavigation = false\n\n      // 4. Set request’s origin to \"client\".\n      request.origin = 'client'\n\n      // 5. Set request’s referrer to \"client\"\n      request.referrer = 'client'\n\n      // 6. Set request’s referrer policy to the empty string.\n      request.referrerPolicy = ''\n\n      // 7. Set request’s URL to request’s current URL.\n      request.url = request.urlList[request.urlList.length - 1]\n\n      // 8. Set request’s URL list to « request’s URL ».\n      request.urlList = [request.url]\n    }\n\n    // 14. If init[\"referrer\"] exists, then:\n    if (init.referrer !== undefined) {\n      // 1. Let referrer be init[\"referrer\"].\n      const referrer = init.referrer\n\n      // 2. If referrer is the empty string, then set request’s referrer to \"no-referrer\".\n      if (referrer === '') {\n        request.referrer = 'no-referrer'\n      } else {\n        // 1. Let parsedReferrer be the result of parsing referrer with\n        // baseURL.\n        // 2. If parsedReferrer is failure, then throw a TypeError.\n        let parsedReferrer\n        try {\n          parsedReferrer = new URL(referrer, baseUrl)\n        } catch (err) {\n          const error = new TypeError(\n            `Referrer \"${referrer}\" is not a valid URL.`\n          )\n          error.cause = err\n          throw error\n        }\n\n        // 3. If one of the following is true\n        // parsedReferrer’s cannot-be-a-base-URL is true, scheme is \"about\",\n        // and path contains a single string \"client\"\n        // parsedReferrer’s origin is not same origin with origin\n        // then set request’s referrer to \"client\".\n        // TODO\n\n        // 4. Otherwise, set request’s referrer to parsedReferrer.\n        request.referrer = parsedReferrer\n      }\n    }\n\n    // 15. If init[\"referrerPolicy\"] exists, then set request’s referrer policy\n    // to it.\n    if (init.referrerPolicy !== undefined) {\n      request.referrerPolicy = init.referrerPolicy\n      if (!referrerPolicy.includes(request.referrerPolicy)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.referrerPolicy}' is not a valid enum value of type ReferrerPolicy.`\n        )\n      }\n    }\n\n    // 16. Let mode be init[\"mode\"] if it exists, and fallbackMode otherwise.\n    let mode\n    if (init.mode !== undefined) {\n      mode = init.mode\n      if (!requestMode.includes(mode)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.mode}' is not a valid enum value of type RequestMode.`\n        )\n      }\n    } else {\n      mode = fallbackMode\n    }\n\n    // 17. If mode is \"navigate\", then throw a TypeError.\n    if (mode === 'navigate') {\n      throw new TypeError()\n    }\n\n    // 18. If mode is non-null, set request’s mode to mode.\n    if (mode != null) {\n      request.mode = mode\n    }\n\n    // 19. If init[\"credentials\"] exists, then set request’s credentials mode\n    // to it.\n    if (init.credentials !== undefined) {\n      request.credentials = init.credentials\n      if (!requestCredentials.includes(request.credentials)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.credentials}' is not a valid enum value of type RequestCredentials.`\n        )\n      }\n    }\n\n    // 18. If init[\"cache\"] exists, then set request’s cache mode to it.\n    if (init.cache !== undefined) {\n      request.cache = init.cache\n      if (!requestCache.includes(request.cache)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.cache}' is not a valid enum value of type RequestCache.`\n        )\n      }\n    }\n\n    // 21. If request’s cache mode is \"only-if-cached\" and request’s mode is\n    // not \"same-origin\", then throw a TypeError.\n    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {\n      throw new TypeError(\n        \"'only-if-cached' can be set only with 'same-origin' mode\"\n      )\n    }\n\n    // 22. If init[\"redirect\"] exists, then set request’s redirect mode to it.\n    if (init.redirect !== undefined) {\n      request.redirect = init.redirect\n      if (!requestRedirect.includes(request.redirect)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.redirect}' is not a valid enum value of type RequestRedirect.`\n        )\n      }\n    }\n\n    // 23. If init[\"integrity\"] exists, then set request’s integrity metadata to it.\n    if (init.integrity !== undefined && init.integrity != null) {\n      request.integrity = String(init.integrity)\n    }\n\n    // 24. If init[\"keepalive\"] exists, then set request’s keepalive to it.\n    if (init.keepalive !== undefined) {\n      request.keepalive = Boolean(init.keepalive)\n    }\n\n    // 25. If init[\"method\"] exists, then:\n    if (init.method !== undefined) {\n      // 1. Let method be init[\"method\"].\n      let method = init.method\n\n      // 2. If method is not a method or method is a forbidden method, then\n      // throw a TypeError.\n      if (!isValidHTTPToken(init.method)) {\n        throw TypeError(`'${init.method}' is not a valid HTTP method.`)\n      }\n\n      if (forbiddenMethods.indexOf(method.toUpperCase()) !== -1) {\n        throw TypeError(`'${init.method}' HTTP method is unsupported.`)\n      }\n\n      // 3. Normalize method.\n      // https://fetch.spec.whatwg.org/#concept-method-normalize\n      method = init.method.toUpperCase()\n\n      // 4. Set request’s method to method.\n      request.method = method\n    }\n\n    // 26. If init[\"signal\"] exists, then set signal to it.\n    if (init.signal !== undefined) {\n      signal = init.signal\n    }\n\n    // 27. Set this’s request to request.\n    this[kState] = request\n\n    // 28. Set this’s signal to a new AbortSignal object with this’s relevant\n    // Realm.\n    const ac = new AbortController()\n    this[kSignal] = ac.signal\n    this[kSignal][kRealm] = this[kRealm]\n\n    // 29. If signal is not null, then make this’s signal follow signal.\n    if (signal != null) {\n      if (\n        !signal ||\n        typeof signal.aborted !== 'boolean' ||\n        typeof signal.addEventListener !== 'function'\n      ) {\n        throw new TypeError(\n          \"Failed to construct 'Request': member signal is not of type AbortSignal.\"\n        )\n      }\n\n      if (signal.aborted) {\n        ac.abort()\n      } else {\n        const abort = () => ac.abort()\n        signal.addEventListener('abort', abort, { once: true })\n        requestFinalizer.register(this, { signal, abort })\n      }\n    }\n\n    // 30. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is request’s header list and guard is\n    // \"request\".\n    this[kHeaders] = new Headers()\n    this[kHeaders][kGuard] = 'request'\n    this[kHeaders][kHeadersList] = request.headersList\n    this[kHeaders][kRealm] = this[kRealm]\n\n    // 31. If this’s request’s mode is \"no-cors\", then:\n    if (mode === 'no-cors') {\n      // 1. If this’s request’s method is not a CORS-safelisted method,\n      // then throw a TypeError.\n      if (!corsSafeListedMethods.includes(request.method)) {\n        throw new TypeError(\n          `'${request.method} is unsupported in no-cors mode.`\n        )\n      }\n\n      // 2. Set this’s headers’s guard to \"request-no-cors\".\n      this[kHeaders][kGuard] = 'request-no-cors'\n    }\n\n    // 32. If init is not empty, then:\n    if (Object.keys(init).length !== 0) {\n      // 1. Let headers be a copy of this’s headers and its associated header\n      // list.\n      let headers = new Headers(this.headers)\n\n      // 2. If init[\"headers\"] exists, then set headers to init[\"headers\"].\n      if (init.headers !== undefined) {\n        headers = init.headers\n      }\n\n      // 3. Empty this’s headers’s header list.\n      this[kState].headersList = new HeadersList()\n      this[kHeaders][kHeadersList] = this[kState].headersList\n\n      // 4. If headers is a Headers object, then for each header in its header\n      // list, append header’s name/header’s value to this’s headers.\n      if (headers instanceof Headers) {\n        this[kState].headersList.push(...headers[kHeadersList])\n      } else {\n        // 5. Otherwise, fill this’s headers with headers.\n        fillHeaders(this[kState].headersList, headers)\n      }\n    }\n\n    // 33. Let inputBody be input’s request’s body if input is a Request\n    // object; otherwise null.\n    const inputBody = input instanceof Request ? input[kState].body : null\n\n    // 34. If either init[\"body\"] exists and is non-null or inputBody is\n    // non-null, and request’s method is `GET` or `HEAD`, then throw a\n    // TypeError.\n    if (\n      ((init.body !== undefined && init.body != null) || inputBody != null) &&\n      (request.method === 'GET' || request.method === 'HEAD')\n    ) {\n      throw new TypeError('Request with GET/HEAD method cannot have body.')\n    }\n\n    // 35. Let initBody be null.\n    let initBody = null\n\n    // 36. If init[\"body\"] exists and is non-null, then:\n    if (init.body !== undefined && init.body != null) {\n      // 1. Let Content-Type be null.\n      // 2. Set initBody and Content-Type to the result of extracting\n      // init[\"body\"], with keepalive set to request’s keepalive.\n      const [extractedBody, contentType] = extractBody(\n        init.body,\n        request.keepalive\n      )\n      initBody = extractedBody\n\n      // 3, If Content-Type is non-null and this’s headers’s header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type to\n      // this’s headers.\n      if (contentType && !this[kHeaders].has('content-type')) {\n        this[kHeaders].append('content-type', contentType)\n      }\n    }\n\n    // 37. Let inputOrInitBody be initBody if it is non-null; otherwise\n    // inputBody.\n    const inputOrInitBody = initBody ?? inputBody\n\n    // 38. If inputOrInitBody is non-null and inputOrInitBody’s source is\n    // null, then:\n    if (inputOrInitBody != null && inputOrInitBody.source == null) {\n      // 1. If this’s request’s mode is neither \"same-origin\" nor \"cors\",\n      // then throw a TypeError.\n      if (request.mode !== 'same-origin' && request.mode !== 'cors') {\n        throw new TypeError(\n          'If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"'\n        )\n      }\n\n      // 2. Set this’s request’s use-CORS-preflight flag.\n      request.useCORSPreflightFlag = true\n    }\n\n    // 39. Let finalBody be inputOrInitBody.\n    let finalBody = inputOrInitBody\n\n    // 40. If initBody is null and inputBody is non-null, then:\n    if (initBody == null && inputBody != null) {\n      // 1. If input is unusable, then throw a TypeError.\n      if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {\n        throw new TypeError(\n          'Cannot construct a Request with a Request object that has already been used.'\n        )\n      }\n\n      // 2. Set finalBody to the result of creating a proxy for inputBody.\n      if (!TransformStream) {\n        TransformStream = require('stream/web').TransformStream\n      }\n\n      // https://streams.spec.whatwg.org/#readablestream-create-a-proxy\n      const identityTransform = new TransformStream()\n      inputBody.stream.pipeThrough(identityTransform)\n      finalBody = {\n        source: inputBody.source,\n        length: inputBody.length,\n        stream: identityTransform.readable\n      }\n    }\n\n    // 41. Set this’s request’s body to finalBody.\n    this[kState].body = finalBody\n  }\n\n  get [Symbol.toStringTag] () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this.constructor.name\n  }\n\n  // Returns request’s HTTP method, which is \"GET\" by default.\n  get method () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The method getter steps are to return this’s request’s method.\n    return this[kState].method\n  }\n\n  // Returns the URL of request as a string.\n  get url () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The url getter steps are to return this’s request’s URL, serialized.\n    return this[kState].url.toString()\n  }\n\n  // Returns a Headers object consisting of the headers associated with request.\n  // Note that headers added in the network layer by the user agent will not\n  // be accounted for in this object, e.g., the \"Host\" header.\n  get headers () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders]\n  }\n\n  // Returns the kind of resource requested by request, e.g., \"document\"\n  // or \"script\".\n  get destination () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The destination getter are to return this’s request’s destination.\n    return this[kState].destination\n  }\n\n  // Returns the referrer of request. Its value can be a same-origin URL if\n  // explicitly set in init, the empty string to indicate no referrer, and\n  // \"about:client\" when defaulting to the global’s default. This is used\n  // during fetching to determine the value of the `Referer` header of the\n  // request being made.\n  get referrer () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // 1. If this’s request’s referrer is \"no-referrer\", then return the\n    // empty string.\n    if (this[kState].referrer === 'no-referrer') {\n      return ''\n    }\n\n    // 2. If this’s request’s referrer is \"client\", then return\n    // \"about:client\".\n    if (this[kState].referrer === 'client') {\n      return 'about:client'\n    }\n\n    // Return this’s request’s referrer, serialized.\n    return this[kState].referrer.toString()\n  }\n\n  // Returns the referrer policy associated with request.\n  // This is used during fetching to compute the value of the request’s\n  // referrer.\n  get referrerPolicy () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The referrerPolicy getter steps are to return this’s request’s referrer policy.\n    return this[kState].referrerPolicy\n  }\n\n  // Returns the mode associated with request, which is a string indicating\n  // whether the request will use CORS, or will be restricted to same-origin\n  // URLs.\n  get mode () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The mode getter steps are to return this’s request’s mode.\n    return this[kState].mode\n  }\n\n  // Returns the credentials mode associated with request,\n  // which is a string indicating whether credentials will be sent with the\n  // request always, never, or only when sent to a same-origin URL.\n  get credentials () {\n    // The credentials getter steps are to return this’s request’s credentials mode.\n    return this[kState].credentials\n  }\n\n  // Returns the cache mode associated with request,\n  // which is a string indicating how the request will\n  // interact with the browser’s cache when fetching.\n  get cache () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The cache getter steps are to return this’s request’s cache mode.\n    return this[kState].cache\n  }\n\n  // Returns the redirect mode associated with request,\n  // which is a string indicating how redirects for the\n  // request will be handled during fetching. A request\n  // will follow redirects by default.\n  get redirect () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The redirect getter steps are to return this’s request’s redirect mode.\n    return this[kState].redirect\n  }\n\n  // Returns request’s subresource integrity metadata, which is a\n  // cryptographic hash of the resource being fetched. Its value\n  // consists of multiple hashes separated by whitespace. [SRI]\n  get integrity () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The integrity getter steps are to return this’s request’s integrity\n    // metadata.\n    return this[kState].integrity\n  }\n\n  // Returns a boolean indicating whether or not request can outlive the\n  // global in which it was created.\n  get keepalive () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The keepalive getter steps are to return this’s request’s keepalive.\n    return this[kState].keepalive\n  }\n\n  // Returns a boolean indicating whether or not request is for a reload\n  // navigation.\n  get isReloadNavigation () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The isReloadNavigation getter steps are to return true if this’s\n    // request’s reload-navigation flag is set; otherwise false.\n    return this[kState].reloadNavigation\n  }\n\n  // Returns a boolean indicating whether or not request is for a history\n  // navigation (a.k.a. back-foward navigation).\n  get isHistoryNavigation () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The isHistoryNavigation getter steps are to return true if this’s request’s\n    // history-navigation flag is set; otherwise false.\n    return this[kState].historyNavigation\n  }\n\n  // Returns the signal associated with request, which is an AbortSignal\n  // object indicating whether or not request has been aborted, and its\n  // abort event handler.\n  get signal () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The signal getter steps are to return this’s signal.\n    return this[kSignal]\n  }\n\n  // Returns a clone of request.\n  clone () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || (this.body && this.body.locked)) {\n      throw new TypeError('unusable')\n    }\n\n    // 2. Let clonedRequest be the result of cloning this’s request.\n    const clonedRequest = cloneRequest(this[kState])\n\n    // 3. Let clonedRequestObject be the result of creating a Request object,\n    // given clonedRequest, this’s headers’s guard, and this’s relevant Realm.\n    const clonedRequestObject = new Request(kInit)\n    clonedRequestObject[kState] = clonedRequest\n    clonedRequestObject[kRealm] = this[kRealm]\n    clonedRequestObject[kHeaders] = new Headers()\n    clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList\n    clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard]\n    clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm]\n\n    // 4. Make clonedRequestObject’s signal follow this’s signal.\n    const ac = new AbortController()\n    if (this.signal.aborted) {\n      ac.abort()\n    } else {\n      this.signal.addEventListener(\n        'abort',\n        function () {\n          ac.abort()\n        },\n        { once: true }\n      )\n    }\n    clonedRequestObject[kSignal] = ac.signal\n\n    // 4. Return clonedRequestObject.\n    return clonedRequestObject\n  }\n}\n\nmixinBody(Request.prototype)\n\nfunction makeRequest (init) {\n  // https://fetch.spec.whatwg.org/#requests\n  const request = {\n    method: 'GET',\n    localURLsOnly: false,\n    unsafeRequest: false,\n    body: null,\n    client: null,\n    reservedClient: null,\n    replacesClientId: '',\n    window: 'client',\n    keepalive: false,\n    serviceWorkers: 'all',\n    initiator: '',\n    destination: '',\n    priority: null,\n    origin: 'client',\n    policyContainer: 'client',\n    referrer: 'client',\n    referrerPolicy: '',\n    mode: 'no-cors',\n    useCORSPreflightFlag: false,\n    credentials: 'same-origin',\n    useCredentials: false,\n    cache: 'default',\n    redirect: 'follow',\n    integrity: '',\n    cryptoGraphicsNonceMetadata: '',\n    parserMetadata: '',\n    reloadNavigation: false,\n    historyNavigation: false,\n    userActivation: false,\n    taintedOrigin: false,\n    redirectCount: 0,\n    responseTainting: 'basic',\n    preventNoCacheCacheControlHeaderModification: false,\n    done: false,\n    timingAllowFailed: false,\n    ...init,\n    headersList: init.headersList\n      ? new HeadersList(...init.headersList)\n      : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList.map((url) => new URL(url))] : []\n  }\n  request.url = request.urlList[0]\n  return request\n}\n\n// https://fetch.spec.whatwg.org/#concept-request-clone\nfunction cloneRequest (request) {\n  // To clone a request request, run these steps:\n\n  // 1. Let newRequest be a copy of request, except for its body.\n  const newRequest = makeRequest({ ...request, body: null })\n\n  // 2. If request’s body is non-null, set newRequest’s body to the\n  // result of cloning request’s body.\n  if (request.body != null) {\n    newRequest.body = cloneBody(request.body)\n  }\n\n  // 3. Return newRequest.\n  return newRequest\n}\n\nObject.defineProperties(Request.prototype, {\n  method: kEnumerableProperty,\n  url: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  signal: kEnumerableProperty\n})\n\nmodule.exports = { Request, makeRequest }\n"]},"metadata":{},"sourceType":"script"}