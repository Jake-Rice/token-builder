{"ast":null,"code":"'use strict';\n\nconst {\n  finished\n} = require('stream');\n\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = require('../core/errors');\n\nconst util = require('../core/util');\n\nconst {\n  AsyncResource\n} = require('async_hooks');\n\nconst {\n  addSignal,\n  removeSignal\n} = require('./abort-signal');\n\nclass StreamHandler extends AsyncResource {\n  constructor(opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts');\n    }\n\n    const {\n      signal,\n      method,\n      opaque,\n      body,\n      onInfo,\n      responseHeaders\n    } = opts;\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback');\n      }\n\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory');\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method');\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback');\n      }\n\n      super('UNDICI_STREAM');\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err);\n      }\n\n      throw err;\n    }\n\n    this.responseHeaders = responseHeaders || null;\n    this.opaque = opaque || null;\n    this.factory = factory;\n    this.callback = callback;\n    this.res = null;\n    this.abort = null;\n    this.context = null;\n    this.trailers = null;\n    this.body = body;\n    this.onInfo = onInfo || null;\n\n    if (util.isStream(body)) {\n      body.on('error', err => {\n        this.onError(err);\n      });\n    }\n\n    addSignal(this, signal);\n  }\n\n  onConnect(abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError();\n    }\n\n    this.abort = abort;\n    this.context = context;\n  }\n\n  onHeaders(statusCode, rawHeaders, resume) {\n    const {\n      factory,\n      opaque,\n      context\n    } = this;\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        this.onInfo({\n          statusCode,\n          headers\n        });\n      }\n\n      return;\n    }\n\n    this.factory = null;\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n    const res = this.runInAsyncScope(factory, null, {\n      statusCode,\n      headers,\n      opaque,\n      context\n    });\n\n    if (!res || typeof res.write !== 'function' || typeof res.end !== 'function' || typeof res.on !== 'function') {\n      throw new InvalidReturnValueError('expected Writable');\n    }\n\n    res.on('drain', resume); // TODO: Avoid finished. It registers an unecessary amount of listeners.\n\n    finished(res, {\n      readable: false\n    }, err => {\n      const {\n        callback,\n        res,\n        opaque,\n        trailers,\n        abort\n      } = this;\n      this.res = null;\n\n      if (err || !res.readable) {\n        util.destroy(res, err);\n      }\n\n      this.callback = null;\n      this.runInAsyncScope(callback, null, err || null, {\n        opaque,\n        trailers\n      });\n\n      if (err) {\n        abort();\n      }\n    });\n    this.res = res;\n    const needDrain = res.writableNeedDrain !== undefined ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;\n    return needDrain !== true;\n  }\n\n  onData(chunk) {\n    const {\n      res\n    } = this;\n    return res.write(chunk);\n  }\n\n  onComplete(trailers) {\n    const {\n      res\n    } = this;\n    removeSignal(this);\n    this.trailers = util.parseHeaders(trailers);\n    res.end();\n  }\n\n  onError(err) {\n    const {\n      res,\n      callback,\n      opaque,\n      body\n    } = this;\n    removeSignal(this);\n    this.factory = null;\n\n    if (res) {\n      this.res = null;\n      util.destroy(res, err);\n    } else if (callback) {\n      this.callback = null;\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, {\n          opaque\n        });\n      });\n    }\n\n    if (body) {\n      this.body = null;\n      util.destroy(body, err);\n    }\n  }\n\n}\n\nfunction stream(opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data);\n      });\n    });\n  }\n\n  try {\n    this.dispatch(opts, new StreamHandler(opts, factory, callback));\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err;\n    }\n\n    const opaque = opts && opts.opaque;\n    queueMicrotask(() => callback(err, {\n      opaque\n    }));\n  }\n}\n\nmodule.exports = stream;","map":{"version":3,"sources":["/Users/jake/workspace/token-builder/node_modules/undici/lib/api/api-stream.js"],"names":["finished","require","InvalidArgumentError","InvalidReturnValueError","RequestAbortedError","util","AsyncResource","addSignal","removeSignal","StreamHandler","constructor","opts","factory","callback","signal","method","opaque","body","onInfo","responseHeaders","on","addEventListener","err","isStream","destroy","nop","res","abort","context","trailers","onError","onConnect","onHeaders","statusCode","rawHeaders","resume","headers","parseRawHeaders","parseHeaders","runInAsyncScope","write","end","readable","needDrain","writableNeedDrain","undefined","_writableState","onData","chunk","onComplete","queueMicrotask","stream","Promise","resolve","reject","call","data","dispatch","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { finished } = require('stream')\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = require('../core/errors')\nconst util = require('../core/util')\nconst { AsyncResource } = require('async_hooks')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass StreamHandler extends AsyncResource {\n  constructor (opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_STREAM')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.factory = factory\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.context = null\n    this.trailers = null\n    this.body = body\n    this.onInfo = onInfo || null\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume) {\n    const { factory, opaque, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.factory = null\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    const res = this.runInAsyncScope(factory, null, {\n      statusCode,\n      headers,\n      opaque,\n      context\n    })\n\n    if (\n      !res ||\n      typeof res.write !== 'function' ||\n      typeof res.end !== 'function' ||\n      typeof res.on !== 'function'\n    ) {\n      throw new InvalidReturnValueError('expected Writable')\n    }\n\n    res.on('drain', resume)\n    // TODO: Avoid finished. It registers an unecessary amount of listeners.\n    finished(res, { readable: false }, (err) => {\n      const { callback, res, opaque, trailers, abort } = this\n\n      this.res = null\n      if (err || !res.readable) {\n        util.destroy(res, err)\n      }\n\n      this.callback = null\n      this.runInAsyncScope(callback, null, err || null, { opaque, trailers })\n\n      if (err) {\n        abort()\n      }\n    })\n\n    this.res = res\n\n    const needDrain = res.writableNeedDrain !== undefined\n      ? res.writableNeedDrain\n      : res._writableState && res._writableState.needDrain\n\n    return needDrain !== true\n  }\n\n  onData (chunk) {\n    const { res } = this\n\n    return res.write(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    this.trailers = util.parseHeaders(trailers)\n\n    res.end()\n  }\n\n  onError (err) {\n    const { res, callback, opaque, body } = this\n\n    removeSignal(this)\n\n    this.factory = null\n\n    if (res) {\n      this.res = null\n      util.destroy(res, err)\n    } else if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction stream (opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new StreamHandler(opts, factory, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = stream\n"]},"metadata":{},"sourceType":"script"}