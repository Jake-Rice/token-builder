{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HttpProvider = void 0;\n\nconst events_1 = require(\"events\");\n\nconst undici_1 = require(\"undici\");\n\nconst constants_1 = require(\"../../constants\");\n\nconst jsonrpc_1 = require(\"../../util/jsonrpc\");\n\nconst packageInfo_1 = require(\"../../util/packageInfo\");\n\nconst errors_1 = require(\"../errors\");\n\nconst errors_list_1 = require(\"../errors-list\");\n\nconst errors_2 = require(\"./errors\");\n\nfunction isErrorResponse(response) {\n  return typeof response.error !== \"undefined\";\n}\n\nconst MAX_RETRIES = 6;\nconst MAX_RETRY_AWAIT_SECONDS = 5;\nconst TOO_MANY_REQUEST_STATUS = 429;\nconst hardhatVersion = (0, packageInfo_1.getHardhatVersion)();\n\nclass HttpProvider extends events_1.EventEmitter {\n  constructor(_url, _networkName) {\n    let _extraHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    let _timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 20000;\n\n    let client = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n    super();\n    this._url = _url;\n    this._networkName = _networkName;\n    this._extraHeaders = _extraHeaders;\n    this._timeout = _timeout;\n    this._nextRequestId = 1;\n    const url = new URL(this._url);\n    this._path = url.pathname;\n    this._authHeader = url.username === \"\" ? undefined : `Basic ${Buffer.from(`${url.username}:${url.password}`, \"utf-8\").toString(\"base64\")}`;\n\n    try {\n      this._dispatcher = client !== null && client !== void 0 ? client : new undici_1.Pool(url.origin);\n    } catch (e) {\n      if (e instanceof TypeError && e.message === \"Invalid URL\") {\n        e.message += ` ${url.origin}`;\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw e;\n    }\n  }\n\n  get url() {\n    return this._url;\n  }\n\n  async request(args) {\n    // We create the error here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new errors_2.ProviderError(\"HttpProviderError\", -1);\n\n    const jsonRpcRequest = this._getJsonRpcRequest(args.method, args.params);\n\n    const jsonRpcResponse = await this._fetchJsonRpcResponse(jsonRpcRequest);\n\n    if (isErrorResponse(jsonRpcResponse)) {\n      error.message = jsonRpcResponse.error.message;\n      error.code = jsonRpcResponse.error.code;\n      error.data = jsonRpcResponse.error.data; // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n      throw error;\n    }\n\n    if (args.method === \"hardhat_reset\") {\n      this.emit(constants_1.HARDHAT_NETWORK_RESET_EVENT);\n    }\n\n    if (args.method === \"evm_revert\") {\n      this.emit(constants_1.HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);\n    }\n\n    return jsonRpcResponse.result;\n  }\n  /**\n   * Sends a batch of requests. Fails if any of them fails.\n   */\n\n\n  async sendBatch(batch) {\n    // We create the errors here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new errors_2.ProviderError(\"HttpProviderError\", -1); // we need this to sort the responses\n\n    const idToIndexMap = {};\n    const requests = batch.map((r, i) => {\n      const jsonRpcRequest = this._getJsonRpcRequest(r.method, r.params);\n\n      idToIndexMap[jsonRpcRequest.id] = i;\n      return jsonRpcRequest;\n    });\n    const jsonRpcResponses = await this._fetchJsonRpcResponse(requests);\n\n    for (const response of jsonRpcResponses) {\n      if (isErrorResponse(response)) {\n        error.message = response.error.message;\n        error.code = response.error.code;\n        error.data = response.error.data; // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n        throw error;\n      }\n    } // We already know that it has this type, but TS can't infer it.\n\n\n    const responses = jsonRpcResponses; // we use the id to sort the responses so that they match the order of the requests\n\n    const sortedResponses = responses.map(response => [idToIndexMap[response.id], response.result]).sort((_ref, _ref2) => {\n      let [indexA] = _ref;\n      let [indexB] = _ref2;\n      return indexA - indexB;\n    }).map(_ref3 => {\n      let [, result] = _ref3;\n      return result;\n    });\n    return sortedResponses;\n  }\n\n  async _fetchJsonRpcResponse(request) {\n    let retryNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    try {\n      const response = await this._dispatcher.request({\n        method: \"POST\",\n        path: this._path,\n        body: JSON.stringify(request),\n        maxRedirections: 10,\n        headersTimeout: process.env.DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI !== undefined ? 0 : this._timeout,\n        headers: Object.assign({\n          \"Content-Type\": \"application/json\",\n          \"User-Agent\": `hardhat ${hardhatVersion}`,\n          Authorization: this._authHeader\n        }, this._extraHeaders)\n      });\n\n      if (this._isRateLimitResponse(response)) {\n        // \"The Fetch Standard allows users to skip consuming the response body\n        // by relying on garbage collection to release connection resources.\n        // Undici does not do the same. Therefore, it is important to always\n        // either consume or cancel the response body.\"\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        // It's not clear how to \"cancel\", so we'll just consume:\n        await response.body.text();\n\n        const seconds = this._getRetryAfterSeconds(response);\n\n        if (seconds !== undefined && this._shouldRetry(retryNumber, seconds)) {\n          return await this._retry(request, seconds, retryNumber);\n        }\n\n        const url = new URL(this._url); // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n        throw new errors_2.ProviderError(`Too Many Requests error received from ${url.hostname}`, -32005 // Limit exceeded according to EIP1474\n        );\n      }\n\n      return (0, jsonrpc_1.parseJsonResponse)(await response.body.text());\n    } catch (error) {\n      if (error.code === \"ECONNREFUSED\") {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.NODE_IS_NOT_RUNNING, {\n          network: this._networkName\n        }, error);\n      }\n\n      if (error.type === \"request-timeout\") {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.NETWORK_TIMEOUT, {}, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n\n  async _retry(request, seconds, retryNumber) {\n    await new Promise(resolve => setTimeout(resolve, 1000 * seconds));\n    return this._fetchJsonRpcResponse(request, retryNumber + 1);\n  }\n\n  _getJsonRpcRequest(method) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      id: this._nextRequestId++\n    };\n  }\n\n  _shouldRetry(retryNumber, retryAfterSeconds) {\n    if (retryNumber > MAX_RETRIES) {\n      return false;\n    }\n\n    if (retryAfterSeconds > MAX_RETRY_AWAIT_SECONDS) {\n      return false;\n    }\n\n    return true;\n  }\n\n  _isRateLimitResponse(response) {\n    return response.statusCode === TOO_MANY_REQUEST_STATUS;\n  }\n\n  _getRetryAfterSeconds(response) {\n    const header = response.headers[\"retry-after\"];\n\n    if (header === undefined || header === null) {\n      return undefined;\n    }\n\n    const parsed = parseInt(header, 10);\n\n    if (isNaN(parsed)) {\n      return undefined;\n    }\n\n    return parsed;\n  }\n\n}\n\nexports.HttpProvider = HttpProvider;","map":{"version":3,"mappings":"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","names":["isErrorResponse","response","error","MAX_RETRIES","MAX_RETRY_AWAIT_SECONDS","TOO_MANY_REQUEST_STATUS","hardhatVersion","HttpProvider","events_1","constructor","_url","_networkName","_extraHeaders","_timeout","client","undefined","url","URL","_path","pathname","_authHeader","username","Buffer","from","password","toString","_dispatcher","undici_1","origin","e","TypeError","message","request","args","errors_2","jsonRpcRequest","_getJsonRpcRequest","method","params","jsonRpcResponse","_fetchJsonRpcResponse","code","data","emit","constants_1","result","sendBatch","batch","idToIndexMap","requests","map","r","i","id","jsonRpcResponses","responses","sortedResponses","sort","indexA","indexB","retryNumber","path","body","JSON","stringify","maxRedirections","headersTimeout","process","env","DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI","headers","Authorization","_isRateLimitResponse","text","seconds","_getRetryAfterSeconds","_shouldRetry","_retry","hostname","errors_1","errors_list_1","NETWORK","NODE_IS_NOT_RUNNING","network","type","NETWORK_TIMEOUT","Promise","resolve","setTimeout","jsonrpc","_nextRequestId","retryAfterSeconds","statusCode","header","parsed","parseInt","isNaN","exports"],"sources":["/Users/jake/workspace/token-builder/node_modules/hardhat/src/internal/core/providers/http.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport { Dispatcher, Pool } from \"undici\";\n\nimport { EIP1193Provider, RequestArguments } from \"../../../types\";\nimport {\n  HARDHAT_NETWORK_RESET_EVENT,\n  HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT,\n} from \"../../constants\";\nimport {\n  FailedJsonRpcResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  parseJsonResponse,\n  SuccessfulJsonRpcResponse,\n} from \"../../util/jsonrpc\";\nimport { getHardhatVersion } from \"../../util/packageInfo\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\n\nimport { ProviderError } from \"./errors\";\n\nfunction isErrorResponse(response: any): response is FailedJsonRpcResponse {\n  return typeof response.error !== \"undefined\";\n}\n\nconst MAX_RETRIES = 6;\nconst MAX_RETRY_AWAIT_SECONDS = 5;\n\nconst TOO_MANY_REQUEST_STATUS = 429;\n\nconst hardhatVersion = getHardhatVersion();\n\nexport class HttpProvider extends EventEmitter implements EIP1193Provider {\n  private _nextRequestId = 1;\n  private _dispatcher: Dispatcher;\n  private _path: string;\n  private _authHeader: string | undefined;\n\n  constructor(\n    private readonly _url: string,\n    private readonly _networkName: string,\n    private readonly _extraHeaders: { [name: string]: string } = {},\n    private readonly _timeout = 20000,\n    client: Dispatcher | undefined = undefined\n  ) {\n    super();\n    const url = new URL(this._url);\n    this._path = url.pathname;\n    this._authHeader =\n      url.username === \"\"\n        ? undefined\n        : `Basic ${Buffer.from(\n            `${url.username}:${url.password}`,\n            \"utf-8\"\n          ).toString(\"base64\")}`;\n    try {\n      this._dispatcher = client ?? new Pool(url.origin);\n    } catch (e) {\n      if (e instanceof TypeError && e.message === \"Invalid URL\") {\n        e.message += ` ${url.origin}`;\n      }\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n\n  public get url(): string {\n    return this._url;\n  }\n\n  public async request(args: RequestArguments): Promise<unknown> {\n    // We create the error here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new ProviderError(\"HttpProviderError\", -1);\n\n    const jsonRpcRequest = this._getJsonRpcRequest(\n      args.method,\n      args.params as any[]\n    );\n    const jsonRpcResponse = await this._fetchJsonRpcResponse(jsonRpcRequest);\n\n    if (isErrorResponse(jsonRpcResponse)) {\n      error.message = jsonRpcResponse.error.message;\n      error.code = jsonRpcResponse.error.code;\n      error.data = jsonRpcResponse.error.data;\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n\n    if (args.method === \"hardhat_reset\") {\n      this.emit(HARDHAT_NETWORK_RESET_EVENT);\n    }\n    if (args.method === \"evm_revert\") {\n      this.emit(HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);\n    }\n\n    return jsonRpcResponse.result;\n  }\n\n  /**\n   * Sends a batch of requests. Fails if any of them fails.\n   */\n  public async sendBatch(\n    batch: Array<{ method: string; params: any[] }>\n  ): Promise<any[]> {\n    // We create the errors here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new ProviderError(\"HttpProviderError\", -1);\n\n    // we need this to sort the responses\n    const idToIndexMap: Record<string, number> = {};\n\n    const requests = batch.map((r, i) => {\n      const jsonRpcRequest = this._getJsonRpcRequest(r.method, r.params);\n      idToIndexMap[jsonRpcRequest.id] = i;\n      return jsonRpcRequest;\n    });\n\n    const jsonRpcResponses = await this._fetchJsonRpcResponse(requests);\n\n    for (const response of jsonRpcResponses) {\n      if (isErrorResponse(response)) {\n        error.message = response.error.message;\n        error.code = response.error.code;\n        error.data = response.error.data;\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw error;\n      }\n    }\n\n    // We already know that it has this type, but TS can't infer it.\n    const responses = jsonRpcResponses as SuccessfulJsonRpcResponse[];\n\n    // we use the id to sort the responses so that they match the order of the requests\n    const sortedResponses = responses\n      .map(\n        (response) =>\n          [idToIndexMap[response.id], response.result] as [number, any]\n      )\n      .sort(([indexA], [indexB]) => indexA - indexB)\n      .map(([, result]) => result);\n\n    return sortedResponses;\n  }\n\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest,\n    retryNumber?: number\n  ): Promise<JsonRpcResponse>;\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest[],\n    retryNumber?: number\n  ): Promise<JsonRpcResponse[]>;\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest | JsonRpcRequest[],\n    retryNumber?: number\n  ): Promise<JsonRpcResponse | JsonRpcResponse[]>;\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest | JsonRpcRequest[],\n    retryNumber = 0\n  ): Promise<JsonRpcResponse | JsonRpcResponse[]> {\n    try {\n      const response = await this._dispatcher.request({\n        method: \"POST\",\n        path: this._path,\n        body: JSON.stringify(request),\n        maxRedirections: 10,\n        headersTimeout:\n          process.env.DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI !== undefined\n            ? 0\n            : this._timeout,\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"User-Agent\": `hardhat ${hardhatVersion}`,\n          Authorization: this._authHeader,\n          ...this._extraHeaders,\n        },\n      });\n\n      if (this._isRateLimitResponse(response)) {\n        // \"The Fetch Standard allows users to skip consuming the response body\n        // by relying on garbage collection to release connection resources.\n        // Undici does not do the same. Therefore, it is important to always\n        // either consume or cancel the response body.\"\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        // It's not clear how to \"cancel\", so we'll just consume:\n        await response.body.text();\n        const seconds = this._getRetryAfterSeconds(response);\n        if (seconds !== undefined && this._shouldRetry(retryNumber, seconds)) {\n          return await this._retry(request, seconds, retryNumber);\n        }\n\n        const url = new URL(this._url);\n\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw new ProviderError(\n          `Too Many Requests error received from ${url.hostname}`,\n          -32005 // Limit exceeded according to EIP1474\n        );\n      }\n\n      return parseJsonResponse(await response.body.text());\n    } catch (error: any) {\n      if (error.code === \"ECONNREFUSED\") {\n        throw new HardhatError(\n          ERRORS.NETWORK.NODE_IS_NOT_RUNNING,\n          { network: this._networkName },\n          error\n        );\n      }\n\n      if (error.type === \"request-timeout\") {\n        throw new HardhatError(ERRORS.NETWORK.NETWORK_TIMEOUT, {}, error);\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n\n  private async _retry(\n    request: JsonRpcRequest | JsonRpcRequest[],\n    seconds: number,\n    retryNumber: number\n  ) {\n    await new Promise((resolve) => setTimeout(resolve, 1000 * seconds));\n    return this._fetchJsonRpcResponse(request, retryNumber + 1);\n  }\n\n  private _getJsonRpcRequest(\n    method: string,\n    params: any[] = []\n  ): JsonRpcRequest {\n    return {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      id: this._nextRequestId++,\n    };\n  }\n\n  private _shouldRetry(retryNumber: number, retryAfterSeconds: number) {\n    if (retryNumber > MAX_RETRIES) {\n      return false;\n    }\n\n    if (retryAfterSeconds > MAX_RETRY_AWAIT_SECONDS) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private _isRateLimitResponse(response: Dispatcher.ResponseData) {\n    return response.statusCode === TOO_MANY_REQUEST_STATUS;\n  }\n\n  private _getRetryAfterSeconds(\n    response: Dispatcher.ResponseData\n  ): number | undefined {\n    const header = response.headers[\"retry-after\"];\n\n    if (header === undefined || header === null) {\n      return undefined;\n    }\n\n    const parsed = parseInt(header, 10);\n    if (isNaN(parsed)) {\n      return undefined;\n    }\n\n    return parsed;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}