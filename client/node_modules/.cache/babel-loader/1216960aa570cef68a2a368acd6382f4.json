{"ast":null,"code":"'use strict';\n\nconst net = require('net');\n\nconst assert = require('assert');\n\nconst util = require('./util');\n\nconst {\n  InvalidArgumentError,\n  ConnectTimeoutError\n} = require('./errors');\n\nlet tls; // include tls conditionally since it is not always available\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nfunction buildConnector(_ref) {\n  let {\n    maxCachedSessions,\n    socketPath,\n    timeout,\n    ...opts\n  } = _ref;\n\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero');\n  }\n\n  const options = {\n    path: socketPath,\n    ...opts\n  };\n  const sessionCache = new Map();\n  timeout = timeout == null ? 10e3 : timeout;\n  maxCachedSessions = maxCachedSessions == null ? 100 : maxCachedSessions;\n  return function connect(_ref2, callback) {\n    let {\n      hostname,\n      host,\n      protocol,\n      port,\n      servername\n    } = _ref2;\n    let socket;\n\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = require('tls');\n      }\n\n      servername = servername || options.servername || util.getServerName(host) || null;\n      const sessionKey = servername || hostname;\n      const session = sessionCache.get(sessionKey) || null;\n      assert(sessionKey);\n      socket = tls.connect({\n        highWaterMark: 16384,\n        // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        port: port || 443,\n        host: hostname\n      });\n      socket.on('session', function (session) {\n        // cache is disabled\n        if (maxCachedSessions === 0) {\n          return;\n        }\n\n        if (sessionCache.size >= maxCachedSessions) {\n          // remove the oldest session\n          const {\n            value: oldestKey\n          } = sessionCache.keys().next();\n          sessionCache.delete(oldestKey);\n        }\n\n        sessionCache.set(sessionKey, session);\n      }).on('error', function (err) {\n        if (sessionKey && err.code !== 'UND_ERR_INFO') {\n          // TODO (fix): Only delete for session related errors.\n          sessionCache.delete(sessionKey);\n        }\n      });\n    } else {\n      socket = net.connect({\n        highWaterMark: 64 * 1024,\n        // Same as nodejs fs streams.\n        ...options,\n        port: port || 80,\n        host: hostname\n      });\n    }\n\n    const timeoutId = timeout ? setTimeout(onConnectTimeout, timeout, socket) : null;\n    socket.setNoDelay(true).once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n      clearTimeout(timeoutId);\n\n      if (callback) {\n        const cb = callback;\n        callback = null;\n        cb(null, this);\n      }\n    }).on('error', function (err) {\n      clearTimeout(timeoutId);\n\n      if (callback) {\n        const cb = callback;\n        callback = null;\n        cb(err);\n      }\n    });\n    return socket;\n  };\n}\n\nfunction onConnectTimeout(socket) {\n  util.destroy(socket, new ConnectTimeoutError());\n}\n\nmodule.exports = buildConnector;","map":{"version":3,"sources":["/Users/jake/workspace/token-builder/node_modules/undici/lib/core/connect.js"],"names":["net","require","assert","util","InvalidArgumentError","ConnectTimeoutError","tls","buildConnector","maxCachedSessions","socketPath","timeout","opts","Number","isInteger","options","path","sessionCache","Map","connect","callback","hostname","host","protocol","port","servername","socket","getServerName","sessionKey","session","get","highWaterMark","on","size","value","oldestKey","keys","next","delete","set","err","code","timeoutId","setTimeout","onConnectTimeout","setNoDelay","once","clearTimeout","cb","destroy","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst net = require('net')\nconst assert = require('assert')\nconst util = require('./util')\nconst { InvalidArgumentError, ConnectTimeoutError } = require('./errors')\nlet tls // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nfunction buildConnector ({ maxCachedSessions, socketPath, timeout, ...opts }) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')\n  }\n\n  const options = { path: socketPath, ...opts }\n  const sessionCache = new Map()\n  timeout = timeout == null ? 10e3 : timeout\n  maxCachedSessions = maxCachedSessions == null ? 100 : maxCachedSessions\n\n  return function connect ({ hostname, host, protocol, port, servername }, callback) {\n    let socket\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = require('tls') \n      }\n      servername = servername || options.servername || util.getServerName(host) || null\n\n      const sessionKey = servername || hostname\n      const session = sessionCache.get(sessionKey) || null\n\n      assert(sessionKey)\n\n      socket = tls.connect({\n        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        port: port || 443,\n        host: hostname\n      })\n\n      socket\n        .on('session', function (session) {\n          // cache is disabled\n          if (maxCachedSessions === 0) {\n            return\n          }\n\n          if (sessionCache.size >= maxCachedSessions) {\n            // remove the oldest session\n            const { value: oldestKey } = sessionCache.keys().next()\n            sessionCache.delete(oldestKey)\n          }\n\n          sessionCache.set(sessionKey, session)\n        })\n        .on('error', function (err) {\n          if (sessionKey && err.code !== 'UND_ERR_INFO') {\n            // TODO (fix): Only delete for session related errors.\n            sessionCache.delete(sessionKey)\n          }\n        })\n    } else {\n      socket = net.connect({\n        highWaterMark: 64 * 1024, // Same as nodejs fs streams.\n        ...options,\n        port: port || 80,\n        host: hostname\n      })\n    }\n\n    const timeoutId = timeout\n      ? setTimeout(onConnectTimeout, timeout, socket)\n      : null\n\n    socket\n      .setNoDelay(true)\n      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n        clearTimeout(timeoutId)\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(null, this)\n        }\n      })\n      .on('error', function (err) {\n        clearTimeout(timeoutId)\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(err)\n        }\n      })\n\n    return socket\n  }\n}\n\nfunction onConnectTimeout (socket) {\n  util.destroy(socket, new ConnectTimeoutError())\n}\n\nmodule.exports = buildConnector\n"]},"metadata":{},"sourceType":"script"}