{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.download = void 0;\n\nconst fs_1 = __importDefault(require(\"fs\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst util_1 = __importDefault(require(\"util\"));\n\nconst packageInfo_1 = require(\"./packageInfo\");\n\nconst TEMP_FILE_PREFIX = \"tmp-\";\nconst hardhatVersion = (0, packageInfo_1.getHardhatVersion)();\n\nfunction resolveTempFileName(filePath) {\n  const {\n    dir,\n    ext,\n    name\n  } = path_1.default.parse(filePath);\n  return path_1.default.format({\n    dir,\n    ext,\n    name: `${TEMP_FILE_PREFIX}${name}`\n  });\n}\n\nasync function download(url, filePath) {\n  let timeoutMillis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10000;\n  const {\n    pipeline\n  } = await Promise.resolve().then(() => __importStar(require(\"stream\")));\n  const {\n    getGlobalDispatcher,\n    ProxyAgent,\n    request\n  } = await Promise.resolve().then(() => __importStar(require(\"undici\")));\n  const streamPipeline = util_1.default.promisify(pipeline);\n\n  function chooseDispatcher() {\n    if (process.env.HTTPS_PROXY !== undefined) {\n      return new ProxyAgent(process.env.HTTPS_PROXY);\n    }\n\n    if (process.env.HTTP_PROXY !== undefined) {\n      return new ProxyAgent(process.env.HTTP_PROXY);\n    }\n\n    return getGlobalDispatcher();\n  } // Fetch the url\n\n\n  const response = await request(url, {\n    dispatcher: chooseDispatcher(),\n    headersTimeout: timeoutMillis,\n    maxRedirections: 10,\n    method: \"GET\",\n    headers: {\n      \"User-Agent\": `hardhat ${hardhatVersion}`\n    }\n  });\n\n  if (response.statusCode >= 200 && response.statusCode <= 299) {\n    const tmpFilePath = resolveTempFileName(filePath);\n    await fs_extra_1.default.ensureDir(path_1.default.dirname(filePath));\n    await streamPipeline(response.body, fs_1.default.createWriteStream(tmpFilePath));\n    return fs_extra_1.default.move(tmpFilePath, filePath, {\n      overwrite: true\n    });\n  } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n  throw new Error(`Failed to download ${url} - ${response.statusCode} received. ${await response.body.text()}`);\n}\n\nexports.download = download;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AAEA;;AAEA,MAAMA,gBAAgB,GAAG,MAAzB;AAEA,MAAMC,cAAc,GAAG,sCAAvB;;AAEA,SAASC,mBAAT,CAA6BC,QAA7B,EAA6C;AAC3C,QAAM;AAAEC,OAAF;AAAOC,OAAP;AAAYC;AAAZ,MAAqBC,eAAKC,KAAL,CAAWL,QAAX,CAA3B;AAEA,SAAOI,eAAKE,MAAL,CAAY;AACjBL,OADiB;AAEjBC,OAFiB;AAGjBC,QAAI,EAAE,GAAGN,gBAAgB,GAAGM,IAAI;AAHf,GAAZ,CAAP;AAKD;;AAEM,eAAeI,QAAf,CACLC,GADK,EAELR,QAFK,EAGgB;AAAA,MAArBS,aAAqB,uEAAL,KAAK;AAErB,QAAM;AAAEC;AAAF,MAAe,wDAAa,QAAb,GAArB;AACA,QAAM;AAAEC,uBAAF;AAAuBC,cAAvB;AAAmCC;AAAnC,MAA+C,wDAAa,QAAb,GAArD;AACA,QAAMC,cAAc,GAAGC,eAAKC,SAAL,CAAeN,QAAf,CAAvB;;AAEA,WAASO,gBAAT,GAAyB;AACvB,QAAIC,OAAO,CAACC,GAAR,CAAYC,WAAZ,KAA4BC,SAAhC,EAA2C;AACzC,aAAO,IAAIT,UAAJ,CAAeM,OAAO,CAACC,GAAR,CAAYC,WAA3B,CAAP;AACD;;AAED,QAAIF,OAAO,CAACC,GAAR,CAAYG,UAAZ,KAA2BD,SAA/B,EAA0C;AACxC,aAAO,IAAIT,UAAJ,CAAeM,OAAO,CAACC,GAAR,CAAYG,UAA3B,CAAP;AACD;;AAED,WAAOX,mBAAmB,EAA1B;AACD,GAhBoB,CAkBrB;;;AACA,QAAMY,QAAQ,GAAG,MAAMV,OAAO,CAACL,GAAD,EAAM;AAClCgB,cAAU,EAAEP,gBAAgB,EADM;AAElCQ,kBAAc,EAAEhB,aAFkB;AAGlCiB,mBAAe,EAAE,EAHiB;AAIlCC,UAAM,EAAE,KAJ0B;AAKlCC,WAAO,EAAE;AACP,oBAAc,WAAW9B,cAAc;AADhC;AALyB,GAAN,CAA9B;;AAUA,MAAIyB,QAAQ,CAACM,UAAT,IAAuB,GAAvB,IAA8BN,QAAQ,CAACM,UAAT,IAAuB,GAAzD,EAA8D;AAC5D,UAAMC,WAAW,GAAG/B,mBAAmB,CAACC,QAAD,CAAvC;AACA,UAAM+B,mBAAQC,SAAR,CAAkB5B,eAAK6B,OAAL,CAAajC,QAAb,CAAlB,CAAN;AAEA,UAAMc,cAAc,CAACS,QAAQ,CAACW,IAAV,EAAgBC,aAAGC,iBAAH,CAAqBN,WAArB,CAAhB,CAApB;AACA,WAAOC,mBAAQM,IAAR,CAAaP,WAAb,EAA0B9B,QAA1B,EAAoC;AAAEsC,eAAS,EAAE;AAAb,KAApC,CAAP;AACD,GAnCoB,CAqCrB;;;AACA,QAAM,IAAIC,KAAJ,CACJ,sBAAsB/B,GAAG,MACvBe,QAAQ,CAACM,UACX,cAAc,MAAMN,QAAQ,CAACW,IAAT,CAAcM,IAAd,EAAoB,EAHpC,CAAN;AAKD;;AA9CDC","names":["TEMP_FILE_PREFIX","hardhatVersion","resolveTempFileName","filePath","dir","ext","name","path_1","parse","format","download","url","timeoutMillis","pipeline","getGlobalDispatcher","ProxyAgent","request","streamPipeline","util_1","promisify","chooseDispatcher","process","env","HTTPS_PROXY","undefined","HTTP_PROXY","response","dispatcher","headersTimeout","maxRedirections","method","headers","statusCode","tmpFilePath","fs_extra_1","ensureDir","dirname","body","fs_1","createWriteStream","move","overwrite","Error","text","exports"],"sources":["/Users/jake/workspace/token-builder/node_modules/hardhat/src/internal/util/download.ts"],"sourcesContent":["import fs from \"fs\";\nimport fsExtra from \"fs-extra\";\nimport path from \"path\";\nimport util from \"util\";\n\nimport { getHardhatVersion } from \"./packageInfo\";\n\nconst TEMP_FILE_PREFIX = \"tmp-\";\n\nconst hardhatVersion = getHardhatVersion();\n\nfunction resolveTempFileName(filePath: string): string {\n  const { dir, ext, name } = path.parse(filePath);\n\n  return path.format({\n    dir,\n    ext,\n    name: `${TEMP_FILE_PREFIX}${name}`,\n  });\n}\n\nexport async function download(\n  url: string,\n  filePath: string,\n  timeoutMillis = 10000\n) {\n  const { pipeline } = await import(\"stream\");\n  const { getGlobalDispatcher, ProxyAgent, request } = await import(\"undici\");\n  const streamPipeline = util.promisify(pipeline);\n\n  function chooseDispatcher() {\n    if (process.env.HTTPS_PROXY !== undefined) {\n      return new ProxyAgent(process.env.HTTPS_PROXY);\n    }\n\n    if (process.env.HTTP_PROXY !== undefined) {\n      return new ProxyAgent(process.env.HTTP_PROXY);\n    }\n\n    return getGlobalDispatcher();\n  }\n\n  // Fetch the url\n  const response = await request(url, {\n    dispatcher: chooseDispatcher(),\n    headersTimeout: timeoutMillis,\n    maxRedirections: 10,\n    method: \"GET\",\n    headers: {\n      \"User-Agent\": `hardhat ${hardhatVersion}`,\n    },\n  });\n\n  if (response.statusCode >= 200 && response.statusCode <= 299) {\n    const tmpFilePath = resolveTempFileName(filePath);\n    await fsExtra.ensureDir(path.dirname(filePath));\n\n    await streamPipeline(response.body, fs.createWriteStream(tmpFilePath));\n    return fsExtra.move(tmpFilePath, filePath, { overwrite: true });\n  }\n\n  // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n  throw new Error(\n    `Failed to download ${url} - ${\n      response.statusCode\n    } received. ${await response.body.text()}`\n  );\n}\n"]},"metadata":{},"sourceType":"script"}