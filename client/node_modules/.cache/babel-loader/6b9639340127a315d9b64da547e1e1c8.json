{"ast":null,"code":"'use strict';\n\nconst {\n  getResponseData,\n  buildKey,\n  addMockDispatch\n} = require('./mock-utils');\n\nconst {\n  kDispatches,\n  kDispatchKey,\n  kDefaultHeaders,\n  kDefaultTrailers,\n  kContentLength,\n  kMockDispatch\n} = require('./mock-symbols');\n\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError\n} = require('../core/errors');\n/**\n * Defines the scope API for a interceptor reply\n */\n\n\nclass MockScope {\n  constructor(mockDispatch) {\n    this[kMockDispatch] = mockDispatch;\n  }\n  /**\n   * Delay a reply by a set amount in ms.\n   */\n\n\n  delay(waitInMs) {\n    if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n      throw new InvalidArgumentError('waitInMs must be a valid integer > 0');\n    }\n\n    this[kMockDispatch].delay = waitInMs;\n    return this;\n  }\n  /**\n   * For a defined reply, never mark as consumed.\n   */\n\n\n  persist() {\n    this[kMockDispatch].persist = true;\n    return this;\n  }\n  /**\n   * Allow one to define a reply for a set amount of matching requests.\n   */\n\n\n  times(repeatTimes) {\n    if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n      throw new InvalidArgumentError('repeatTimes must be a valid integer > 0');\n    }\n\n    this[kMockDispatch].times = repeatTimes;\n    return this;\n  }\n\n}\n/**\n * Defines an interceptor for a Mock\n */\n\n\nclass MockInterceptor {\n  constructor(opts, mockDispatches) {\n    if (typeof opts !== 'object') {\n      throw new InvalidArgumentError('opts must be an object');\n    }\n\n    if (typeof opts.path === 'undefined') {\n      throw new InvalidArgumentError('opts.path must be defined');\n    }\n\n    if (typeof opts.method === 'undefined') {\n      throw new InvalidArgumentError('opts.method must be defined');\n    }\n\n    this[kDispatchKey] = buildKey(opts);\n    this[kDispatches] = mockDispatches;\n    this[kDefaultHeaders] = {};\n    this[kDefaultTrailers] = {};\n    this[kContentLength] = false;\n  }\n\n  createMockScopeDispatchData(statusCode, data) {\n    let responseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const responseData = getResponseData(data);\n    const contentLength = this[kContentLength] ? {\n      'content-length': responseData.length\n    } : {};\n    const headers = { ...this[kDefaultHeaders],\n      ...contentLength,\n      ...responseOptions.headers\n    };\n    const trailers = { ...this[kDefaultTrailers],\n      ...responseOptions.trailers\n    };\n    return {\n      statusCode,\n      data,\n      headers,\n      trailers\n    };\n  }\n\n  validateReplyParameters(statusCode, data, responseOptions) {\n    if (typeof statusCode === 'undefined') {\n      throw new InvalidArgumentError('statusCode must be defined');\n    }\n\n    if (typeof data === 'undefined') {\n      throw new InvalidArgumentError('data must be defined');\n    }\n\n    if (typeof responseOptions !== 'object') {\n      throw new InvalidArgumentError('responseOptions must be an object');\n    }\n  }\n  /**\n   * Mock an undici request with a defined reply.\n   */\n\n\n  reply(replyData) {\n    // Values of reply aren't available right now as they\n    // can only be available when the reply callback is invoked.\n    if (typeof replyData === 'function') {\n      // We'll first wrap the provided callback in another function,\n      // this function will properly resolve the data from the callback\n      // when invoked.\n      const wrappedDefaultsCallback = opts => {\n        // Our reply options callback contains the parameter for statusCode, data and options.\n        const resolvedData = replyData(opts); // Check if it is in the right format\n\n        if (typeof resolvedData !== 'object') {\n          throw new InvalidArgumentError('reply options callback must return an object');\n        }\n\n        const {\n          statusCode,\n          data,\n          responseOptions = {}\n        } = resolvedData;\n        this.validateReplyParameters(statusCode, data, responseOptions); // Since the values can be obtained immediately we return them\n        // from this higher order function that will be resolved later.\n\n        return { ...this.createMockScopeDispatchData(statusCode, data, responseOptions)\n        };\n      }; // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.\n\n\n      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);\n      return new MockScope(newMockDispatch);\n    } // We can have either one or three parameters, if we get here,\n    // we should have 2-3 parameters. So we spread the arguments of\n    // this function to obtain the parameters, since replyData will always\n    // just be the statusCode. \n\n\n    const [statusCode, data, responseOptions = {}] = [...arguments];\n    this.validateReplyParameters(statusCode, data, responseOptions); // Send in-already provided data like usual\n\n    const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);\n    return new MockScope(newMockDispatch);\n  }\n  /**\n   * Mock an undici request with a defined error.\n   */\n\n\n  replyWithError(error) {\n    if (typeof error === 'undefined') {\n      throw new InvalidArgumentError('error must be defined');\n    }\n\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], {\n      error\n    });\n    return new MockScope(newMockDispatch);\n  }\n  /**\n   * Set default reply headers on the interceptor for subsequent replies\n   */\n\n\n  defaultReplyHeaders(headers) {\n    if (typeof headers === 'undefined') {\n      throw new InvalidArgumentError('headers must be defined');\n    }\n\n    this[kDefaultHeaders] = headers;\n    return this;\n  }\n  /**\n   * Set default reply trailers on the interceptor for subsequent replies\n   */\n\n\n  defaultReplyTrailers(trailers) {\n    if (typeof trailers === 'undefined') {\n      throw new InvalidArgumentError('trailers must be defined');\n    }\n\n    this[kDefaultTrailers] = trailers;\n    return this;\n  }\n  /**\n   * Set reply content length header for replies on the interceptor\n   */\n\n\n  replyContentLength() {\n    this[kContentLength] = true;\n    return this;\n  }\n\n}\n\nmodule.exports.MockInterceptor = MockInterceptor;\nmodule.exports.MockScope = MockScope;","map":{"version":3,"sources":["/Users/jake/workspace/token-builder/node_modules/undici/lib/mock/mock-interceptor.js"],"names":["getResponseData","buildKey","addMockDispatch","require","kDispatches","kDispatchKey","kDefaultHeaders","kDefaultTrailers","kContentLength","kMockDispatch","InvalidArgumentError","InvalidReturnValueError","MockScope","constructor","mockDispatch","delay","waitInMs","Number","isInteger","persist","times","repeatTimes","MockInterceptor","opts","mockDispatches","path","method","createMockScopeDispatchData","statusCode","data","responseOptions","responseData","contentLength","length","headers","trailers","validateReplyParameters","reply","replyData","wrappedDefaultsCallback","resolvedData","newMockDispatch","arguments","dispatchData","replyWithError","error","defaultReplyHeaders","defaultReplyTrailers","replyContentLength","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { getResponseData, buildKey, addMockDispatch } = require('./mock-utils')\nconst {\n  kDispatches,\n  kDispatchKey,\n  kDefaultHeaders,\n  kDefaultTrailers,\n  kContentLength,\n  kMockDispatch\n} = require('./mock-symbols')\nconst { InvalidArgumentError, InvalidReturnValueError } = require('../core/errors')\n\n/**\n * Defines the scope API for a interceptor reply\n */\nclass MockScope {\n  constructor (mockDispatch) {\n    this[kMockDispatch] = mockDispatch\n  }\n\n  /**\n   * Delay a reply by a set amount in ms.\n   */\n  delay (waitInMs) {\n    if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n      throw new InvalidArgumentError('waitInMs must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].delay = waitInMs\n    return this\n  }\n\n  /**\n   * For a defined reply, never mark as consumed.\n   */\n  persist () {\n    this[kMockDispatch].persist = true\n    return this\n  }\n\n  /**\n   * Allow one to define a reply for a set amount of matching requests.\n   */\n  times (repeatTimes) {\n    if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n      throw new InvalidArgumentError('repeatTimes must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].times = repeatTimes\n    return this\n  }\n}\n\n/**\n * Defines an interceptor for a Mock\n */\nclass MockInterceptor {\n  constructor (opts, mockDispatches) {\n    if (typeof opts !== 'object') {\n      throw new InvalidArgumentError('opts must be an object')\n    }\n    if (typeof opts.path === 'undefined') {\n      throw new InvalidArgumentError('opts.path must be defined')\n    }\n    if (typeof opts.method === 'undefined') {\n      throw new InvalidArgumentError('opts.method must be defined')\n    }\n\n    this[kDispatchKey] = buildKey(opts)\n    this[kDispatches] = mockDispatches\n    this[kDefaultHeaders] = {}\n    this[kDefaultTrailers] = {}\n    this[kContentLength] = false\n  }\n\n  createMockScopeDispatchData(statusCode, data, responseOptions = {}) {\n    const responseData = getResponseData(data)\n    const contentLength = this[kContentLength] ? { 'content-length': responseData.length } : {}\n    const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers }\n    const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers }\n\n    return { statusCode, data, headers, trailers };\n  }\n\n  validateReplyParameters(statusCode, data, responseOptions) {\n    if (typeof statusCode === 'undefined') {\n      throw new InvalidArgumentError('statusCode must be defined')\n    }\n    if (typeof data === 'undefined') {\n      throw new InvalidArgumentError('data must be defined')\n    }\n    if (typeof responseOptions !== 'object') {\n      throw new InvalidArgumentError('responseOptions must be an object')\n    }\n  }\n\n  /**\n   * Mock an undici request with a defined reply.\n   */\n  reply (replyData) {\n    // Values of reply aren't available right now as they\n    // can only be available when the reply callback is invoked.\n    if (typeof replyData === 'function') {\n      // We'll first wrap the provided callback in another function,\n      // this function will properly resolve the data from the callback\n      // when invoked.\n      const wrappedDefaultsCallback = (opts) => {\n        // Our reply options callback contains the parameter for statusCode, data and options.\n        const resolvedData = replyData(opts);\n\n        // Check if it is in the right format\n        if (typeof resolvedData !== 'object') {\n          throw new InvalidArgumentError('reply options callback must return an object')\n        }\n\n        const { statusCode, data, responseOptions = {}} = resolvedData;\n        this.validateReplyParameters(statusCode, data, responseOptions);\n        // Since the values can be obtained immediately we return them\n        // from this higher order function that will be resolved later.\n        return { \n          ...this.createMockScopeDispatchData(statusCode, data, responseOptions)\n        }\n      }\n\n      // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.\n      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback)\n      return new MockScope(newMockDispatch);\n    }\n\n    // We can have either one or three parameters, if we get here,\n    // we should have 2-3 parameters. So we spread the arguments of\n    // this function to obtain the parameters, since replyData will always\n    // just be the statusCode. \n    const [statusCode, data, responseOptions = {}] = [...arguments];   \n    this.validateReplyParameters(statusCode, data, responseOptions);\n\n    // Send in-already provided data like usual\n    const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData)\n    return new MockScope(newMockDispatch)\n    \n  }\n\n  /**\n   * Mock an undici request with a defined error.\n   */\n  replyWithError (error) {\n    if (typeof error === 'undefined') {\n      throw new InvalidArgumentError('error must be defined')\n    }\n\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error })\n    return new MockScope(newMockDispatch)\n  }\n\n  /**\n   * Set default reply headers on the interceptor for subsequent replies\n   */\n  defaultReplyHeaders (headers) {\n    if (typeof headers === 'undefined') {\n      throw new InvalidArgumentError('headers must be defined')\n    }\n\n    this[kDefaultHeaders] = headers\n    return this\n  }\n\n  /**\n   * Set default reply trailers on the interceptor for subsequent replies\n   */\n  defaultReplyTrailers (trailers) {\n    if (typeof trailers === 'undefined') {\n      throw new InvalidArgumentError('trailers must be defined')\n    }\n\n    this[kDefaultTrailers] = trailers\n    return this\n  }\n\n  /**\n   * Set reply content length header for replies on the interceptor\n   */\n  replyContentLength () {\n    this[kContentLength] = true\n    return this\n  }\n}\n\nmodule.exports.MockInterceptor = MockInterceptor\nmodule.exports.MockScope = MockScope\n"]},"metadata":{},"sourceType":"script"}