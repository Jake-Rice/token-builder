{"ast":null,"code":"'use strict';\n/**\n @module interfaces/common\n*/\n\nvar Suite = require('../suite');\n\nvar errors = require('../errors');\n\nvar createMissingArgumentError = errors.createMissingArgumentError;\nvar createUnsupportedError = errors.createUnsupportedError;\nvar createForbiddenExclusivityError = errors.createForbiddenExclusivityError;\n/**\n * Functions common to more than one interface.\n *\n * @private\n * @param {Suite[]} suites\n * @param {Context} context\n * @param {Mocha} mocha\n * @return {Object} An object containing common functions.\n */\n\nmodule.exports = function (suites, context, mocha) {\n  /**\n   * Check if the suite should be tested.\n   *\n   * @private\n   * @param {Suite} suite - suite to check\n   * @returns {boolean}\n   */\n  function shouldBeTested(suite) {\n    return !mocha.options.grep || mocha.options.grep && mocha.options.grep.test(suite.fullTitle()) && !mocha.options.invert;\n  }\n\n  return {\n    /**\n     * This is only present if flag --delay is passed into Mocha. It triggers\n     * root suite execution.\n     *\n     * @param {Suite} suite The root suite.\n     * @return {Function} A function which runs the root suite\n     */\n    runWithSuite: function runWithSuite(suite) {\n      return function run() {\n        suite.run();\n      };\n    },\n\n    /**\n     * Execute before running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    before: function (name, fn) {\n      suites[0].beforeAll(name, fn);\n    },\n\n    /**\n     * Execute after running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    after: function (name, fn) {\n      suites[0].afterAll(name, fn);\n    },\n\n    /**\n     * Execute before each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    beforeEach: function (name, fn) {\n      suites[0].beforeEach(name, fn);\n    },\n\n    /**\n     * Execute after each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    afterEach: function (name, fn) {\n      suites[0].afterEach(name, fn);\n    },\n    suite: {\n      /**\n       * Create an exclusive Suite; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      only: function only(opts) {\n        if (mocha.options.forbidOnly) {\n          throw createForbiddenExclusivityError(mocha);\n        }\n\n        opts.isOnly = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Create a Suite, but skip it; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      skip: function skip(opts) {\n        opts.pending = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Creates a suite.\n       *\n       * @param {Object} opts Options\n       * @param {string} opts.title Title of Suite\n       * @param {Function} [opts.fn] Suite Function (not always applicable)\n       * @param {boolean} [opts.pending] Is Suite pending?\n       * @param {string} [opts.file] Filepath where this Suite resides\n       * @param {boolean} [opts.isOnly] Is Suite exclusive?\n       * @returns {Suite}\n       */\n      create: function create(opts) {\n        var suite = Suite.create(suites[0], opts.title);\n        suite.pending = Boolean(opts.pending);\n        suite.file = opts.file;\n        suites.unshift(suite);\n\n        if (opts.isOnly) {\n          suite.markOnly();\n        }\n\n        if (suite.pending && mocha.options.forbidPending && shouldBeTested(suite)) {\n          throw createUnsupportedError('Pending test forbidden');\n        }\n\n        if (typeof opts.fn === 'function') {\n          opts.fn.call(suite);\n          suites.shift();\n        } else if (typeof opts.fn === 'undefined' && !suite.pending) {\n          throw createMissingArgumentError('Suite \"' + suite.fullTitle() + '\" was defined but no callback was supplied. ' + 'Supply a callback or explicitly skip the suite.', 'callback', 'function');\n        } else if (!opts.fn && suite.pending) {\n          suites.shift();\n        }\n\n        return suite;\n      }\n    },\n    test: {\n      /**\n       * Exclusive test-case.\n       *\n       * @param {Object} mocha\n       * @param {Function} test\n       * @returns {*}\n       */\n      only: function (mocha, test) {\n        if (mocha.options.forbidOnly) {\n          throw createForbiddenExclusivityError(mocha);\n        }\n\n        test.markOnly();\n        return test;\n      },\n\n      /**\n       * Pending test case.\n       *\n       * @param {string} title\n       */\n      skip: function (title) {\n        context.test(title);\n      }\n    }\n  };\n};","map":{"version":3,"sources":["/Users/jake/workspace/token-builder/node_modules/mocha/lib/interfaces/common.js"],"names":["Suite","require","errors","createMissingArgumentError","createUnsupportedError","createForbiddenExclusivityError","module","exports","suites","context","mocha","shouldBeTested","suite","options","grep","test","fullTitle","invert","runWithSuite","run","before","name","fn","beforeAll","after","afterAll","beforeEach","afterEach","only","opts","forbidOnly","isOnly","create","skip","pending","title","Boolean","file","unshift","markOnly","forbidPending","call","shift"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n @module interfaces/common\n*/\n\nvar Suite = require('../suite');\nvar errors = require('../errors');\nvar createMissingArgumentError = errors.createMissingArgumentError;\nvar createUnsupportedError = errors.createUnsupportedError;\nvar createForbiddenExclusivityError = errors.createForbiddenExclusivityError;\n\n/**\n * Functions common to more than one interface.\n *\n * @private\n * @param {Suite[]} suites\n * @param {Context} context\n * @param {Mocha} mocha\n * @return {Object} An object containing common functions.\n */\nmodule.exports = function (suites, context, mocha) {\n  /**\n   * Check if the suite should be tested.\n   *\n   * @private\n   * @param {Suite} suite - suite to check\n   * @returns {boolean}\n   */\n  function shouldBeTested(suite) {\n    return (\n      !mocha.options.grep ||\n      (mocha.options.grep &&\n        mocha.options.grep.test(suite.fullTitle()) &&\n        !mocha.options.invert)\n    );\n  }\n\n  return {\n    /**\n     * This is only present if flag --delay is passed into Mocha. It triggers\n     * root suite execution.\n     *\n     * @param {Suite} suite The root suite.\n     * @return {Function} A function which runs the root suite\n     */\n    runWithSuite: function runWithSuite(suite) {\n      return function run() {\n        suite.run();\n      };\n    },\n\n    /**\n     * Execute before running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    before: function (name, fn) {\n      suites[0].beforeAll(name, fn);\n    },\n\n    /**\n     * Execute after running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    after: function (name, fn) {\n      suites[0].afterAll(name, fn);\n    },\n\n    /**\n     * Execute before each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    beforeEach: function (name, fn) {\n      suites[0].beforeEach(name, fn);\n    },\n\n    /**\n     * Execute after each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    afterEach: function (name, fn) {\n      suites[0].afterEach(name, fn);\n    },\n\n    suite: {\n      /**\n       * Create an exclusive Suite; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      only: function only(opts) {\n        if (mocha.options.forbidOnly) {\n          throw createForbiddenExclusivityError(mocha);\n        }\n        opts.isOnly = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Create a Suite, but skip it; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      skip: function skip(opts) {\n        opts.pending = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Creates a suite.\n       *\n       * @param {Object} opts Options\n       * @param {string} opts.title Title of Suite\n       * @param {Function} [opts.fn] Suite Function (not always applicable)\n       * @param {boolean} [opts.pending] Is Suite pending?\n       * @param {string} [opts.file] Filepath where this Suite resides\n       * @param {boolean} [opts.isOnly] Is Suite exclusive?\n       * @returns {Suite}\n       */\n      create: function create(opts) {\n        var suite = Suite.create(suites[0], opts.title);\n        suite.pending = Boolean(opts.pending);\n        suite.file = opts.file;\n        suites.unshift(suite);\n        if (opts.isOnly) {\n          suite.markOnly();\n        }\n        if (\n          suite.pending &&\n          mocha.options.forbidPending &&\n          shouldBeTested(suite)\n        ) {\n          throw createUnsupportedError('Pending test forbidden');\n        }\n        if (typeof opts.fn === 'function') {\n          opts.fn.call(suite);\n          suites.shift();\n        } else if (typeof opts.fn === 'undefined' && !suite.pending) {\n          throw createMissingArgumentError(\n            'Suite \"' +\n              suite.fullTitle() +\n              '\" was defined but no callback was supplied. ' +\n              'Supply a callback or explicitly skip the suite.',\n            'callback',\n            'function'\n          );\n        } else if (!opts.fn && suite.pending) {\n          suites.shift();\n        }\n\n        return suite;\n      }\n    },\n\n    test: {\n      /**\n       * Exclusive test-case.\n       *\n       * @param {Object} mocha\n       * @param {Function} test\n       * @returns {*}\n       */\n      only: function (mocha, test) {\n        if (mocha.options.forbidOnly) {\n          throw createForbiddenExclusivityError(mocha);\n        }\n        test.markOnly();\n        return test;\n      },\n\n      /**\n       * Pending test case.\n       *\n       * @param {string} title\n       */\n      skip: function (title) {\n        context.test(title);\n      }\n    }\n  };\n};\n"]},"metadata":{},"sourceType":"script"}