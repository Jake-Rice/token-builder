{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst os_1 = __importDefault(require(\"os\"));\n\nconst chalk_1 = __importDefault(require(\"chalk\"));\n\nconst child_process_1 = require(\"child_process\");\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst semver_1 = __importDefault(require(\"semver\"));\n\nconst aggregate_error_1 = __importDefault(require(\"aggregate-error\"));\n\nconst artifacts_1 = require(\"../internal/artifacts\");\n\nconst config_env_1 = require(\"../internal/core/config/config-env\");\n\nconst errors_1 = require(\"../internal/core/errors\");\n\nconst errors_list_1 = require(\"../internal/core/errors-list\");\n\nconst compilation_job_1 = require(\"../internal/solidity/compilation-job\");\n\nconst compiler_1 = require(\"../internal/solidity/compiler\");\n\nconst compiler_input_1 = require(\"../internal/solidity/compiler/compiler-input\");\n\nconst downloader_1 = require(\"../internal/solidity/compiler/downloader\");\n\nconst dependencyGraph_1 = require(\"../internal/solidity/dependencyGraph\");\n\nconst parse_1 = require(\"../internal/solidity/parse\");\n\nconst resolver_1 = require(\"../internal/solidity/resolver\");\n\nconst glob_1 = require(\"../internal/util/glob\");\n\nconst global_dir_1 = require(\"../internal/util/global-dir\");\n\nconst strings_1 = require(\"../internal/util/strings\");\n\nconst builtin_tasks_1 = require(\"../types/builtin-tasks\");\n\nconst contract_names_1 = require(\"../utils/contract-names\");\n\nconst source_names_1 = require(\"../utils/source-names\");\n\nconst task_names_1 = require(\"./task-names\");\n\nconst solidity_files_cache_1 = require(\"./utils/solidity-files-cache\");\n\nfunction isConsoleLogError(error) {\n  return error.type === \"TypeError\" && typeof error.message === \"string\" && error.message.includes(\"log\") && error.message.includes(\"type(library console)\");\n}\n\nconst log = (0, debug_1.default)(\"hardhat:core:tasks:compile\");\nconst COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED = \"0.4.11\";\n/**\n * Returns a list of absolute paths to all the solidity files in the project.\n * This list doesn't include dependencies, for example solidity files inside\n * node_modules.\n *\n * This is the right task to override to change how the solidity files of the\n * project are obtained.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS, async (_, _ref) => {\n  let {\n    config\n  } = _ref;\n  const paths = await (0, glob_1.glob)(path_1.default.join(config.paths.sources, \"**/*.sol\"));\n  return paths;\n});\n/**\n * Receives a list of absolute paths and returns a list of source names\n * corresponding to each path. For example, receives\n * [\"/home/user/project/contracts/Foo.sol\"] and returns\n * [\"contracts/Foo.sol\"]. These source names will be used when the solc input\n * is generated.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES).addParam(\"sourcePaths\", undefined, undefined, config_env_1.types.any).setAction(async (_ref2, _ref3) => {\n  let {\n    sourcePaths\n  } = _ref2;\n  let {\n    config\n  } = _ref3;\n  const sourceNames = await Promise.all(sourcePaths.map(p => (0, source_names_1.localPathToSourceName)(config.paths.root, p)));\n  return sourceNames;\n});\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_READ_FILE).addParam(\"absolutePath\", undefined, undefined, config_env_1.types.string).setAction(async _ref4 => {\n  let {\n    absolutePath\n  } = _ref4;\n  const content = await fs_extra_1.default.readFile(absolutePath, {\n    encoding: \"utf8\"\n  });\n  return content;\n});\n/**\n * Receives a list of source names and returns a dependency graph. This task\n * is responsible for both resolving dependencies (like getting files from\n * node_modules) and generating the graph.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH).addParam(\"sourceNames\", undefined, undefined, config_env_1.types.any).addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any).setAction(async (_ref5, _ref6) => {\n  let {\n    sourceNames,\n    solidityFilesCache\n  } = _ref5;\n  let {\n    config,\n    run\n  } = _ref6;\n  const parser = new parse_1.Parser(solidityFilesCache);\n  const resolver = new resolver_1.Resolver(config.paths.root, parser, absolutePath => run(task_names_1.TASK_COMPILE_SOLIDITY_READ_FILE, {\n    absolutePath\n  }));\n  const resolvedFiles = await Promise.all(sourceNames.map(sn => resolver.resolveSourceName(sn)));\n  const dependencyGraph = await dependencyGraph_1.DependencyGraph.createFromResolvedFiles(resolver, resolvedFiles);\n  return dependencyGraph;\n});\n/**\n * Receives a dependency graph and a file in it, and returns the compilation\n * job for that file. The compilation job should have everything that is\n * necessary to compile that file: a compiler config to be used and a list of\n * files to use as input of the compilation.\n *\n * If the file cannot be compiled, a MatchingCompilerFailure should be\n * returned instead.\n *\n * This is the right task to override to change the compiler configuration.\n * For example, if you want to change the compiler settings when targetting\n * rinkeby, you could do something like this:\n *\n *   const compilationJob = await runSuper();\n *   if (config.network.name === 'rinkeby') {\n *     compilationJob.solidityConfig.settings = newSettings;\n *   }\n *   return compilationJob;\n *\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE).addParam(\"dependencyGraph\", undefined, undefined, config_env_1.types.any).addParam(\"file\", undefined, undefined, config_env_1.types.any).addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any).setAction(async (_ref7, _ref8) => {\n  let {\n    dependencyGraph,\n    file\n  } = _ref7;\n  let {\n    config\n  } = _ref8;\n  return (0, compilation_job_1.createCompilationJobFromFile)(dependencyGraph, file, config.solidity);\n});\n/**\n * Receives a dependency graph and returns a tuple with two arrays. The first\n * array is a list of CompilationJobsSuccess, where each item has a list of\n * compilation jobs. The second array is a list of CompilationJobsFailure,\n * where each item has a list of files that couldn't be compiled, grouped by\n * the reason for the failure.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS).addParam(\"dependencyGraph\", undefined, undefined, config_env_1.types.any).addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any).setAction(async (_ref9, _ref10) => {\n  let {\n    dependencyGraph,\n    solidityFilesCache\n  } = _ref9;\n  let {\n    run\n  } = _ref10;\n  const connectedComponents = dependencyGraph.getConnectedComponents();\n  log(`The dependency graph was divided in '${connectedComponents.length}' connected components`);\n  const compilationJobsCreationResults = await Promise.all(connectedComponents.map(graph => (0, compilation_job_1.createCompilationJobsFromConnectedComponent)(graph, file => run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE, {\n    file,\n    dependencyGraph,\n    solidityFilesCache\n  }))));\n  let jobs = [];\n  let errors = [];\n\n  for (const result of compilationJobsCreationResults) {\n    jobs = jobs.concat(result.jobs);\n    errors = errors.concat(result.errors);\n  }\n\n  return {\n    jobs,\n    errors\n  };\n});\n/**\n * Receives a list of compilation jobs and returns a new list where some of\n * the compilation jobs might've been removed.\n *\n * This task can be overriden to change the way the cache is used, or to use\n * a different approach to filtering out compilation jobs.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"force\", undefined, undefined, config_env_1.types.boolean).addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any).setAction(async _ref11 => {\n  let {\n    compilationJobs,\n    force,\n    solidityFilesCache\n  } = _ref11;\n  (0, errors_1.assertHardhatInvariant)(solidityFilesCache !== undefined, \"The implementation of this task needs a defined solidityFilesCache\");\n\n  if (force) {\n    log(`force flag enabled, not filtering`);\n    return compilationJobs;\n  }\n\n  const neededCompilationJobs = compilationJobs.filter(job => needsCompilation(job, solidityFilesCache));\n  const jobsFilteredOutCount = compilationJobs.length - neededCompilationJobs.length;\n  log(`'${jobsFilteredOutCount}' jobs were filtered out`);\n  return neededCompilationJobs;\n});\n/**\n * Receives a list of compilation jobs and returns a new list where some of\n * the jobs might've been merged.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).setAction(async _ref12 => {\n  let {\n    compilationJobs\n  } = _ref12;\n  return (0, compilation_job_1.mergeCompilationJobsWithoutBug)(compilationJobs);\n});\n/**\n * Prints a message when there's nothing to compile.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async _ref13 => {\n  let {\n    quiet\n  } = _ref13;\n\n  if (!quiet) {\n    console.log(\"Nothing to compile\");\n  }\n});\n/**\n * Receives a list of compilation jobs and sends each one to be compiled.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOBS).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async (_ref14, _ref15) => {\n  let {\n    compilationJobs,\n    quiet\n  } = _ref14;\n  let {\n    run\n  } = _ref15;\n\n  if (compilationJobs.length === 0) {\n    log(`No compilation jobs to compile`);\n    await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE, {\n      quiet\n    });\n    return {\n      artifactsEmittedPerJob: []\n    };\n  }\n\n  const {\n    default: pMap\n  } = await Promise.resolve().then(() => __importStar(require(\"p-map\")));\n  log(`Compiling ${compilationJobs.length} jobs`);\n  const versionList = [];\n\n  for (const job of compilationJobs) {\n    const solcVersion = job.getSolcConfig().version;\n\n    if (!versionList.includes(solcVersion)) {\n      // versions older than 0.4.11 don't work with hardhat\n      // see issue https://github.com/nomiclabs/hardhat/issues/2004\n      if (semver_1.default.lt(solcVersion, COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.COMPILE_TASK_UNSUPPORTED_SOLC_VERSION, {\n          version: solcVersion,\n          firstSupportedVersion: COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED\n        });\n      }\n\n      versionList.push(solcVersion);\n    }\n  }\n  /**\n   * Downloading the same version of a compiler in parallel can cause an\n   * error. When compilation jobs are executed in parallel, there's a chance\n   * that both use the same solc version and trigger this problem. To\n   * prevent that, we pre-download all the necessary compilers before\n   * running the compilation jobs.\n   */\n\n\n  for (const solcVersion of versionList) {\n    await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD, {\n      solcVersion,\n      quiet: false\n    });\n  }\n\n  const pMapOptions = {\n    concurrency: os_1.default.cpus().length,\n    stopOnError: false\n  };\n\n  try {\n    const results = await pMap(compilationJobs, (compilationJob, compilationJobIndex) => {\n      return run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOB, {\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n        quiet\n      });\n    }, pMapOptions);\n    const artifactsEmittedPerJob = results.map(_ref16 => {\n      let {\n        compilationJob,\n        artifactsEmittedPerFile\n      } = _ref16;\n      return {\n        compilationJob,\n        artifactsEmittedPerFile\n      };\n    });\n    return {\n      artifactsEmittedPerJob\n    };\n  } catch (e) {\n    if (!(e instanceof aggregate_error_1.default)) {\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n\n    for (const error of e) {\n      if (!errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.BUILTIN_TASKS.COMPILE_FAILURE)) {\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw error;\n      }\n    } // error is an aggregate error, and all errors are compilation failures\n\n\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.COMPILE_FAILURE);\n  }\n});\n/**\n * Receives a compilation job and returns a CompilerInput.\n *\n * It's not recommended to override this task to modify the solc\n * configuration, override\n * TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE instead.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).setAction(async _ref17 => {\n  let {\n    compilationJob\n  } = _ref17;\n  return (0, compiler_input_1.getInputFromCompilationJob)(compilationJob);\n});\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START).addParam(\"isCompilerDownloaded\", undefined, undefined, config_env_1.types.boolean).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string).setAction(async _ref18 => {\n  let {\n    isCompilerDownloaded,\n    solcVersion\n  } = _ref18;\n\n  if (isCompilerDownloaded) {\n    return;\n  }\n\n  console.log(`Downloading compiler ${solcVersion}`);\n});\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END).addParam(\"isCompilerDownloaded\", undefined, undefined, config_env_1.types.boolean).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string).setAction(async _ref19 => {\n  let {} = _ref19;\n});\n/**\n * Receives a solc version and returns a path to a solc binary or to a\n * downloaded solcjs module. It also returns a flag indicating if the returned\n * path corresponds to solc or solcjs.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string).setAction(async (_ref20, _ref21) => {\n  let {\n    quiet,\n    solcVersion\n  } = _ref20;\n  let {\n    run\n  } = _ref21;\n  const compilersCache = await (0, global_dir_1.getCompilersDir)();\n  const downloader = new downloader_1.CompilerDownloader(compilersCache);\n  const isCompilerDownloaded = await downloader.isCompilerDownloaded(solcVersion);\n  const {\n    longVersion,\n    platform: desiredPlatform\n  } = await downloader.getCompilerBuild(solcVersion);\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START, {\n    solcVersion,\n    isCompilerDownloaded,\n    quiet\n  });\n  let compilerPath;\n  let platform;\n  let nativeBinaryFailed = false;\n  const compilerPathResult = await downloader.getDownloadedCompilerPath(solcVersion);\n\n  if (compilerPathResult === undefined) {\n    if (desiredPlatform === downloader_1.CompilerPlatform.WASM) {\n      // if we were trying to download solcjs and it failed, there's nothing\n      // we can do\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.CANT_GET_COMPILER, {\n        version: solcVersion\n      });\n    }\n\n    nativeBinaryFailed = true;\n  } else {\n    compilerPath = compilerPathResult.compilerPath; // when using a native binary, check that it works correctly\n    // it it doesn't, force the downloader to use solcjs\n\n    if (compilerPathResult.platform !== downloader_1.CompilerPlatform.WASM) {\n      log(\"Checking native solc binary\");\n      const solcBinaryWorks = await checkSolcBinary(compilerPathResult.compilerPath);\n\n      if (!solcBinaryWorks) {\n        log(\"Native solc binary doesn't work, using solcjs instead\");\n        nativeBinaryFailed = true;\n      }\n    }\n  }\n\n  if (nativeBinaryFailed) {\n    const solcJsDownloader = new downloader_1.CompilerDownloader(compilersCache, {\n      forceSolcJs: true\n    });\n    const solcjsCompilerPath = await solcJsDownloader.getDownloadedCompilerPath(solcVersion);\n\n    if (solcjsCompilerPath === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.CANT_GET_COMPILER, {\n        version: solcVersion\n      });\n    }\n\n    compilerPath = solcjsCompilerPath.compilerPath;\n    platform = downloader_1.CompilerPlatform.WASM;\n  }\n\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END, {\n    solcVersion,\n    isCompilerDownloaded,\n    quiet\n  });\n  const isSolcJs = platform === downloader_1.CompilerPlatform.WASM;\n  (0, errors_1.assertHardhatInvariant)(compilerPath !== undefined, \"A compilerPath should be defined at this point\");\n  return {\n    compilerPath,\n    isSolcJs,\n    version: solcVersion,\n    longVersion\n  };\n});\n/**\n * Receives an absolute path to a solcjs module and the input to be compiled,\n * and returns the generated output\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLCJS).addParam(\"input\", undefined, undefined, config_env_1.types.any).addParam(\"solcJsPath\", undefined, undefined, config_env_1.types.string).setAction(async _ref22 => {\n  let {\n    input,\n    solcJsPath\n  } = _ref22;\n  const compiler = new compiler_1.Compiler(solcJsPath);\n  const output = await compiler.compile(input);\n  return output;\n});\n/**\n * Receives an absolute path to a solc binary and the input to be compiled,\n * and returns the generated output\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLC).addParam(\"input\", undefined, undefined, config_env_1.types.any).addParam(\"solcPath\", undefined, undefined, config_env_1.types.string).setAction(async _ref23 => {\n  let {\n    input,\n    solcPath\n  } = _ref23;\n  const compiler = new compiler_1.NativeCompiler(solcPath);\n  const output = await compiler.compile(input);\n  return output;\n});\n/**\n * Receives a CompilerInput and a solc version, compiles the input using a native\n * solc binary or, if that's not possible, using solcjs. Returns the generated\n * output.\n *\n * This task can be overriden to change how solc is obtained or used.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_SOLC).addParam(\"input\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int).setAction(async (_ref24, _ref25) => {\n  let {\n    input,\n    quiet,\n    solcVersion,\n    compilationJob,\n    compilationJobs,\n    compilationJobIndex\n  } = _ref24;\n  let {\n    run\n  } = _ref25;\n  const solcBuild = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD, {\n    quiet,\n    solcVersion\n  });\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START, {\n    compilationJob,\n    compilationJobs,\n    compilationJobIndex,\n    quiet\n  });\n  let output;\n\n  if (solcBuild.isSolcJs) {\n    output = await run(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLCJS, {\n      input,\n      solcJsPath: solcBuild.compilerPath\n    });\n  } else {\n    output = await run(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLC, {\n      input,\n      solcPath: solcBuild.compilerPath\n    });\n  }\n\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END, {\n    compilationJob,\n    compilationJobs,\n    compilationJobIndex,\n    output,\n    quiet\n  });\n  return {\n    output,\n    solcBuild\n  };\n});\n/**\n * This task is just a proxy to the task that compiles with solc.\n *\n * Override this to use a different task to compile a job.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE, async (taskArgs, _ref26) => {\n  let {\n    run\n  } = _ref26;\n  return run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_SOLC, taskArgs);\n});\n/**\n * Receives a compilation output and prints its errors and any other\n * information useful to the user.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS).addParam(\"output\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async _ref27 => {\n  let {\n    output\n  } = _ref27;\n\n  var _a;\n\n  if ((output === null || output === void 0 ? void 0 : output.errors) === undefined) {\n    return;\n  }\n\n  for (const error of output.errors) {\n    if (error.severity === \"error\") {\n      const errorMessage = (_a = getFormattedInternalCompilerErrorMessage(error)) !== null && _a !== void 0 ? _a : error.formattedMessage;\n      console.error(chalk_1.default.red(errorMessage));\n    } else {\n      console.warn(chalk_1.default.yellow(error.formattedMessage));\n    }\n  }\n\n  const hasConsoleErrors = output.errors.some(isConsoleLogError);\n\n  if (hasConsoleErrors) {\n    console.error(chalk_1.default.red(`The console.log call you made isn’t supported. See https://hardhat.org/console-log for the list of supported methods.`));\n    console.log();\n  }\n});\n/**\n * Receives a solc output and checks if there are errors. Throws if there are\n * errors.\n *\n * Override this task to avoid interrupting the compilation process if some\n * job has compilation errors.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_CHECK_ERRORS).addParam(\"output\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async (_ref28, _ref29) => {\n  let {\n    output,\n    quiet\n  } = _ref28;\n  let {\n    run\n  } = _ref29;\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS, {\n    output,\n    quiet\n  });\n\n  if (hasCompilationErrors(output)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.COMPILE_FAILURE);\n  }\n});\n/**\n * Saves to disk the artifacts for a compilation job. These artifacts\n * include the main artifacts, the debug files, and the build info.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"input\", undefined, undefined, config_env_1.types.any).addParam(\"output\", undefined, undefined, config_env_1.types.any).addParam(\"solcBuild\", undefined, undefined, config_env_1.types.any).setAction(async (_ref30, _ref31) => {\n  let {\n    compilationJob,\n    input,\n    output,\n    solcBuild\n  } = _ref30;\n  let {\n    artifacts,\n    run\n  } = _ref31;\n\n  var _a, _b;\n\n  const pathToBuildInfo = await artifacts.saveBuildInfo(compilationJob.getSolcConfig().version, solcBuild.longVersion, input, output);\n  const artifactsEmittedPerFile = [];\n\n  for (const file of compilationJob.getResolvedFiles()) {\n    log(`Emitting artifacts for file '${file.sourceName}'`);\n\n    if (!compilationJob.emitsArtifacts(file)) {\n      continue;\n    }\n\n    const artifactsEmitted = [];\n\n    for (const [contractName, contractOutput] of Object.entries((_b = (_a = output.contracts) === null || _a === void 0 ? void 0 : _a[file.sourceName]) !== null && _b !== void 0 ? _b : {})) {\n      log(`Emitting artifact for contract '${contractName}'`);\n      const artifact = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT, {\n        sourceName: file.sourceName,\n        contractName,\n        contractOutput\n      });\n      await artifacts.saveArtifactAndDebugFile(artifact, pathToBuildInfo);\n      artifactsEmitted.push(artifact.contractName);\n    }\n\n    artifactsEmittedPerFile.push({\n      file,\n      artifactsEmitted\n    });\n  }\n\n  return {\n    artifactsEmittedPerFile\n  };\n});\n/**\n * Generates the artifact for contract `contractName` given its compilation\n * output.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT).addParam(\"sourceName\", undefined, undefined, config_env_1.types.string).addParam(\"contractName\", undefined, undefined, config_env_1.types.string).addParam(\"contractOutput\", undefined, undefined, config_env_1.types.any).setAction(async _ref32 => {\n  let {\n    sourceName,\n    contractName,\n    contractOutput\n  } = _ref32;\n  return (0, artifacts_1.getArtifactFromContractOutput)(sourceName, contractName, contractOutput);\n});\n/**\n * Prints a message before running soljs with some input.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async _ref33 => {\n  let {} = _ref33;\n});\n/**\n * Prints a message after compiling some input\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int).addParam(\"output\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async _ref34 => {\n  let {} = _ref34;\n});\n/**\n * This is an orchestrator task that uses other subtasks to compile a\n * compilation job.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOB).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addOptionalParam(\"emitsArtifacts\", undefined, true, config_env_1.types.boolean).setAction(async (_ref35, _ref36) => {\n  let {\n    compilationJob,\n    compilationJobs,\n    compilationJobIndex,\n    quiet,\n    emitsArtifacts\n  } = _ref35;\n  let {\n    run\n  } = _ref36;\n  log(`Compiling job with version '${compilationJob.getSolcConfig().version}'`);\n  const input = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT, {\n    compilationJob\n  });\n  const {\n    output,\n    solcBuild\n  } = await run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE, {\n    solcVersion: compilationJob.getSolcConfig().version,\n    input,\n    quiet,\n    compilationJob,\n    compilationJobs,\n    compilationJobIndex\n  });\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_CHECK_ERRORS, {\n    output,\n    quiet\n  });\n  let artifactsEmittedPerFile = [];\n\n  if (emitsArtifacts) {\n    artifactsEmittedPerFile = (await run(task_names_1.TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS, {\n      compilationJob,\n      input,\n      output,\n      solcBuild\n    })).artifactsEmittedPerFile;\n  }\n\n  return {\n    artifactsEmittedPerFile,\n    compilationJob,\n    input,\n    output,\n    solcBuild\n  };\n});\n/**\n * Receives a list of CompilationJobsFailure and throws an error if it's not\n * empty.\n *\n * This task could be overriden to avoid interrupting the compilation if\n * there's some part of the project that can't be compiled.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES).addParam(\"compilationJobsCreationErrors\", undefined, undefined, config_env_1.types.any).setAction(async (_ref37, _ref38) => {\n  let {\n    compilationJobsCreationErrors\n  } = _ref37;\n  let {\n    run\n  } = _ref38;\n  const hasErrors = compilationJobsCreationErrors.length > 0;\n\n  if (hasErrors) {\n    log(`There were errors creating the compilation jobs, throwing`);\n    const reasons = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS, {\n      compilationJobsCreationErrors\n    });\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.COMPILATION_JOBS_CREATION_FAILURE, {\n      reasons\n    });\n  }\n});\n/**\n * Receives a list of CompilationJobsFailure and returns an error message\n * that describes the failure.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS).addParam(\"compilationJobsCreationErrors\", undefined, undefined, config_env_1.types.any).setAction(async _ref39 => {\n  let {\n    compilationJobsCreationErrors: errors\n  } = _ref39;\n\n  var _a, _b, _c, _d;\n\n  const noCompatibleSolc = [];\n  const incompatibleOverridenSolc = [];\n  const directlyImportsIncompatibleFile = [];\n  const indirectlyImportsIncompatibleFile = [];\n  const other = [];\n\n  for (const error of errors) {\n    if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.NO_COMPATIBLE_SOLC_VERSION_FOUND) {\n      noCompatibleSolc.push(error);\n    } else if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.INCOMPATIBLE_OVERRIDEN_SOLC_VERSION) {\n      incompatibleOverridenSolc.push(error);\n    } else if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.DIRECTLY_IMPORTS_INCOMPATIBLE_FILE) {\n      directlyImportsIncompatibleFile.push(error);\n    } else if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE) {\n      indirectlyImportsIncompatibleFile.push(error);\n    } else if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.OTHER_ERROR) {\n      other.push(error);\n    } else {\n      // add unrecognized errors to `other`\n      other.push(error);\n    }\n  }\n\n  let errorMessage = \"\";\n\n  if (incompatibleOverridenSolc.length > 0) {\n    errorMessage += `The compiler version for the following files is fixed through an override in your config file to a version that is incompatible with their Solidity version pragmas.\n\n`;\n\n    for (const error of incompatibleOverridenSolc) {\n      const {\n        sourceName\n      } = error.file;\n      const {\n        versionPragmas\n      } = error.file.content;\n      const versionsRange = versionPragmas.join(\" \");\n      log(`File ${sourceName} has an incompatible overriden compiler`);\n      errorMessage += `  * ${sourceName} (${versionsRange})\\n`;\n    }\n\n    errorMessage += \"\\n\";\n  }\n\n  if (noCompatibleSolc.length > 0) {\n    errorMessage += `The Solidity version pragma statement in these files doesn't match any of the configured compilers in your config. Change the pragma or configure additional compiler versions in your hardhat config.\n\n`;\n\n    for (const error of noCompatibleSolc) {\n      const {\n        sourceName\n      } = error.file;\n      const {\n        versionPragmas\n      } = error.file.content;\n      const versionsRange = versionPragmas.join(\" \");\n      log(`File ${sourceName} doesn't match any of the configured compilers`);\n      errorMessage += `  * ${sourceName} (${versionsRange})\\n`;\n    }\n\n    errorMessage += \"\\n\";\n  }\n\n  if (directlyImportsIncompatibleFile.length > 0) {\n    errorMessage += `These files import other files that use a different and incompatible version of Solidity:\n\n`;\n\n    for (const error of directlyImportsIncompatibleFile) {\n      const {\n        sourceName\n      } = error.file;\n      const {\n        versionPragmas\n      } = error.file.content;\n      const versionsRange = versionPragmas.join(\" \");\n      const incompatibleDirectImportsFiles = (_b = (_a = error.extra) === null || _a === void 0 ? void 0 : _a.incompatibleDirectImports) !== null && _b !== void 0 ? _b : [];\n      const incompatibleDirectImports = incompatibleDirectImportsFiles.map(x => `${x.sourceName} (${x.content.versionPragmas.join(\" \")})`);\n      log(`File ${sourceName} imports files ${incompatibleDirectImportsFiles.map(x => x.sourceName).join(\", \")} that use an incompatible version of Solidity`);\n      let directImportsText = \"\";\n\n      if (incompatibleDirectImports.length === 1) {\n        directImportsText = ` imports ${incompatibleDirectImports[0]}`;\n      } else if (incompatibleDirectImports.length === 2) {\n        directImportsText = ` imports ${incompatibleDirectImports[0]} and ${incompatibleDirectImports[1]}`;\n      } else if (incompatibleDirectImports.length > 2) {\n        const otherImportsCount = incompatibleDirectImports.length - 2;\n        directImportsText = ` imports ${incompatibleDirectImports[0]}, ${incompatibleDirectImports[1]} and ${otherImportsCount} other ${(0, strings_1.pluralize)(otherImportsCount, \"file\")}. Use --verbose to see the full list.`;\n      }\n\n      errorMessage += `  * ${sourceName} (${versionsRange})${directImportsText}\\n`;\n    }\n\n    errorMessage += \"\\n\";\n  }\n\n  if (indirectlyImportsIncompatibleFile.length > 0) {\n    errorMessage += `These files depend on other files that use a different and incompatible version of Solidity:\n\n`;\n\n    for (const error of indirectlyImportsIncompatibleFile) {\n      const {\n        sourceName\n      } = error.file;\n      const {\n        versionPragmas\n      } = error.file.content;\n      const versionsRange = versionPragmas.join(\" \");\n      const incompatibleIndirectImports = (_d = (_c = error.extra) === null || _c === void 0 ? void 0 : _c.incompatibleIndirectImports) !== null && _d !== void 0 ? _d : [];\n      const incompatibleImports = incompatibleIndirectImports.map(_ref40 => {\n        let {\n          dependency\n        } = _ref40;\n        return `${dependency.sourceName} (${dependency.content.versionPragmas.join(\" \")})`;\n      });\n\n      for (const {\n        dependency,\n        path: dependencyPath\n      } of incompatibleIndirectImports) {\n        const dependencyPathText = [sourceName, ...dependencyPath.map(x => x.sourceName), dependency.sourceName].join(\" -> \");\n        log(`File ${sourceName} depends on file ${dependency.sourceName} that uses an incompatible version of Solidity\nThe dependency path is ${dependencyPathText}\n`);\n      }\n\n      let indirectImportsText = \"\";\n\n      if (incompatibleImports.length === 1) {\n        indirectImportsText = ` depends on ${incompatibleImports[0]}`;\n      } else if (incompatibleImports.length === 2) {\n        indirectImportsText = ` depends on ${incompatibleImports[0]} and ${incompatibleImports[1]}`;\n      } else if (incompatibleImports.length > 2) {\n        const otherImportsCount = incompatibleImports.length - 2;\n        indirectImportsText = ` depends on ${incompatibleImports[0]}, ${incompatibleImports[1]} and ${otherImportsCount} other ${(0, strings_1.pluralize)(otherImportsCount, \"file\")}. Use --verbose to see the full list.`;\n      }\n\n      errorMessage += `  * ${sourceName} (${versionsRange})${indirectImportsText}\\n`;\n    }\n\n    errorMessage += \"\\n\";\n  }\n\n  if (other.length > 0) {\n    errorMessage += `These files and its dependencies cannot be compiled with your config. This can happen because they have incompatible Solidity pragmas, or don't match any of your configured Solidity compilers.\n\n${other.map(x => `  * ${x.file.sourceName}`).join(\"\\n\")}\n\n`;\n  }\n\n  errorMessage += `To learn more, run the command again with --verbose\n\nRead about compiler configuration at https://hardhat.org/config\n`;\n  return errorMessage;\n});\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async _ref41 => {\n  let {\n    compilationJobs\n  } = _ref41;\n  let count = 0;\n\n  for (const job of compilationJobs) {\n    count += job.getResolvedFiles().filter(file => job.emitsArtifacts(file)).length;\n  }\n\n  if (count > 0) {\n    console.log(`Compiled ${count} Solidity ${(0, strings_1.pluralize)(count, \"file\")} successfully`);\n  }\n});\n/**\n * Main task for compiling the solidity files in the project.\n *\n * The main responsibility of this task is to orchestrate and connect most of\n * the subtasks related to compiling solidity.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY).addParam(\"force\", undefined, undefined, config_env_1.types.boolean).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async (_ref42, _ref43) => {\n  let {\n    force,\n    quiet\n  } = _ref42;\n  let {\n    artifacts,\n    config,\n    run\n  } = _ref43;\n  const sourcePaths = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS);\n  const sourceNames = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES, {\n    sourcePaths\n  });\n  const solidityFilesCachePath = (0, solidity_files_cache_1.getSolidityFilesCachePath)(config.paths);\n  let solidityFilesCache = await solidity_files_cache_1.SolidityFilesCache.readFromFile(solidityFilesCachePath);\n  const dependencyGraph = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH, {\n    sourceNames,\n    solidityFilesCache\n  });\n  solidityFilesCache = await invalidateCacheMissingArtifacts(solidityFilesCache, artifacts, dependencyGraph.getResolvedFiles());\n  const compilationJobsCreationResult = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS, {\n    dependencyGraph,\n    solidityFilesCache\n  });\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES, {\n    compilationJobsCreationErrors: compilationJobsCreationResult.errors\n  });\n  const compilationJobs = compilationJobsCreationResult.jobs;\n  const filteredCompilationJobs = await run(task_names_1.TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS, {\n    compilationJobs,\n    force,\n    solidityFilesCache\n  });\n  const mergedCompilationJobs = await run(task_names_1.TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS, {\n    compilationJobs: filteredCompilationJobs\n  });\n  const {\n    artifactsEmittedPerJob\n  } = await run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOBS, {\n    compilationJobs: mergedCompilationJobs,\n    quiet\n  }); // update cache using the information about the emitted artifacts\n\n  for (const {\n    compilationJob: compilationJob,\n    artifactsEmittedPerFile: artifactsEmittedPerFile\n  } of artifactsEmittedPerJob) {\n    for (const {\n      file,\n      artifactsEmitted\n    } of artifactsEmittedPerFile) {\n      solidityFilesCache.addFile(file.absolutePath, {\n        lastModificationDate: file.lastModificationDate.valueOf(),\n        contentHash: file.contentHash,\n        sourceName: file.sourceName,\n        solcConfig: compilationJob.getSolcConfig(),\n        imports: file.content.imports,\n        versionPragmas: file.content.versionPragmas,\n        artifacts: artifactsEmitted\n      });\n    }\n  }\n\n  const allArtifactsEmittedPerFile = solidityFilesCache.getEntries(); // We know this is the actual implementation, so we use some\n  // non-public methods here.\n\n  const artifactsImpl = artifacts;\n  artifactsImpl.addValidArtifacts(allArtifactsEmittedPerFile);\n  await solidityFilesCache.writeToFile(solidityFilesCachePath);\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT, {\n    compilationJobs: mergedCompilationJobs,\n    quiet\n  });\n});\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_REMOVE_OBSOLETE_ARTIFACTS, async (_, _ref44) => {\n  let {\n    artifacts\n  } = _ref44;\n  // We know this is the actual implementation, so we use some\n  // non-public methods here.\n  const artifactsImpl = artifacts;\n  await artifactsImpl.removeObsoleteArtifacts();\n});\n/**\n * Returns a list of compilation tasks.\n *\n * This is the task to override to add support for other languages.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_GET_COMPILATION_TASKS, async () => {\n  return [task_names_1.TASK_COMPILE_SOLIDITY];\n});\n/**\n * Main compile task.\n *\n * This is a meta-task that just gets all the compilation tasks and runs them.\n * Right now there's only a \"compile solidity\" task.\n */\n\n(0, config_env_1.task)(task_names_1.TASK_COMPILE, \"Compiles the entire project, building all artifacts\").addFlag(\"force\", \"Force compilation ignoring cache\").addFlag(\"quiet\", \"Makes the compilation process less verbose\").setAction(async (compilationArgs, _ref45) => {\n  let {\n    run\n  } = _ref45;\n  const compilationTasks = await run(task_names_1.TASK_COMPILE_GET_COMPILATION_TASKS);\n\n  for (const compilationTask of compilationTasks) {\n    await run(compilationTask, compilationArgs);\n  }\n\n  await run(task_names_1.TASK_COMPILE_REMOVE_OBSOLETE_ARTIFACTS);\n});\n/**\n * If a file is present in the cache, but some of its artifacts are missing on\n * disk, we remove it from the cache to force it to be recompiled.\n */\n\nasync function invalidateCacheMissingArtifacts(solidityFilesCache, artifacts, resolvedFiles) {\n  for (const file of resolvedFiles) {\n    const cacheEntry = solidityFilesCache.getEntry(file.absolutePath);\n\n    if (cacheEntry === undefined) {\n      continue;\n    }\n\n    const {\n      artifacts: emittedArtifacts\n    } = cacheEntry;\n\n    for (const emittedArtifact of emittedArtifacts) {\n      const artifactExists = await artifacts.artifactExists((0, contract_names_1.getFullyQualifiedName)(file.sourceName, emittedArtifact));\n\n      if (!artifactExists) {\n        log(`Invalidate cache for '${file.absolutePath}' because artifact '${emittedArtifact}' doesn't exist`);\n        solidityFilesCache.removeEntry(file.absolutePath);\n        break;\n      }\n    }\n  }\n\n  return solidityFilesCache;\n}\n/**\n * Checks if the given compilation job needs to be done.\n */\n\n\nfunction needsCompilation(job, cache) {\n  for (const file of job.getResolvedFiles()) {\n    const hasChanged = cache.hasFileChanged(file.absolutePath, file.contentHash, // we only check if the solcConfig is different for files that\n    // emit artifacts\n    job.emitsArtifacts(file) ? job.getSolcConfig() : undefined);\n\n    if (hasChanged) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction hasCompilationErrors(output) {\n  return output.errors && output.errors.some(x => x.severity === \"error\");\n}\n\nasync function checkSolcBinary(solcPath) {\n  return new Promise(resolve => {\n    const process = (0, child_process_1.exec)(`${solcPath} --version`);\n    process.on(\"exit\", code => {\n      resolve(code === 0);\n    });\n  });\n}\n/**\n * This function returns a properly formatted Internal Compiler Error message.\n *\n * This is present due to a bug in Solidity. See: https://github.com/ethereum/solidity/issues/9926\n *\n * If the error is not an ICE, or if it's properly formatted, this function returns undefined.\n */\n\n\nfunction getFormattedInternalCompilerErrorMessage(error) {\n  if (error.formattedMessage.trim() !== \"InternalCompilerError:\") {\n    return;\n  } // We trim any final `:`, as we found some at the end of the error messages,\n  // and then trim just in case a blank space was left\n\n\n  return `${error.type}: ${error.message}`.replace(/[:\\s]*$/g, \"\").trim();\n}","map":{"version":3,"mappings":"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","names":["isConsoleLogError","error","type","message","includes","log","COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED","task_names_1","_","config","paths","path_1","join","sources","addParam","undefined","config_env_1","any","setAction","sourcePaths","sourceNames","Promise","all","map","p","root","string","absolutePath","content","fs_extra_1","readFile","encoding","addOptionalParam","solidityFilesCache","run","parser","parse_1","resolver","resolver_1","resolvedFiles","sn","resolveSourceName","dependencyGraph","dependencyGraph_1","createFromResolvedFiles","file","solidity","connectedComponents","getConnectedComponents","length","compilationJobsCreationResults","graph","jobs","errors","result","concat","boolean","compilationJobs","force","neededCompilationJobs","filter","job","needsCompilation","jobsFilteredOutCount","quiet","console","artifactsEmittedPerJob","default","pMap","versionList","solcVersion","getSolcConfig","version","semver_1","lt","errors_1","errors_list_1","BUILTIN_TASKS","COMPILE_TASK_UNSUPPORTED_SOLC_VERSION","firstSupportedVersion","push","pMapOptions","concurrency","os_1","cpus","stopOnError","results","compilationJob","compilationJobIndex","artifactsEmittedPerFile","e","aggregate_error_1","isHardhatErrorType","COMPILE_FAILURE","isCompilerDownloaded","compilersCache","downloader","downloader_1","longVersion","platform","desiredPlatform","getCompilerBuild","compilerPath","nativeBinaryFailed","compilerPathResult","getDownloadedCompilerPath","WASM","SOLC","CANT_GET_COMPILER","solcBinaryWorks","checkSolcBinary","solcJsDownloader","forceSolcJs","solcjsCompilerPath","isSolcJs","input","solcJsPath","compiler","compiler_1","output","compile","solcPath","int","solcBuild","taskArgs","severity","errorMessage","_a","formattedMessage","chalk_1","red","warn","yellow","hasConsoleErrors","some","hasCompilationErrors","artifacts","pathToBuildInfo","saveBuildInfo","getResolvedFiles","sourceName","emitsArtifacts","artifactsEmitted","contractName","contractOutput","Object","entries","contracts","_b","artifact","saveArtifactAndDebugFile","compilationJobsCreationErrors","hasErrors","reasons","COMPILATION_JOBS_CREATION_FAILURE","noCompatibleSolc","incompatibleOverridenSolc","directlyImportsIncompatibleFile","indirectlyImportsIncompatibleFile","other","reason","builtin_tasks_1","NO_COMPATIBLE_SOLC_VERSION_FOUND","INCOMPATIBLE_OVERRIDEN_SOLC_VERSION","DIRECTLY_IMPORTS_INCOMPATIBLE_FILE","INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE","OTHER_ERROR","versionPragmas","versionsRange","incompatibleDirectImportsFiles","extra","incompatibleDirectImports","x","directImportsText","otherImportsCount","incompatibleIndirectImports","_c","_d","incompatibleImports","dependency","path","dependencyPath","dependencyPathText","indirectImportsText","count","solidityFilesCachePath","solidity_files_cache_1","readFromFile","invalidateCacheMissingArtifacts","compilationJobsCreationResult","filteredCompilationJobs","mergedCompilationJobs","addFile","lastModificationDate","valueOf","contentHash","solcConfig","imports","allArtifactsEmittedPerFile","getEntries","artifactsImpl","addValidArtifacts","writeToFile","removeObsoleteArtifacts","addFlag","compilationArgs","compilationTasks","compilationTask","cacheEntry","getEntry","emittedArtifacts","emittedArtifact","artifactExists","removeEntry","cache","hasChanged","hasFileChanged","resolve","process","on","code","getFormattedInternalCompilerErrorMessage","trim","replace"],"sources":["/Users/jake/workspace/token-builder/node_modules/hardhat/src/builtin-tasks/compile.ts"],"sourcesContent":["import os from \"os\";\nimport chalk from \"chalk\";\nimport { exec } from \"child_process\";\nimport debug from \"debug\";\nimport fsExtra from \"fs-extra\";\nimport path from \"path\";\nimport semver from \"semver\";\nimport AggregateError from \"aggregate-error\";\n\nimport {\n  Artifacts as ArtifactsImpl,\n  getArtifactFromContractOutput,\n} from \"../internal/artifacts\";\nimport { subtask, task, types } from \"../internal/core/config/config-env\";\nimport { assertHardhatInvariant, HardhatError } from \"../internal/core/errors\";\nimport { ERRORS } from \"../internal/core/errors-list\";\nimport {\n  createCompilationJobFromFile,\n  createCompilationJobsFromConnectedComponent,\n  mergeCompilationJobsWithoutBug,\n} from \"../internal/solidity/compilation-job\";\nimport { Compiler, NativeCompiler } from \"../internal/solidity/compiler\";\nimport { getInputFromCompilationJob } from \"../internal/solidity/compiler/compiler-input\";\nimport {\n  CompilerDownloader,\n  CompilerPlatform,\n} from \"../internal/solidity/compiler/downloader\";\nimport { DependencyGraph } from \"../internal/solidity/dependencyGraph\";\nimport { Parser } from \"../internal/solidity/parse\";\nimport { ResolvedFile, Resolver } from \"../internal/solidity/resolver\";\nimport { glob } from \"../internal/util/glob\";\nimport { getCompilersDir } from \"../internal/util/global-dir\";\nimport { pluralize } from \"../internal/util/strings\";\nimport { Artifacts, CompilerInput, CompilerOutput, SolcBuild } from \"../types\";\nimport * as taskTypes from \"../types/builtin-tasks\";\nimport {\n  CompilationJob,\n  CompilationJobCreationError,\n  CompilationJobCreationErrorReason,\n  CompilationJobsCreationResult,\n} from \"../types/builtin-tasks\";\nimport { getFullyQualifiedName } from \"../utils/contract-names\";\nimport { localPathToSourceName } from \"../utils/source-names\";\n\nimport {\n  TASK_COMPILE,\n  TASK_COMPILE_GET_COMPILATION_TASKS,\n  TASK_COMPILE_SOLIDITY,\n  TASK_COMPILE_SOLIDITY_CHECK_ERRORS,\n  TASK_COMPILE_SOLIDITY_COMPILE,\n  TASK_COMPILE_SOLIDITY_COMPILE_JOB,\n  TASK_COMPILE_SOLIDITY_COMPILE_JOBS,\n  TASK_COMPILE_SOLIDITY_COMPILE_SOLC,\n  TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS,\n  TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS,\n  TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT,\n  TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE,\n  TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS,\n  TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS,\n  TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT,\n  TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH,\n  TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD,\n  TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES,\n  TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS,\n  TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES,\n  TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS,\n  TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT,\n  TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END,\n  TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START,\n  TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE,\n  TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END,\n  TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START,\n  TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS,\n  TASK_COMPILE_SOLIDITY_READ_FILE,\n  TASK_COMPILE_SOLIDITY_RUN_SOLC,\n  TASK_COMPILE_SOLIDITY_RUN_SOLCJS,\n  TASK_COMPILE_REMOVE_OBSOLETE_ARTIFACTS,\n} from \"./task-names\";\nimport {\n  getSolidityFilesCachePath,\n  SolidityFilesCache,\n} from \"./utils/solidity-files-cache\";\n\ntype ArtifactsEmittedPerFile = Array<{\n  file: taskTypes.ResolvedFile;\n  artifactsEmitted: string[];\n}>;\n\ntype ArtifactsEmittedPerJob = Array<{\n  compilationJob: CompilationJob;\n  artifactsEmittedPerFile: ArtifactsEmittedPerFile;\n}>;\n\nfunction isConsoleLogError(error: any): boolean {\n  return (\n    error.type === \"TypeError\" &&\n    typeof error.message === \"string\" &&\n    error.message.includes(\"log\") &&\n    error.message.includes(\"type(library console)\")\n  );\n}\n\nconst log = debug(\"hardhat:core:tasks:compile\");\n\nconst COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED = \"0.4.11\";\n\n/**\n * Returns a list of absolute paths to all the solidity files in the project.\n * This list doesn't include dependencies, for example solidity files inside\n * node_modules.\n *\n * This is the right task to override to change how the solidity files of the\n * project are obtained.\n */\nsubtask(\n  TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS,\n  async (_, { config }): Promise<string[]> => {\n    const paths = await glob(path.join(config.paths.sources, \"**/*.sol\"));\n\n    return paths;\n  }\n);\n\n/**\n * Receives a list of absolute paths and returns a list of source names\n * corresponding to each path. For example, receives\n * [\"/home/user/project/contracts/Foo.sol\"] and returns\n * [\"contracts/Foo.sol\"]. These source names will be used when the solc input\n * is generated.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES)\n  .addParam(\"sourcePaths\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      { sourcePaths }: { sourcePaths: string[] },\n      { config }\n    ): Promise<string[]> => {\n      const sourceNames = await Promise.all(\n        sourcePaths.map((p) => localPathToSourceName(config.paths.root, p))\n      );\n\n      return sourceNames;\n    }\n  );\n\nsubtask(TASK_COMPILE_SOLIDITY_READ_FILE)\n  .addParam(\"absolutePath\", undefined, undefined, types.string)\n  .setAction(\n    async ({ absolutePath }: { absolutePath: string }): Promise<string> => {\n      const content = await fsExtra.readFile(absolutePath, {\n        encoding: \"utf8\",\n      });\n\n      return content;\n    }\n  );\n\n/**\n * Receives a list of source names and returns a dependency graph. This task\n * is responsible for both resolving dependencies (like getting files from\n * node_modules) and generating the graph.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH)\n  .addParam(\"sourceNames\", undefined, undefined, types.any)\n  .addOptionalParam(\"solidityFilesCache\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      {\n        sourceNames,\n        solidityFilesCache,\n      }: { sourceNames: string[]; solidityFilesCache?: SolidityFilesCache },\n      { config, run }\n    ): Promise<taskTypes.DependencyGraph> => {\n      const parser = new Parser(solidityFilesCache);\n      const resolver = new Resolver(\n        config.paths.root,\n        parser,\n        (absolutePath: string) =>\n          run(TASK_COMPILE_SOLIDITY_READ_FILE, { absolutePath })\n      );\n\n      const resolvedFiles = await Promise.all(\n        sourceNames.map((sn) => resolver.resolveSourceName(sn))\n      );\n      const dependencyGraph = await DependencyGraph.createFromResolvedFiles(\n        resolver,\n        resolvedFiles\n      );\n\n      return dependencyGraph;\n    }\n  );\n\n/**\n * Receives a dependency graph and a file in it, and returns the compilation\n * job for that file. The compilation job should have everything that is\n * necessary to compile that file: a compiler config to be used and a list of\n * files to use as input of the compilation.\n *\n * If the file cannot be compiled, a MatchingCompilerFailure should be\n * returned instead.\n *\n * This is the right task to override to change the compiler configuration.\n * For example, if you want to change the compiler settings when targetting\n * rinkeby, you could do something like this:\n *\n *   const compilationJob = await runSuper();\n *   if (config.network.name === 'rinkeby') {\n *     compilationJob.solidityConfig.settings = newSettings;\n *   }\n *   return compilationJob;\n *\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE)\n  .addParam(\"dependencyGraph\", undefined, undefined, types.any)\n  .addParam(\"file\", undefined, undefined, types.any)\n  .addOptionalParam(\"solidityFilesCache\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      {\n        dependencyGraph,\n        file,\n      }: {\n        dependencyGraph: taskTypes.DependencyGraph;\n        file: taskTypes.ResolvedFile;\n        solidityFilesCache?: SolidityFilesCache;\n      },\n      { config }\n    ): Promise<CompilationJob | CompilationJobCreationError> => {\n      return createCompilationJobFromFile(\n        dependencyGraph,\n        file,\n        config.solidity\n      );\n    }\n  );\n\n/**\n * Receives a dependency graph and returns a tuple with two arrays. The first\n * array is a list of CompilationJobsSuccess, where each item has a list of\n * compilation jobs. The second array is a list of CompilationJobsFailure,\n * where each item has a list of files that couldn't be compiled, grouped by\n * the reason for the failure.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS)\n  .addParam(\"dependencyGraph\", undefined, undefined, types.any)\n  .addOptionalParam(\"solidityFilesCache\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      {\n        dependencyGraph,\n        solidityFilesCache,\n      }: {\n        dependencyGraph: taskTypes.DependencyGraph;\n        solidityFilesCache?: SolidityFilesCache;\n      },\n      { run }\n    ): Promise<CompilationJobsCreationResult> => {\n      const connectedComponents = dependencyGraph.getConnectedComponents();\n\n      log(\n        `The dependency graph was divided in '${connectedComponents.length}' connected components`\n      );\n\n      const compilationJobsCreationResults = await Promise.all(\n        connectedComponents.map((graph) =>\n          createCompilationJobsFromConnectedComponent(\n            graph,\n            (file: taskTypes.ResolvedFile) =>\n              run(TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE, {\n                file,\n                dependencyGraph,\n                solidityFilesCache,\n              })\n          )\n        )\n      );\n\n      let jobs: CompilationJob[] = [];\n      let errors: CompilationJobCreationError[] = [];\n\n      for (const result of compilationJobsCreationResults) {\n        jobs = jobs.concat(result.jobs);\n        errors = errors.concat(result.errors);\n      }\n\n      return { jobs, errors };\n    }\n  );\n\n/**\n * Receives a list of compilation jobs and returns a new list where some of\n * the compilation jobs might've been removed.\n *\n * This task can be overriden to change the way the cache is used, or to use\n * a different approach to filtering out compilation jobs.\n */\nsubtask(TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"force\", undefined, undefined, types.boolean)\n  .addOptionalParam(\"solidityFilesCache\", undefined, undefined, types.any)\n  .setAction(\n    async ({\n      compilationJobs,\n      force,\n      solidityFilesCache,\n    }: {\n      compilationJobs: CompilationJob[];\n      force: boolean;\n      solidityFilesCache?: SolidityFilesCache;\n    }): Promise<CompilationJob[]> => {\n      assertHardhatInvariant(\n        solidityFilesCache !== undefined,\n        \"The implementation of this task needs a defined solidityFilesCache\"\n      );\n\n      if (force) {\n        log(`force flag enabled, not filtering`);\n        return compilationJobs;\n      }\n\n      const neededCompilationJobs = compilationJobs.filter((job) =>\n        needsCompilation(job, solidityFilesCache)\n      );\n\n      const jobsFilteredOutCount =\n        compilationJobs.length - neededCompilationJobs.length;\n      log(`'${jobsFilteredOutCount}' jobs were filtered out`);\n\n      return neededCompilationJobs;\n    }\n  );\n\n/**\n * Receives a list of compilation jobs and returns a new list where some of\n * the jobs might've been merged.\n */\nsubtask(TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .setAction(\n    async ({\n      compilationJobs,\n    }: {\n      compilationJobs: CompilationJob[];\n    }): Promise<CompilationJob[]> => {\n      return mergeCompilationJobsWithoutBug(compilationJobs);\n    }\n  );\n\n/**\n * Prints a message when there's nothing to compile.\n */\nsubtask(TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(async ({ quiet }: { quiet: boolean }) => {\n    if (!quiet) {\n      console.log(\"Nothing to compile\");\n    }\n  });\n\n/**\n * Receives a list of compilation jobs and sends each one to be compiled.\n */\nsubtask(TASK_COMPILE_SOLIDITY_COMPILE_JOBS)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(\n    async (\n      {\n        compilationJobs,\n        quiet,\n      }: {\n        compilationJobs: CompilationJob[];\n        quiet: boolean;\n      },\n      { run }\n    ): Promise<{ artifactsEmittedPerJob: ArtifactsEmittedPerJob }> => {\n      if (compilationJobs.length === 0) {\n        log(`No compilation jobs to compile`);\n        await run(TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE, { quiet });\n        return { artifactsEmittedPerJob: [] };\n      }\n\n      const { default: pMap } = await import(\"p-map\");\n\n      log(`Compiling ${compilationJobs.length} jobs`);\n\n      const versionList: string[] = [];\n      for (const job of compilationJobs) {\n        const solcVersion = job.getSolcConfig().version;\n\n        if (!versionList.includes(solcVersion)) {\n          // versions older than 0.4.11 don't work with hardhat\n          // see issue https://github.com/nomiclabs/hardhat/issues/2004\n          if (\n            semver.lt(solcVersion, COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED)\n          ) {\n            throw new HardhatError(\n              ERRORS.BUILTIN_TASKS.COMPILE_TASK_UNSUPPORTED_SOLC_VERSION,\n              {\n                version: solcVersion,\n                firstSupportedVersion:\n                  COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED,\n              }\n            );\n          }\n\n          versionList.push(solcVersion);\n        }\n      }\n\n      /**\n       * Downloading the same version of a compiler in parallel can cause an\n       * error. When compilation jobs are executed in parallel, there's a chance\n       * that both use the same solc version and trigger this problem. To\n       * prevent that, we pre-download all the necessary compilers before\n       * running the compilation jobs.\n       */\n      for (const solcVersion of versionList) {\n        await run(TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD, {\n          solcVersion,\n          quiet: false,\n        });\n      }\n\n      const pMapOptions = { concurrency: os.cpus().length, stopOnError: false };\n      try {\n        const results = await pMap(\n          compilationJobs,\n          (compilationJob, compilationJobIndex) => {\n            return run(TASK_COMPILE_SOLIDITY_COMPILE_JOB, {\n              compilationJob,\n              compilationJobs,\n              compilationJobIndex,\n              quiet,\n            });\n          },\n          pMapOptions\n        );\n\n        const artifactsEmittedPerJob: ArtifactsEmittedPerJob = results.map(\n          ({ compilationJob, artifactsEmittedPerFile }) => ({\n            compilationJob,\n            artifactsEmittedPerFile,\n          })\n        );\n\n        return { artifactsEmittedPerJob };\n      } catch (e) {\n        if (!(e instanceof AggregateError)) {\n          // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n          throw e;\n        }\n\n        for (const error of e) {\n          if (\n            !HardhatError.isHardhatErrorType(\n              error,\n              ERRORS.BUILTIN_TASKS.COMPILE_FAILURE\n            )\n          ) {\n            // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n            throw error;\n          }\n        }\n\n        // error is an aggregate error, and all errors are compilation failures\n        throw new HardhatError(ERRORS.BUILTIN_TASKS.COMPILE_FAILURE);\n      }\n    }\n  );\n\n/**\n * Receives a compilation job and returns a CompilerInput.\n *\n * It's not recommended to override this task to modify the solc\n * configuration, override\n * TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE instead.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT)\n  .addParam(\"compilationJob\", undefined, undefined, types.any)\n  .setAction(\n    async ({\n      compilationJob,\n    }: {\n      compilationJob: CompilationJob;\n    }): Promise<CompilerInput> => {\n      return getInputFromCompilationJob(compilationJob);\n    }\n  );\n\nsubtask(TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START)\n  .addParam(\"isCompilerDownloaded\", undefined, undefined, types.boolean)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .addParam(\"solcVersion\", undefined, undefined, types.string)\n  .setAction(\n    async ({\n      isCompilerDownloaded,\n      solcVersion,\n    }: {\n      isCompilerDownloaded: boolean;\n      quiet: boolean;\n      solcVersion: string;\n    }) => {\n      if (isCompilerDownloaded) {\n        return;\n      }\n\n      console.log(`Downloading compiler ${solcVersion}`);\n    }\n  );\n\nsubtask(TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END)\n  .addParam(\"isCompilerDownloaded\", undefined, undefined, types.boolean)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .addParam(\"solcVersion\", undefined, undefined, types.string)\n  .setAction(\n    async ({}: {\n      isCompilerDownloaded: boolean;\n      quiet: boolean;\n      solcVersion: string;\n    }) => {}\n  );\n\n/**\n * Receives a solc version and returns a path to a solc binary or to a\n * downloaded solcjs module. It also returns a flag indicating if the returned\n * path corresponds to solc or solcjs.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .addParam(\"solcVersion\", undefined, undefined, types.string)\n  .setAction(\n    async (\n      {\n        quiet,\n        solcVersion,\n      }: {\n        quiet: boolean;\n        solcVersion: string;\n      },\n      { run }\n    ): Promise<SolcBuild> => {\n      const compilersCache = await getCompilersDir();\n      const downloader = new CompilerDownloader(compilersCache);\n\n      const isCompilerDownloaded = await downloader.isCompilerDownloaded(\n        solcVersion\n      );\n\n      const { longVersion, platform: desiredPlatform } =\n        await downloader.getCompilerBuild(solcVersion);\n\n      await run(TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START, {\n        solcVersion,\n        isCompilerDownloaded,\n        quiet,\n      });\n\n      let compilerPath: string | undefined;\n      let platform: CompilerPlatform | undefined;\n      let nativeBinaryFailed = false;\n\n      const compilerPathResult = await downloader.getDownloadedCompilerPath(\n        solcVersion\n      );\n\n      if (compilerPathResult === undefined) {\n        if (desiredPlatform === CompilerPlatform.WASM) {\n          // if we were trying to download solcjs and it failed, there's nothing\n          // we can do\n          throw new HardhatError(ERRORS.SOLC.CANT_GET_COMPILER, {\n            version: solcVersion,\n          });\n        }\n\n        nativeBinaryFailed = true;\n      } else {\n        compilerPath = compilerPathResult.compilerPath;\n\n        // when using a native binary, check that it works correctly\n        // it it doesn't, force the downloader to use solcjs\n        if (compilerPathResult.platform !== CompilerPlatform.WASM) {\n          log(\"Checking native solc binary\");\n\n          const solcBinaryWorks = await checkSolcBinary(\n            compilerPathResult.compilerPath\n          );\n          if (!solcBinaryWorks) {\n            log(\"Native solc binary doesn't work, using solcjs instead\");\n            nativeBinaryFailed = true;\n          }\n        }\n      }\n\n      if (nativeBinaryFailed) {\n        const solcJsDownloader = new CompilerDownloader(compilersCache, {\n          forceSolcJs: true,\n        });\n\n        const solcjsCompilerPath =\n          await solcJsDownloader.getDownloadedCompilerPath(solcVersion);\n\n        if (solcjsCompilerPath === undefined) {\n          throw new HardhatError(ERRORS.SOLC.CANT_GET_COMPILER, {\n            version: solcVersion,\n          });\n        }\n\n        compilerPath = solcjsCompilerPath.compilerPath;\n        platform = CompilerPlatform.WASM;\n      }\n\n      await run(TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END, {\n        solcVersion,\n        isCompilerDownloaded,\n        quiet,\n      });\n\n      const isSolcJs = platform === CompilerPlatform.WASM;\n\n      assertHardhatInvariant(\n        compilerPath !== undefined,\n        \"A compilerPath should be defined at this point\"\n      );\n\n      return { compilerPath, isSolcJs, version: solcVersion, longVersion };\n    }\n  );\n\n/**\n * Receives an absolute path to a solcjs module and the input to be compiled,\n * and returns the generated output\n */\nsubtask(TASK_COMPILE_SOLIDITY_RUN_SOLCJS)\n  .addParam(\"input\", undefined, undefined, types.any)\n  .addParam(\"solcJsPath\", undefined, undefined, types.string)\n  .setAction(\n    async ({\n      input,\n      solcJsPath,\n    }: {\n      input: CompilerInput;\n      solcJsPath: string;\n    }) => {\n      const compiler = new Compiler(solcJsPath);\n\n      const output = await compiler.compile(input);\n\n      return output;\n    }\n  );\n\n/**\n * Receives an absolute path to a solc binary and the input to be compiled,\n * and returns the generated output\n */\nsubtask(TASK_COMPILE_SOLIDITY_RUN_SOLC)\n  .addParam(\"input\", undefined, undefined, types.any)\n  .addParam(\"solcPath\", undefined, undefined, types.string)\n  .setAction(\n    async ({ input, solcPath }: { input: CompilerInput; solcPath: string }) => {\n      const compiler = new NativeCompiler(solcPath);\n\n      const output = await compiler.compile(input);\n\n      return output;\n    }\n  );\n\n/**\n * Receives a CompilerInput and a solc version, compiles the input using a native\n * solc binary or, if that's not possible, using solcjs. Returns the generated\n * output.\n *\n * This task can be overriden to change how solc is obtained or used.\n */\nsubtask(TASK_COMPILE_SOLIDITY_COMPILE_SOLC)\n  .addParam(\"input\", undefined, undefined, types.any)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .addParam(\"solcVersion\", undefined, undefined, types.string)\n  .addParam(\"compilationJob\", undefined, undefined, types.any)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"compilationJobIndex\", undefined, undefined, types.int)\n  .setAction(\n    async (\n      {\n        input,\n        quiet,\n        solcVersion,\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n      }: {\n        input: CompilerInput;\n        quiet: boolean;\n        solcVersion: string;\n        compilationJob: CompilationJob;\n        compilationJobs: CompilationJob[];\n        compilationJobIndex: number;\n      },\n      { run }\n    ): Promise<{ output: CompilerOutput; solcBuild: SolcBuild }> => {\n      const solcBuild: SolcBuild = await run(\n        TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD,\n        {\n          quiet,\n          solcVersion,\n        }\n      );\n\n      await run(TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START, {\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n        quiet,\n      });\n\n      let output;\n      if (solcBuild.isSolcJs) {\n        output = await run(TASK_COMPILE_SOLIDITY_RUN_SOLCJS, {\n          input,\n          solcJsPath: solcBuild.compilerPath,\n        });\n      } else {\n        output = await run(TASK_COMPILE_SOLIDITY_RUN_SOLC, {\n          input,\n          solcPath: solcBuild.compilerPath,\n        });\n      }\n\n      await run(TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END, {\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n        output,\n        quiet,\n      });\n\n      return { output, solcBuild };\n    }\n  );\n\n/**\n * This task is just a proxy to the task that compiles with solc.\n *\n * Override this to use a different task to compile a job.\n */\nsubtask(TASK_COMPILE_SOLIDITY_COMPILE, async (taskArgs: any, { run }) => {\n  return run(TASK_COMPILE_SOLIDITY_COMPILE_SOLC, taskArgs);\n});\n\n/**\n * Receives a compilation output and prints its errors and any other\n * information useful to the user.\n */\nsubtask(TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS)\n  .addParam(\"output\", undefined, undefined, types.any)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(async ({ output }: { output: any; quiet: boolean }) => {\n    if (output?.errors === undefined) {\n      return;\n    }\n\n    for (const error of output.errors) {\n      if (error.severity === \"error\") {\n        const errorMessage =\n          getFormattedInternalCompilerErrorMessage(error) ??\n          error.formattedMessage;\n\n        console.error(chalk.red(errorMessage));\n      } else {\n        console.warn(chalk.yellow(error.formattedMessage));\n      }\n    }\n\n    const hasConsoleErrors = output.errors.some(isConsoleLogError);\n    if (hasConsoleErrors) {\n      console.error(\n        chalk.red(\n          `The console.log call you made isn’t supported. See https://hardhat.org/console-log for the list of supported methods.`\n        )\n      );\n      console.log();\n    }\n  });\n\n/**\n * Receives a solc output and checks if there are errors. Throws if there are\n * errors.\n *\n * Override this task to avoid interrupting the compilation process if some\n * job has compilation errors.\n */\nsubtask(TASK_COMPILE_SOLIDITY_CHECK_ERRORS)\n  .addParam(\"output\", undefined, undefined, types.any)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(\n    async ({ output, quiet }: { output: any; quiet: boolean }, { run }) => {\n      await run(TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS, {\n        output,\n        quiet,\n      });\n\n      if (hasCompilationErrors(output)) {\n        throw new HardhatError(ERRORS.BUILTIN_TASKS.COMPILE_FAILURE);\n      }\n    }\n  );\n\n/**\n * Saves to disk the artifacts for a compilation job. These artifacts\n * include the main artifacts, the debug files, and the build info.\n */\nsubtask(TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS)\n  .addParam(\"compilationJob\", undefined, undefined, types.any)\n  .addParam(\"input\", undefined, undefined, types.any)\n  .addParam(\"output\", undefined, undefined, types.any)\n  .addParam(\"solcBuild\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      {\n        compilationJob,\n        input,\n        output,\n        solcBuild,\n      }: {\n        compilationJob: CompilationJob;\n        input: CompilerInput;\n        output: CompilerOutput;\n        solcBuild: SolcBuild;\n      },\n      { artifacts, run }\n    ): Promise<{\n      artifactsEmittedPerFile: ArtifactsEmittedPerFile;\n    }> => {\n      const pathToBuildInfo = await artifacts.saveBuildInfo(\n        compilationJob.getSolcConfig().version,\n        solcBuild.longVersion,\n        input,\n        output\n      );\n\n      const artifactsEmittedPerFile: ArtifactsEmittedPerFile = [];\n      for (const file of compilationJob.getResolvedFiles()) {\n        log(`Emitting artifacts for file '${file.sourceName}'`);\n        if (!compilationJob.emitsArtifacts(file)) {\n          continue;\n        }\n\n        const artifactsEmitted = [];\n        for (const [contractName, contractOutput] of Object.entries(\n          output.contracts?.[file.sourceName] ?? {}\n        )) {\n          log(`Emitting artifact for contract '${contractName}'`);\n\n          const artifact = await run(\n            TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT,\n            {\n              sourceName: file.sourceName,\n              contractName,\n              contractOutput,\n            }\n          );\n\n          await artifacts.saveArtifactAndDebugFile(artifact, pathToBuildInfo);\n\n          artifactsEmitted.push(artifact.contractName);\n        }\n\n        artifactsEmittedPerFile.push({\n          file,\n          artifactsEmitted,\n        });\n      }\n\n      return { artifactsEmittedPerFile };\n    }\n  );\n\n/**\n * Generates the artifact for contract `contractName` given its compilation\n * output.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT)\n  .addParam(\"sourceName\", undefined, undefined, types.string)\n  .addParam(\"contractName\", undefined, undefined, types.string)\n  .addParam(\"contractOutput\", undefined, undefined, types.any)\n  .setAction(\n    async ({\n      sourceName,\n      contractName,\n      contractOutput,\n    }: {\n      sourceName: string;\n      contractName: string;\n      contractOutput: any;\n    }): Promise<any> => {\n      return getArtifactFromContractOutput(\n        sourceName,\n        contractName,\n        contractOutput\n      );\n    }\n  );\n\n/**\n * Prints a message before running soljs with some input.\n */\nsubtask(TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START)\n  .addParam(\"compilationJob\", undefined, undefined, types.any)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"compilationJobIndex\", undefined, undefined, types.int)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(\n    async ({}: {\n      compilationJob: CompilationJob;\n      compilationJobs: CompilationJob[];\n      compilationJobIndex: number;\n    }) => {}\n  );\n\n/**\n * Prints a message after compiling some input\n */\nsubtask(TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END)\n  .addParam(\"compilationJob\", undefined, undefined, types.any)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"compilationJobIndex\", undefined, undefined, types.int)\n  .addParam(\"output\", undefined, undefined, types.any)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(\n    async ({}: {\n      compilationJob: CompilationJob;\n      compilationJobs: CompilationJob[];\n      compilationJobIndex: number;\n      output: any;\n      quiet: boolean;\n    }) => {}\n  );\n\n/**\n * This is an orchestrator task that uses other subtasks to compile a\n * compilation job.\n */\nsubtask(TASK_COMPILE_SOLIDITY_COMPILE_JOB)\n  .addParam(\"compilationJob\", undefined, undefined, types.any)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"compilationJobIndex\", undefined, undefined, types.int)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .addOptionalParam(\"emitsArtifacts\", undefined, true, types.boolean)\n  .setAction(\n    async (\n      {\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n        quiet,\n        emitsArtifacts,\n      }: {\n        compilationJob: CompilationJob;\n        compilationJobs: CompilationJob[];\n        compilationJobIndex: number;\n        quiet: boolean;\n        emitsArtifacts: boolean;\n      },\n      { run }\n    ): Promise<{\n      artifactsEmittedPerFile: ArtifactsEmittedPerFile;\n      compilationJob: taskTypes.CompilationJob;\n      input: CompilerInput;\n      output: CompilerOutput;\n      solcBuild: any;\n    }> => {\n      log(\n        `Compiling job with version '${compilationJob.getSolcConfig().version}'`\n      );\n      const input: CompilerInput = await run(\n        TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT,\n        {\n          compilationJob,\n        }\n      );\n\n      const { output, solcBuild } = await run(TASK_COMPILE_SOLIDITY_COMPILE, {\n        solcVersion: compilationJob.getSolcConfig().version,\n        input,\n        quiet,\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n      });\n\n      await run(TASK_COMPILE_SOLIDITY_CHECK_ERRORS, { output, quiet });\n\n      let artifactsEmittedPerFile = [];\n      if (emitsArtifacts) {\n        artifactsEmittedPerFile = (\n          await run(TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS, {\n            compilationJob,\n            input,\n            output,\n            solcBuild,\n          })\n        ).artifactsEmittedPerFile;\n      }\n\n      return {\n        artifactsEmittedPerFile,\n        compilationJob,\n        input,\n        output,\n        solcBuild,\n      };\n    }\n  );\n\n/**\n * Receives a list of CompilationJobsFailure and throws an error if it's not\n * empty.\n *\n * This task could be overriden to avoid interrupting the compilation if\n * there's some part of the project that can't be compiled.\n */\nsubtask(TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES)\n  .addParam(\"compilationJobsCreationErrors\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      {\n        compilationJobsCreationErrors,\n      }: {\n        compilationJobsCreationErrors: CompilationJobCreationError[];\n      },\n      { run }\n    ) => {\n      const hasErrors = compilationJobsCreationErrors.length > 0;\n\n      if (hasErrors) {\n        log(`There were errors creating the compilation jobs, throwing`);\n        const reasons: string = await run(\n          TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS,\n          { compilationJobsCreationErrors }\n        );\n\n        throw new HardhatError(\n          ERRORS.BUILTIN_TASKS.COMPILATION_JOBS_CREATION_FAILURE,\n          {\n            reasons,\n          }\n        );\n      }\n    }\n  );\n\n/**\n * Receives a list of CompilationJobsFailure and returns an error message\n * that describes the failure.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS)\n  .addParam(\"compilationJobsCreationErrors\", undefined, undefined, types.any)\n  .setAction(\n    async ({\n      compilationJobsCreationErrors: errors,\n    }: {\n      compilationJobsCreationErrors: CompilationJobCreationError[];\n    }): Promise<string> => {\n      const noCompatibleSolc: CompilationJobCreationError[] = [];\n      const incompatibleOverridenSolc: CompilationJobCreationError[] = [];\n      const directlyImportsIncompatibleFile: CompilationJobCreationError[] = [];\n      const indirectlyImportsIncompatibleFile: CompilationJobCreationError[] =\n        [];\n      const other: CompilationJobCreationError[] = [];\n\n      for (const error of errors) {\n        if (\n          error.reason ===\n          CompilationJobCreationErrorReason.NO_COMPATIBLE_SOLC_VERSION_FOUND\n        ) {\n          noCompatibleSolc.push(error);\n        } else if (\n          error.reason ===\n          CompilationJobCreationErrorReason.INCOMPATIBLE_OVERRIDEN_SOLC_VERSION\n        ) {\n          incompatibleOverridenSolc.push(error);\n        } else if (\n          error.reason ===\n          CompilationJobCreationErrorReason.DIRECTLY_IMPORTS_INCOMPATIBLE_FILE\n        ) {\n          directlyImportsIncompatibleFile.push(error);\n        } else if (\n          error.reason ===\n          CompilationJobCreationErrorReason.INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE\n        ) {\n          indirectlyImportsIncompatibleFile.push(error);\n        } else if (\n          error.reason === CompilationJobCreationErrorReason.OTHER_ERROR\n        ) {\n          other.push(error);\n        } else {\n          // add unrecognized errors to `other`\n          other.push(error);\n        }\n      }\n\n      let errorMessage = \"\";\n      if (incompatibleOverridenSolc.length > 0) {\n        errorMessage += `The compiler version for the following files is fixed through an override in your config file to a version that is incompatible with their Solidity version pragmas.\n\n`;\n\n        for (const error of incompatibleOverridenSolc) {\n          const { sourceName } = error.file;\n          const { versionPragmas } = error.file.content;\n          const versionsRange = versionPragmas.join(\" \");\n\n          log(`File ${sourceName} has an incompatible overriden compiler`);\n\n          errorMessage += `  * ${sourceName} (${versionsRange})\\n`;\n        }\n\n        errorMessage += \"\\n\";\n      }\n\n      if (noCompatibleSolc.length > 0) {\n        errorMessage += `The Solidity version pragma statement in these files doesn't match any of the configured compilers in your config. Change the pragma or configure additional compiler versions in your hardhat config.\n\n`;\n\n        for (const error of noCompatibleSolc) {\n          const { sourceName } = error.file;\n          const { versionPragmas } = error.file.content;\n          const versionsRange = versionPragmas.join(\" \");\n\n          log(\n            `File ${sourceName} doesn't match any of the configured compilers`\n          );\n\n          errorMessage += `  * ${sourceName} (${versionsRange})\\n`;\n        }\n\n        errorMessage += \"\\n\";\n      }\n\n      if (directlyImportsIncompatibleFile.length > 0) {\n        errorMessage += `These files import other files that use a different and incompatible version of Solidity:\n\n`;\n\n        for (const error of directlyImportsIncompatibleFile) {\n          const { sourceName } = error.file;\n          const { versionPragmas } = error.file.content;\n          const versionsRange = versionPragmas.join(\" \");\n\n          const incompatibleDirectImportsFiles: ResolvedFile[] =\n            error.extra?.incompatibleDirectImports ?? [];\n\n          const incompatibleDirectImports = incompatibleDirectImportsFiles.map(\n            (x: ResolvedFile) =>\n              `${x.sourceName} (${x.content.versionPragmas.join(\" \")})`\n          );\n\n          log(\n            `File ${sourceName} imports files ${incompatibleDirectImportsFiles\n              .map((x) => x.sourceName)\n              .join(\", \")} that use an incompatible version of Solidity`\n          );\n\n          let directImportsText = \"\";\n          if (incompatibleDirectImports.length === 1) {\n            directImportsText = ` imports ${incompatibleDirectImports[0]}`;\n          } else if (incompatibleDirectImports.length === 2) {\n            directImportsText = ` imports ${incompatibleDirectImports[0]} and ${incompatibleDirectImports[1]}`;\n          } else if (incompatibleDirectImports.length > 2) {\n            const otherImportsCount = incompatibleDirectImports.length - 2;\n            directImportsText = ` imports ${incompatibleDirectImports[0]}, ${\n              incompatibleDirectImports[1]\n            } and ${otherImportsCount} other ${pluralize(\n              otherImportsCount,\n              \"file\"\n            )}. Use --verbose to see the full list.`;\n          }\n\n          errorMessage += `  * ${sourceName} (${versionsRange})${directImportsText}\\n`;\n        }\n\n        errorMessage += \"\\n\";\n      }\n\n      if (indirectlyImportsIncompatibleFile.length > 0) {\n        errorMessage += `These files depend on other files that use a different and incompatible version of Solidity:\n\n`;\n\n        for (const error of indirectlyImportsIncompatibleFile) {\n          const { sourceName } = error.file;\n          const { versionPragmas } = error.file.content;\n          const versionsRange = versionPragmas.join(\" \");\n\n          const incompatibleIndirectImports: taskTypes.TransitiveDependency[] =\n            error.extra?.incompatibleIndirectImports ?? [];\n\n          const incompatibleImports = incompatibleIndirectImports.map(\n            ({ dependency }) =>\n              `${\n                dependency.sourceName\n              } (${dependency.content.versionPragmas.join(\" \")})`\n          );\n\n          for (const {\n            dependency,\n            path: dependencyPath,\n          } of incompatibleIndirectImports) {\n            const dependencyPathText = [\n              sourceName,\n              ...dependencyPath.map((x) => x.sourceName),\n              dependency.sourceName,\n            ].join(\" -> \");\n\n            log(\n              `File ${sourceName} depends on file ${dependency.sourceName} that uses an incompatible version of Solidity\nThe dependency path is ${dependencyPathText}\n`\n            );\n          }\n\n          let indirectImportsText = \"\";\n          if (incompatibleImports.length === 1) {\n            indirectImportsText = ` depends on ${incompatibleImports[0]}`;\n          } else if (incompatibleImports.length === 2) {\n            indirectImportsText = ` depends on ${incompatibleImports[0]} and ${incompatibleImports[1]}`;\n          } else if (incompatibleImports.length > 2) {\n            const otherImportsCount = incompatibleImports.length - 2;\n            indirectImportsText = ` depends on ${incompatibleImports[0]}, ${\n              incompatibleImports[1]\n            } and ${otherImportsCount} other ${pluralize(\n              otherImportsCount,\n              \"file\"\n            )}. Use --verbose to see the full list.`;\n          }\n\n          errorMessage += `  * ${sourceName} (${versionsRange})${indirectImportsText}\\n`;\n        }\n\n        errorMessage += \"\\n\";\n      }\n\n      if (other.length > 0) {\n        errorMessage += `These files and its dependencies cannot be compiled with your config. This can happen because they have incompatible Solidity pragmas, or don't match any of your configured Solidity compilers.\n\n${other.map((x) => `  * ${x.file.sourceName}`).join(\"\\n\")}\n\n`;\n      }\n\n      errorMessage += `To learn more, run the command again with --verbose\n\nRead about compiler configuration at https://hardhat.org/config\n`;\n\n      return errorMessage;\n    }\n  );\n\nsubtask(TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(\n    async ({ compilationJobs }: { compilationJobs: CompilationJob[] }) => {\n      let count = 0;\n      for (const job of compilationJobs) {\n        count += job\n          .getResolvedFiles()\n          .filter((file) => job.emitsArtifacts(file)).length;\n      }\n\n      if (count > 0) {\n        console.log(\n          `Compiled ${count} Solidity ${pluralize(count, \"file\")} successfully`\n        );\n      }\n    }\n  );\n\n/**\n * Main task for compiling the solidity files in the project.\n *\n * The main responsibility of this task is to orchestrate and connect most of\n * the subtasks related to compiling solidity.\n */\nsubtask(TASK_COMPILE_SOLIDITY)\n  .addParam(\"force\", undefined, undefined, types.boolean)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(\n    async (\n      { force, quiet }: { force: boolean; quiet: boolean },\n      { artifacts, config, run }\n    ) => {\n      const sourcePaths: string[] = await run(\n        TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS\n      );\n\n      const sourceNames: string[] = await run(\n        TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES,\n        {\n          sourcePaths,\n        }\n      );\n\n      const solidityFilesCachePath = getSolidityFilesCachePath(config.paths);\n      let solidityFilesCache = await SolidityFilesCache.readFromFile(\n        solidityFilesCachePath\n      );\n\n      const dependencyGraph: taskTypes.DependencyGraph = await run(\n        TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH,\n        { sourceNames, solidityFilesCache }\n      );\n\n      solidityFilesCache = await invalidateCacheMissingArtifacts(\n        solidityFilesCache,\n        artifacts,\n        dependencyGraph.getResolvedFiles()\n      );\n\n      const compilationJobsCreationResult: CompilationJobsCreationResult =\n        await run(TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS, {\n          dependencyGraph,\n          solidityFilesCache,\n        });\n\n      await run(TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES, {\n        compilationJobsCreationErrors: compilationJobsCreationResult.errors,\n      });\n\n      const compilationJobs = compilationJobsCreationResult.jobs;\n\n      const filteredCompilationJobs: CompilationJob[] = await run(\n        TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS,\n        { compilationJobs, force, solidityFilesCache }\n      );\n\n      const mergedCompilationJobs: CompilationJob[] = await run(\n        TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS,\n        { compilationJobs: filteredCompilationJobs }\n      );\n\n      const {\n        artifactsEmittedPerJob,\n      }: { artifactsEmittedPerJob: ArtifactsEmittedPerJob } = await run(\n        TASK_COMPILE_SOLIDITY_COMPILE_JOBS,\n        {\n          compilationJobs: mergedCompilationJobs,\n          quiet,\n        }\n      );\n\n      // update cache using the information about the emitted artifacts\n      for (const {\n        compilationJob: compilationJob,\n        artifactsEmittedPerFile: artifactsEmittedPerFile,\n      } of artifactsEmittedPerJob) {\n        for (const { file, artifactsEmitted } of artifactsEmittedPerFile) {\n          solidityFilesCache.addFile(file.absolutePath, {\n            lastModificationDate: file.lastModificationDate.valueOf(),\n            contentHash: file.contentHash,\n            sourceName: file.sourceName,\n            solcConfig: compilationJob.getSolcConfig(),\n            imports: file.content.imports,\n            versionPragmas: file.content.versionPragmas,\n            artifacts: artifactsEmitted,\n          });\n        }\n      }\n\n      const allArtifactsEmittedPerFile = solidityFilesCache.getEntries();\n\n      // We know this is the actual implementation, so we use some\n      // non-public methods here.\n      const artifactsImpl = artifacts as ArtifactsImpl;\n      artifactsImpl.addValidArtifacts(allArtifactsEmittedPerFile);\n\n      await solidityFilesCache.writeToFile(solidityFilesCachePath);\n\n      await run(TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT, {\n        compilationJobs: mergedCompilationJobs,\n        quiet,\n      });\n    }\n  );\n\nsubtask(TASK_COMPILE_REMOVE_OBSOLETE_ARTIFACTS, async (_, { artifacts }) => {\n  // We know this is the actual implementation, so we use some\n  // non-public methods here.\n  const artifactsImpl = artifacts as ArtifactsImpl;\n  await artifactsImpl.removeObsoleteArtifacts();\n});\n\n/**\n * Returns a list of compilation tasks.\n *\n * This is the task to override to add support for other languages.\n */\nsubtask(TASK_COMPILE_GET_COMPILATION_TASKS, async (): Promise<string[]> => {\n  return [TASK_COMPILE_SOLIDITY];\n});\n\n/**\n * Main compile task.\n *\n * This is a meta-task that just gets all the compilation tasks and runs them.\n * Right now there's only a \"compile solidity\" task.\n */\ntask(TASK_COMPILE, \"Compiles the entire project, building all artifacts\")\n  .addFlag(\"force\", \"Force compilation ignoring cache\")\n  .addFlag(\"quiet\", \"Makes the compilation process less verbose\")\n  .setAction(async (compilationArgs: any, { run }) => {\n    const compilationTasks: string[] = await run(\n      TASK_COMPILE_GET_COMPILATION_TASKS\n    );\n\n    for (const compilationTask of compilationTasks) {\n      await run(compilationTask, compilationArgs);\n    }\n\n    await run(TASK_COMPILE_REMOVE_OBSOLETE_ARTIFACTS);\n  });\n\n/**\n * If a file is present in the cache, but some of its artifacts are missing on\n * disk, we remove it from the cache to force it to be recompiled.\n */\nasync function invalidateCacheMissingArtifacts(\n  solidityFilesCache: SolidityFilesCache,\n  artifacts: Artifacts,\n  resolvedFiles: ResolvedFile[]\n): Promise<SolidityFilesCache> {\n  for (const file of resolvedFiles) {\n    const cacheEntry = solidityFilesCache.getEntry(file.absolutePath);\n\n    if (cacheEntry === undefined) {\n      continue;\n    }\n\n    const { artifacts: emittedArtifacts } = cacheEntry;\n\n    for (const emittedArtifact of emittedArtifacts) {\n      const artifactExists = await artifacts.artifactExists(\n        getFullyQualifiedName(file.sourceName, emittedArtifact)\n      );\n      if (!artifactExists) {\n        log(\n          `Invalidate cache for '${file.absolutePath}' because artifact '${emittedArtifact}' doesn't exist`\n        );\n        solidityFilesCache.removeEntry(file.absolutePath);\n        break;\n      }\n    }\n  }\n\n  return solidityFilesCache;\n}\n\n/**\n * Checks if the given compilation job needs to be done.\n */\nfunction needsCompilation(\n  job: taskTypes.CompilationJob,\n  cache: SolidityFilesCache\n): boolean {\n  for (const file of job.getResolvedFiles()) {\n    const hasChanged = cache.hasFileChanged(\n      file.absolutePath,\n      file.contentHash,\n      // we only check if the solcConfig is different for files that\n      // emit artifacts\n      job.emitsArtifacts(file) ? job.getSolcConfig() : undefined\n    );\n\n    if (hasChanged) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction hasCompilationErrors(output: any): boolean {\n  return (\n    output.errors && output.errors.some((x: any) => x.severity === \"error\")\n  );\n}\n\nasync function checkSolcBinary(solcPath: string): Promise<boolean> {\n  return new Promise((resolve) => {\n    const process = exec(`${solcPath} --version`);\n    process.on(\"exit\", (code) => {\n      resolve(code === 0);\n    });\n  });\n}\n\n/**\n * This function returns a properly formatted Internal Compiler Error message.\n *\n * This is present due to a bug in Solidity. See: https://github.com/ethereum/solidity/issues/9926\n *\n * If the error is not an ICE, or if it's properly formatted, this function returns undefined.\n */\nfunction getFormattedInternalCompilerErrorMessage(error: {\n  formattedMessage: string;\n  message: string;\n  type: string;\n}): string | undefined {\n  if (error.formattedMessage.trim() !== \"InternalCompilerError:\") {\n    return;\n  }\n\n  // We trim any final `:`, as we found some at the end of the error messages,\n  // and then trim just in case a blank space was left\n  return `${error.type}: ${error.message}`.replace(/[:\\s]*$/g, \"\").trim();\n}\n"]},"metadata":{},"sourceType":"script"}