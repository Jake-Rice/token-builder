{"ast":null,"code":"'use strict';\n\nconst util = require('../core/util');\n\nconst {\n  ReadableStreamFrom,\n  toUSVString,\n  isBlobLike\n} = require('./util');\n\nconst {\n  FormData\n} = require('./formdata');\n\nconst {\n  kState\n} = require('./symbols');\n\nconst {\n  Blob\n} = require('buffer');\n\nconst {\n  kBodyUsed\n} = require('../core/symbols');\n\nconst assert = require('assert');\n\nconst {\n  NotSupportedError\n} = require('../core/errors');\n\nconst {\n  isErrored\n} = require('../core/util');\n\nconst {\n  isUint8Array\n} = require('util/types');\n\nlet ReadableStream;\n\nasync function* blobGen(blob) {\n  if (blob.stream) {\n    yield* blob.stream();\n  } else {\n    // istanbul ignore next: node < 16.7\n    yield await blob.arrayBuffer();\n  }\n} // https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n\n\nfunction extractBody(object) {\n  let keepalive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream;\n  } // 1. Let stream be object if object is a ReadableStream object.\n  // Otherwise, let stream be a new ReadableStream, and set up stream.\n\n\n  let stream = null; // 2. Let action be null.\n\n  let action = null; // 3. Let source be null.\n\n  let source = null; // 4. Let length be null.\n\n  let length = null; // 5. Let Content-Type be null.\n\n  let contentType = null; // 6. Switch on object:\n\n  if (object == null) {// Note: The IDL processor cannot handle this situation. See\n    // https://crbug.com/335871.\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString(); // Set Content-Type to `application/x-www-form-urlencoded;charset=UTF-8`.\n\n    contentType = 'application/x-www-form-urlencoded;charset=UTF-8';\n  } else if (object instanceof ArrayBuffer || ArrayBuffer.isView(object)) {\n    // BufferSource\n    if (object instanceof DataView) {\n      // TODO: Blob doesn't seem to work with DataView?\n      object = object.buffer;\n    } // Set source to a copy of the bytes held by object.\n\n\n    source = new Uint8Array(object);\n  } else if (object instanceof FormData) {\n    const boundary = '----formdata-undici-' + Math.random();\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`;\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n\n    const escape = str => str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22');\n\n    const normalizeLinefeeds = value => value.replace(/\\r?\\n|\\r/g, '\\r\\n'); // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n\n\n    action = async function* (object) {\n      const enc = new TextEncoder();\n\n      for (const [name, value] of object) {\n        if (typeof value === 'string') {\n          yield enc.encode(prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`);\n        } else {\n          yield enc.encode(prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + (value.name ? `; filename=\"${escape(value.name)}\"` : '') + '\\r\\n' + `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`);\n          yield* blobGen(value);\n          yield enc.encode('\\r\\n');\n        }\n      }\n\n      yield enc.encode(`--${boundary}--`);\n    }; // Set source to object.\n\n\n    source = object; // Set length to unclear, see html/6424 for improving this.\n    // TODO\n    // Set Content-Type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n\n    contentType = 'multipart/form-data; boundary=' + boundary;\n  } else if (isBlobLike(object)) {\n    // Blob\n    // Set action to this step: read object.\n    action = blobGen; // Set source to object.\n\n    source = object; // Set length to object’s size.\n\n    length = object.size; // If object’s type attribute is not the empty byte sequence, set\n    // Content-Type to its value.\n\n    if (object.type) {\n      contentType = object.type;\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive');\n    } // If object is disturbed or locked, then throw a TypeError.\n\n\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError('Response body object should not be disturbed or locked');\n    }\n\n    stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);\n  } else {\n    // TODO: byte sequence?\n    // TODO: scalar value string?\n    // TODO: else?\n    source = toUSVString(object);\n    contentType = 'text/plain;charset=UTF-8';\n  } // 7. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  // TODO: What is a \"byte sequence?\"\n\n\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source);\n  } // 8. If action is non-null, then run these steps in in parallel:\n\n\n  if (action != null) {\n    // Run action.\n    let iterator;\n    stream = new ReadableStream({\n      async start() {\n        iterator = action(object)[Symbol.asyncIterator]();\n      },\n\n      async pull(controller) {\n        const {\n          value,\n          done\n        } = await iterator.next();\n\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close();\n          });\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            controller.enqueue(new Uint8Array(value));\n          }\n        }\n\n        return controller.desiredSize > 0;\n      },\n\n      async cancel(reason) {\n        await iterator.return();\n      }\n\n    });\n  } else if (!stream) {\n    // TODO: Spec doesn't say anything about this?\n    stream = new ReadableStream({\n      async pull(controller) {\n        controller.enqueue(typeof source === 'string' ? new TextEncoder().encode(source) : source);\n        queueMicrotask(() => {\n          controller.close();\n        });\n      }\n\n    });\n  } // 9. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n\n\n  const body = {\n    stream,\n    source,\n    length\n  }; // 10. Return body and Content-Type.\n\n  return [body, contentType];\n} // https://fetch.spec.whatwg.org/#bodyinit-safely-extract\n\n\nfunction safelyExtractBody(object) {\n  let keepalive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (!ReadableStream) {\n    // istanbul ignore next\n    ReadableStream = require('stream/web').ReadableStream;\n  } // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n  // 1. If object is a ReadableStream object, then:\n\n\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'disturbed'); // istanbul ignore next\n\n    assert(!object.locked, 'locked');\n  } // 2. Return the results of extracting object.\n\n\n  return extractBody(object, keepalive);\n}\n\nfunction cloneBody(body) {\n  // To clone a body body, run these steps:\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee(); // 2. Set body’s stream to out1.\n\n  body.stream = out1; // 3. Return a body whose stream is out2 and other members are copied from body.\n\n  return {\n    stream: out2,\n    length: body.length,\n    source: body.source\n  };\n}\n\nconst methods = {\n  async blob() {\n    const chunks = [];\n\n    if (this[kState].body) {\n      if (isUint8Array(this[kState].body)) {\n        chunks.push(this[kState].body);\n      } else {\n        const stream = this[kState].body.stream;\n\n        if (util.isDisturbed(stream)) {\n          throw new TypeError('disturbed');\n        }\n\n        if (stream.locked) {\n          throw new TypeError('locked');\n        } // Compat.\n\n\n        stream[kBodyUsed] = true;\n\n        for await (const chunk of stream) {\n          chunks.push(chunk);\n        }\n      }\n    }\n\n    return new Blob(chunks, {\n      type: this.headers.get('Content-Type') || ''\n    });\n  },\n\n  async arrayBuffer() {\n    const blob = await this.blob();\n    return await blob.arrayBuffer();\n  },\n\n  async text() {\n    const blob = await this.blob();\n    return toUSVString(await blob.text());\n  },\n\n  async json() {\n    return JSON.parse(await this.text());\n  },\n\n  async formData() {\n    const contentType = this.headers.get('Content-Type'); // If mimeType’s essence is \"multipart/form-data\", then:\n\n    if (/multipart\\/form-data/.test(contentType)) {\n      throw new NotSupportedError('multipart/form-data not supported');\n    } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n      // Otherwise, if mimeType’s essence is \"application/x-www-form-urlencoded\", then:\n      // 1. Let entries be the result of parsing bytes.\n      let entries;\n\n      try {\n        entries = new URLSearchParams(await this.text());\n      } catch (err) {\n        // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n        // 2. If entries is failure, then throw a TypeError.\n        throw Object.assign(new TypeError(), {\n          cause: err\n        });\n      } // 3. Return a new FormData object whose entries are entries.\n\n\n      const formData = new FormData();\n\n      for (const [name, value] of entries) {\n        formData.append(name, value);\n      }\n\n      return formData;\n    } else {\n      // Otherwise, throw a TypeError.\n      throw new TypeError();\n    }\n  }\n\n};\nconst properties = {\n  body: {\n    enumerable: true,\n\n    get() {\n      return this[kState].body ? this[kState].body.stream : null;\n    }\n\n  },\n  bodyUsed: {\n    enumerable: true,\n\n    get() {\n      return this[kState].body && util.isDisturbed(this[kState].body.stream);\n    }\n\n  }\n};\n\nfunction mixinBody(prototype) {\n  Object.assign(prototype, methods);\n  Object.defineProperties(prototype, properties);\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody\n};","map":{"version":3,"sources":["/Users/jake/workspace/token-builder/node_modules/undici/lib/fetch/body.js"],"names":["util","require","ReadableStreamFrom","toUSVString","isBlobLike","FormData","kState","Blob","kBodyUsed","assert","NotSupportedError","isErrored","isUint8Array","ReadableStream","blobGen","blob","stream","arrayBuffer","extractBody","object","keepalive","action","source","length","contentType","URLSearchParams","toString","ArrayBuffer","isView","DataView","buffer","Uint8Array","boundary","Math","random","prefix","escape","str","replace","normalizeLinefeeds","value","enc","TextEncoder","name","encode","type","size","Symbol","asyncIterator","TypeError","isDisturbed","locked","isBuffer","Buffer","byteLength","iterator","start","pull","controller","done","next","queueMicrotask","close","enqueue","desiredSize","cancel","reason","return","body","safelyExtractBody","cloneBody","out1","out2","tee","methods","chunks","push","chunk","headers","get","text","json","JSON","parse","formData","test","entries","err","Object","assign","cause","append","properties","enumerable","bodyUsed","mixinBody","prototype","defineProperties","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst util = require('../core/util')\nconst { ReadableStreamFrom, toUSVString, isBlobLike } = require('./util')\nconst { FormData } = require('./formdata')\nconst { kState } = require('./symbols')\nconst { Blob } = require('buffer')\nconst { kBodyUsed } = require('../core/symbols')\nconst assert = require('assert')\nconst { NotSupportedError } = require('../core/errors')\nconst { isErrored } = require('../core/util')\nconst { isUint8Array } = require('util/types')\n\nlet ReadableStream\n\nasync function * blobGen (blob) {\n  if (blob.stream) {\n    yield * blob.stream()\n  } else {\n    // istanbul ignore next: node < 16.7\n    yield await blob.arrayBuffer()\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  // 1. Let stream be object if object is a ReadableStream object.\n  // Otherwise, let stream be a new ReadableStream, and set up stream.\n  let stream = null\n\n  // 2. Let action be null.\n  let action = null\n\n  // 3. Let source be null.\n  let source = null\n\n  // 4. Let length be null.\n  let length = null\n\n  // 5. Let Content-Type be null.\n  let contentType = null\n\n  // 6. Switch on object:\n  if (object == null) {\n    // Note: The IDL processor cannot handle this situation. See\n    // https://crbug.com/335871.\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString()\n\n    // Set Content-Type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    contentType = 'application/x-www-form-urlencoded;charset=UTF-8'\n  } else if (object instanceof ArrayBuffer || ArrayBuffer.isView(object)) {\n    // BufferSource\n\n    if (object instanceof DataView) {\n      // TODO: Blob doesn't seem to work with DataView?\n      object = object.buffer\n    }\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object)\n  } else if (object instanceof FormData) {\n    const boundary = '----formdata-undici-' + Math.random()\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`\n\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n    const escape = (str) =>\n      str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22')\n    const normalizeLinefeeds = (value) => value.replace(/\\r?\\n|\\r/g, '\\r\\n')\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n    action = async function * (object) {\n      const enc = new TextEncoder()\n\n      for (const [name, value] of object) {\n        if (typeof value === 'string') {\n          yield enc.encode(\n            prefix +\n              `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n              `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`\n          )\n        } else {\n          yield enc.encode(\n            prefix +\n              `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n              (value.name ? `; filename=\"${escape(value.name)}\"` : '') +\n              '\\r\\n' +\n              `Content-Type: ${\n                value.type || 'application/octet-stream'\n              }\\r\\n\\r\\n`\n          )\n\n          yield * blobGen(value)\n\n          yield enc.encode('\\r\\n')\n        }\n      }\n\n      yield enc.encode(`--${boundary}--`)\n    }\n\n    // Set source to object.\n    source = object\n\n    // Set length to unclear, see html/6424 for improving this.\n    // TODO\n\n    // Set Content-Type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    contentType = 'multipart/form-data; boundary=' + boundary\n  } else if (isBlobLike(object)) {\n    // Blob\n\n    // Set action to this step: read object.\n    action = blobGen\n\n    // Set source to object.\n    source = object\n\n    // Set length to object’s size.\n    length = object.size\n\n    // If object’s type attribute is not the empty byte sequence, set\n    // Content-Type to its value.\n    if (object.type) {\n      contentType = object.type\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive')\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError(\n        'Response body object should not be disturbed or locked'\n      )\n    }\n\n    stream =\n      object instanceof ReadableStream ? object : ReadableStreamFrom(object)\n  } else {\n    // TODO: byte sequence?\n    // TODO: scalar value string?\n    // TODO: else?\n    source = toUSVString(object)\n    contentType = 'text/plain;charset=UTF-8'\n  }\n\n  // 7. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  // TODO: What is a \"byte sequence?\"\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source)\n  }\n\n  // 8. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator\n    stream = new ReadableStream({\n      async start () {\n        iterator = action(object)[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { value, done } = await iterator.next()\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close()\n          })\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            controller.enqueue(new Uint8Array(value))\n          }\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      }\n    })\n  } else if (!stream) {\n    // TODO: Spec doesn't say anything about this?\n    stream = new ReadableStream({\n      async pull (controller) {\n        controller.enqueue(\n          typeof source === 'string' ? new TextEncoder().encode(source) : source\n        )\n        queueMicrotask(() => {\n          controller.close()\n        })\n      }\n    })\n  }\n\n  // 9. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = { stream, source, length }\n\n  // 10. Return body and Content-Type.\n  return [body, contentType]\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    // istanbul ignore next\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'disturbed')\n    // istanbul ignore next\n    assert(!object.locked, 'locked')\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive)\n}\n\nfunction cloneBody (body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee()\n\n  // 2. Set body’s stream to out1.\n  body.stream = out1\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: out2,\n    length: body.length,\n    source: body.source\n  }\n}\n\nconst methods = {\n  async blob () {\n    const chunks = []\n\n    if (this[kState].body) {\n      if (isUint8Array(this[kState].body)) {\n        chunks.push(this[kState].body)\n      } else {\n        const stream = this[kState].body.stream\n\n        if (util.isDisturbed(stream)) {\n          throw new TypeError('disturbed')\n        }\n\n        if (stream.locked) {\n          throw new TypeError('locked')\n        }\n\n        // Compat.\n        stream[kBodyUsed] = true\n\n        for await (const chunk of stream) {\n          chunks.push(chunk)\n        }\n      }\n    }\n\n    return new Blob(chunks, { type: this.headers.get('Content-Type') || '' })\n  },\n\n  async arrayBuffer () {\n    const blob = await this.blob()\n    return await blob.arrayBuffer()\n  },\n\n  async text () {\n    const blob = await this.blob()\n    return toUSVString(await blob.text())\n  },\n\n  async json () {\n    return JSON.parse(await this.text())\n  },\n\n  async formData () {\n    const contentType = this.headers.get('Content-Type')\n\n    // If mimeType’s essence is \"multipart/form-data\", then:\n    if (/multipart\\/form-data/.test(contentType)) {\n      throw new NotSupportedError('multipart/form-data not supported')\n    } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n      // Otherwise, if mimeType’s essence is \"application/x-www-form-urlencoded\", then:\n\n      // 1. Let entries be the result of parsing bytes.\n      let entries\n      try {\n        entries = new URLSearchParams(await this.text())\n      } catch (err) {\n        // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n        // 2. If entries is failure, then throw a TypeError.\n        throw Object.assign(new TypeError(), { cause: err })\n      }\n\n      // 3. Return a new FormData object whose entries are entries.\n      const formData = new FormData()\n      for (const [name, value] of entries) {\n        formData.append(name, value)\n      }\n      return formData\n    } else {\n      // Otherwise, throw a TypeError.\n      throw new TypeError()\n    }\n  }\n}\n\nconst properties = {\n  body: {\n    enumerable: true,\n    get () {\n      return this[kState].body ? this[kState].body.stream : null\n    }\n  },\n  bodyUsed: {\n    enumerable: true,\n    get () {\n      return this[kState].body && util.isDisturbed(this[kState].body.stream)\n    }\n  }\n}\n\nfunction mixinBody (prototype) {\n  Object.assign(prototype, methods)\n  Object.defineProperties(prototype, properties)\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody\n}\n"]},"metadata":{},"sourceType":"script"}