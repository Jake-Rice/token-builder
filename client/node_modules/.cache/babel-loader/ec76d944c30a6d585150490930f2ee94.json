{"ast":null,"code":"const assert = require('assert');\n\nconst {\n  atob\n} = require('buffer');\n\nconst encoder = new TextEncoder(); // https://fetch.spec.whatwg.org/#data-url-processor\n\n/** @param {URL} dataURL */\n\nfunction dataURLProcessor(dataURL) {\n  // 1. Assert: dataURL’s scheme is \"data\".\n  assert(dataURL.protocol === 'data:'); // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n\n  let input = URLSerializer(dataURL, true); // 3. Remove the leading \"data:\" string from input.\n\n  input = input.slice(5); // 4. Let position point at the start of input.\n\n  const position = {\n    position: 0\n  }; // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n\n  let mimeType = collectASequenceOfCodePoints(char => char !== ',', input, position); // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Note: This will only remove U+0020 SPACE code\n  // points, if any.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n\n  const mimeTypeLength = mimeType.length;\n  mimeType = mimeType.replace(/^(\\u0020)+|(\\u0020)+$/g, ''); // 7. If position is past the end of input, then\n  // return failure\n\n  if (position.position >= input.length) {\n    return 'failure';\n  } // 8. Advance position by 1.\n\n\n  position.position++; // 9. Let encodedBody be the remainder of input.\n\n  const encodedBody = input.slice(mimeTypeLength + 1); // 10. Let body be the percent-decoding of encodedBody.\n\n  /** @type {Uint8Array|string} */\n\n  let body = stringPercentDecode(encodedBody); // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n\n  if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = decodeURIComponent(new TextDecoder('utf-8').decode(body)); // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n\n    body = forgivingBase64(stringBody); // 3. If body is failure, then return failure.\n\n    if (body === 'failure') {\n      return 'failure';\n    } // 4. Remove the last 6 code points from mimeType.\n\n\n    mimeType = mimeType.slice(0, -6); // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n\n    mimeType = mimeType.replace(/(\\u0020)+$/, ''); // 6. Remove the last U+003B (;) code point from mimeType.\n\n    mimeType = mimeType.slice(0, -1);\n  } // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n\n\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType;\n  } // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n\n\n  let mimeTypeRecord = parseMIMEType(mimeType); // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII');\n  } // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n\n\n  return {\n    mimeType: mimeTypeRecord,\n    body\n  };\n} // https://url.spec.whatwg.org/#concept-url-serializer\n\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\n\n\nfunction URLSerializer(url) {\n  let excludeFragment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  // 1. Let output be url’s scheme and U+003A (:) concatenated.\n  let output = url.protocol; // 2. If url’s host is non-null:\n\n  if (url.host.length > 0) {\n    // 1. Append \"//\" to output.\n    output += '//'; // 2. If url includes credentials, then:\n\n    if (url.username.length > 0 || url.password.length > 0) {\n      // 1. Append url’s username to output.\n      output += url.username; // 2. If url’s password is not the empty string, then append U+003A (:),\n      // followed by url’s password, to output.\n\n      if (url.password.length > 0) {\n        output += ':' + url.password;\n      } // 3. Append U+0040 (@) to output.\n\n\n      output += '@';\n    } // 3. Append url’s host, serialized, to output.\n\n\n    output += decodeURIComponent(url.host); // 4. If url’s port is non-null, append U+003A (:) followed by url’s port,\n    // serialized, to output.\n\n    if (url.port.length > 0) {\n      output += ':' + url.port;\n    }\n  } // 3. If url’s host is null, url does not have an opaque path,\n  // url’s path’s size is greater than 1, and url’s path[0]\n  // is the empty string, then append U+002F (/) followed by\n  // U+002E (.) to output.\n  // Note: This prevents web+demo:/.//not-a-host/ or web+demo:/path/..//not-a-host/,\n  // when parsed and then serialized, from ending up as web+demo://not-a-host/\n  // (they end up as web+demo:/.//not-a-host/).\n  // Undici implementation note: url's path[0] can never be an\n  // empty string, so we have to slightly alter what the spec says.\n\n\n  if (url.host.length === 0 && url.pathname.length > 1 && url.href.slice(url.protocol.length + 1)[0] === '.') {\n    output += '/.';\n  } // 4. Append the result of URL path serializing url to output.\n\n\n  output += url.pathname; // 5. If url’s query is non-null, append U+003F (?),\n  // followed by url’s query, to output.\n\n  if (url.search.length > 0) {\n    output += url.search;\n  } // 6. If exclude fragment is false and url’s fragment is non-null,\n  // then append U+0023 (#), followed by url’s fragment, to output.\n\n\n  if (excludeFragment === false && url.hash.length > 0) {\n    output += url.hash;\n  } // 7. Return output.\n\n\n  return output;\n} // https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */\n\n\nfunction collectASequenceOfCodePoints(condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = ''; // 2. While position doesn’t point past the end of input and the\n  // code point at position within input meets the condition condition:\n\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position]; // 2. Advance position by 1.\n\n    position.position++;\n  } // 3. Return result.\n\n\n  return result;\n} // https://url.spec.whatwg.org/#string-percent-decode\n\n/** @param {string} input */\n\n\nfunction stringPercentDecode(input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input); // 2. Return the percent-decoding of bytes.\n\n  return percentDecode(bytes);\n} // https://url.spec.whatwg.org/#percent-decode\n\n/** @param {Uint8Array} input */\n\n\nfunction percentDecode(input) {\n  // 1. Let output be an empty byte sequence.\n\n  /** @type {number[]} */\n  const output = []; // 2. For each byte byte in input:\n\n  for (let i = 0; i < input.length; i++) {\n    const byte = input[i]; // 1. If byte is not 0x25 (%), then append byte to output.\n\n    if (byte !== 0x25) {\n      output.push(byte);\n    } // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n    // after byte in input are not in the ranges\n    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n    // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n    // to output.\n    else if (byte === 0x25 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {\n      output.push(0x25);\n    } // 3. Otherwise:\n    else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);\n      const bytePoint = Number.parseInt(nextTwoBytes, 16); // 2. Append a byte whose value is bytePoint to output.\n\n      output.push(bytePoint); // 3. Skip the next two bytes in input.\n\n      i += 2;\n    }\n  } // 3. Return output.\n\n\n  return Uint8Array.of(...output);\n} // https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n\n/** @param {string} input */\n\n\nfunction parseMIMEType(input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = input.trim(); // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n\n  const position = {\n    position: 0\n  }; // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n\n  const type = collectASequenceOfCodePoints(char => char !== '/', input, position); // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n\n  if (type.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(type)) {\n    return 'failure';\n  } // 5. If position is past the end of input, then return\n  // failure\n\n\n  if (position.position > input.length) {\n    return 'failure';\n  } // 6. Advance position by 1. (This skips past U+002F (/).)\n\n\n  position.position++; // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n\n  let subtype = collectASequenceOfCodePoints(char => char !== ';', input, position); // 8. Remove any trailing HTTP whitespace from subtype.\n\n  subtype = subtype.trim(); // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n\n  if (subtype.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(subtype)) {\n    return 'failure';\n  } // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n\n\n  const mimeType = {\n    type: type.toLowerCase(),\n    subtype: subtype.toLowerCase(),\n\n    /** @type {Map<string, string>} */\n    parameters: new Map()\n  }; // 11. While position is not past the end of input:\n\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++; // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n\n    collectASequenceOfCodePoints( // https://fetch.spec.whatwg.org/#http-whitespace\n    char => /(\\u000A|\\u000D|\\u0009|\\u0020)/.test(char), input, position); // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n\n    let parameterName = collectASequenceOfCodePoints(char => char !== ';' && char !== '=', input, position); // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n\n    parameterName = parameterName.toLowerCase(); // 5. If position is not past the end of input, then:\n\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue;\n      } // 2. Advance position by 1. (This skips past U+003D (=).)\n\n\n      position.position++;\n    } // 6. If position is past the end of input, then break.\n\n\n    if (position.position > input.length) {\n      break;\n    } // 7. Let parameterValue be null.\n\n\n    let parameterValue = null; // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      // Undici implementation note: extract-value is never\n      // defined or mentioned anywhere.\n      parameterValue = collectAnHTTPQuotedString(input, position\n      /*, extractValue */\n      ); // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n\n      collectASequenceOfCodePoints(char => char !== ';', input, position);\n    } // 9. Otherwise:\n    else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePoints(char => char !== ';', input, position); // 2. Remove any trailing HTTP whitespace from parameterValue.\n\n      parameterValue = parameterValue.trim(); // 3. If parameterValue is the empty string, then continue.\n\n      if (parameterValue.length === 0) {\n        continue;\n      }\n    } // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeType’s parameters[parameterName] does not exist\n    // then set mimeType’s parameters[parameterName] to parameterValue.\n\n\n    if (parameterName.length !== 0 && /^[!#$%&'*+-.^_|~A-z0-9]+$/.test(parameterName) && // https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n    !/^(\\u0009|\\x{0020}-\\x{007E}|\\x{0080}-\\x{00FF})+$/.test(parameterValue) && !mimeType.parameters.has(parameterName)) {\n      mimeType.parameters.set(parameterName, parameterValue);\n    }\n  } // 12. Return mimeType.\n\n\n  return mimeType;\n} // https://infra.spec.whatwg.org/#forgiving-base64-decode\n\n/** @param {string} data */\n\n\nfunction forgivingBase64(data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, ''); // 2. If data’s code point length divides by 4 leaving\n  // no remainder, then:\n\n  if (data.length % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    data = data.replace(/=?=$/, '');\n  } // 3. If data’s code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n\n\n  if (data.length % 4 === 1) {\n    return 'failure';\n  } // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n\n\n  if (/[^+/0-9A-Za-z]/.test(data)) {\n    return 'failure';\n  }\n\n  const binary = atob(data);\n  const bytes = new Uint8Array(binary.length);\n\n  for (let byte = 0; byte < binary.length; byte++) {\n    bytes[byte] = binary.charCodeAt(byte);\n  }\n\n  return bytes;\n} // https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */\n\n\nfunction collectAnHTTPQuotedString(input, position, extractValue) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position; // 2. Let value be the empty string.\n\n  let value = ''; // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n\n  assert(input[position.position] === '\"'); // 4. Advance position by 1.\n\n  position.position++; // 5. While true:\n\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(char => char !== '\"' && char !== '\\\\', input, position); // 2. If position is past the end of input, then break.\n\n    if (position.position >= input.length) {\n      break;\n    } // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n\n\n    const quoteOrBackslash = input[position.position]; // 4. Advance position by 1.\n\n    position.position++; // 5. If quoteOrBackslash is U+005C (\\), then:\n\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\';\n        break;\n      } // 2. Append the code point at position within input to value.\n\n\n      value += input[position.position]; // 3. Advance position by 1.\n\n      position.position++;\n    } // 6. Otherwise:\n    else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"'); // 2. Break.\n\n      break;\n    }\n  } // 6. If the extract-value flag is set, then return value.\n\n\n  if (extractValue) {\n    return value;\n  } // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n\n\n  return input.slice(positionStart, position.position);\n}\n\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  collectASequenceOfCodePoints,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString\n};","map":{"version":3,"sources":["/Users/jake/workspace/token-builder/node_modules/undici/lib/fetch/dataURL.js"],"names":["assert","require","atob","encoder","TextEncoder","dataURLProcessor","dataURL","protocol","input","URLSerializer","slice","position","mimeType","collectASequenceOfCodePoints","char","mimeTypeLength","length","replace","encodedBody","body","stringPercentDecode","test","stringBody","decodeURIComponent","TextDecoder","decode","forgivingBase64","startsWith","mimeTypeRecord","parseMIMEType","url","excludeFragment","output","host","username","password","port","pathname","href","search","hash","condition","result","bytes","encode","percentDecode","i","byte","push","String","fromCharCode","nextTwoBytes","bytePoint","Number","parseInt","Uint8Array","of","trim","type","subtype","toLowerCase","parameters","Map","parameterName","parameterValue","collectAnHTTPQuotedString","has","set","data","binary","charCodeAt","extractValue","positionStart","value","quoteOrBackslash","module","exports"],"mappings":"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","sourcesContent":["const assert = require('assert')\nconst { atob } = require('buffer')\n\nconst encoder = new TextEncoder()\n\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */\nfunction dataURLProcessor (dataURL) {\n  // 1. Assert: dataURL’s scheme is \"data\".\n  assert(dataURL.protocol === 'data:')\n\n  // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n  let input = URLSerializer(dataURL, true)\n\n  // 3. Remove the leading \"data:\" string from input.\n  input = input.slice(5)\n\n  // 4. Let position point at the start of input.\n  const position = { position: 0 }\n\n  // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n  let mimeType = collectASequenceOfCodePoints(\n    (char) => char !== ',',\n    input,\n    position\n  )\n\n  // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Note: This will only remove U+0020 SPACE code\n  // points, if any.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n  const mimeTypeLength = mimeType.length\n  mimeType = mimeType.replace(/^(\\u0020)+|(\\u0020)+$/g, '')\n\n  // 7. If position is past the end of input, then\n  // return failure\n  if (position.position >= input.length) {\n    return 'failure'\n  }\n\n  // 8. Advance position by 1.\n  position.position++\n\n  // 9. Let encodedBody be the remainder of input.\n  const encodedBody = input.slice(mimeTypeLength + 1)\n\n  // 10. Let body be the percent-decoding of encodedBody.\n  /** @type {Uint8Array|string} */\n  let body = stringPercentDecode(encodedBody)\n\n  // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n  if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = decodeURIComponent(new TextDecoder('utf-8').decode(body))\n    // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n    body = forgivingBase64(stringBody)\n\n    // 3. If body is failure, then return failure.\n    if (body === 'failure') {\n      return 'failure'\n    }\n\n    // 4. Remove the last 6 code points from mimeType.\n    mimeType = mimeType.slice(0, -6)\n\n    // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n    mimeType = mimeType.replace(/(\\u0020)+$/, '')\n\n    // 6. Remove the last U+003B (;) code point from mimeType.\n    mimeType = mimeType.slice(0, -1)\n  }\n\n  // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType\n  }\n\n  // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n  let mimeTypeRecord = parseMIMEType(mimeType)\n\n  // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII')\n  }\n\n  // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n  return { mimeType: mimeTypeRecord, body }\n}\n\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\nfunction URLSerializer (url, excludeFragment = false) {\n  // 1. Let output be url’s scheme and U+003A (:) concatenated.\n  let output = url.protocol\n\n  // 2. If url’s host is non-null:\n  if (url.host.length > 0) {\n    // 1. Append \"//\" to output.\n    output += '//'\n\n    // 2. If url includes credentials, then:\n    if (url.username.length > 0 || url.password.length > 0) {\n      // 1. Append url’s username to output.\n      output += url.username\n\n      // 2. If url’s password is not the empty string, then append U+003A (:),\n      // followed by url’s password, to output.\n      if (url.password.length > 0) {\n        output += ':' + url.password\n      }\n\n      // 3. Append U+0040 (@) to output.\n      output += '@'\n    }\n\n    // 3. Append url’s host, serialized, to output.\n    output += decodeURIComponent(url.host)\n\n    // 4. If url’s port is non-null, append U+003A (:) followed by url’s port,\n    // serialized, to output.\n    if (url.port.length > 0) {\n      output += ':' + url.port\n    }\n  }\n\n  // 3. If url’s host is null, url does not have an opaque path,\n  // url’s path’s size is greater than 1, and url’s path[0]\n  // is the empty string, then append U+002F (/) followed by\n  // U+002E (.) to output.\n  // Note: This prevents web+demo:/.//not-a-host/ or web+demo:/path/..//not-a-host/,\n  // when parsed and then serialized, from ending up as web+demo://not-a-host/\n  // (they end up as web+demo:/.//not-a-host/).\n  // Undici implementation note: url's path[0] can never be an\n  // empty string, so we have to slightly alter what the spec says.\n  if (\n    url.host.length === 0 &&\n    url.pathname.length > 1 &&\n    url.href.slice(url.protocol.length + 1)[0] === '.'\n  ) {\n    output += '/.'\n  }\n\n  // 4. Append the result of URL path serializing url to output.\n  output += url.pathname\n\n  // 5. If url’s query is non-null, append U+003F (?),\n  // followed by url’s query, to output.\n  if (url.search.length > 0) {\n    output += url.search\n  }\n\n  // 6. If exclude fragment is false and url’s fragment is non-null,\n  // then append U+0023 (#), followed by url’s fragment, to output.\n  if (excludeFragment === false && url.hash.length > 0) {\n    output += url.hash\n  }\n\n  // 7. Return output.\n  return output\n}\n\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePoints (condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = ''\n\n  // 2. While position doesn’t point past the end of input and the\n  // code point at position within input meets the condition condition:\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position]\n\n    // 2. Advance position by 1.\n    position.position++\n  }\n\n  // 3. Return result.\n  return result\n}\n\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */\nfunction stringPercentDecode (input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input)\n\n  // 2. Return the percent-decoding of bytes.\n  return percentDecode(bytes)\n}\n\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */\nfunction percentDecode (input) {\n  // 1. Let output be an empty byte sequence.\n  /** @type {number[]} */\n  const output = []\n\n  // 2. For each byte byte in input:\n  for (let i = 0; i < input.length; i++) {\n    const byte = input[i]\n\n    // 1. If byte is not 0x25 (%), then append byte to output.\n    if (byte !== 0x25) {\n      output.push(byte)\n    }\n\n    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n    // after byte in input are not in the ranges\n    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n    // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n    // to output.\n    else if (\n      byte === 0x25 &&\n      !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))\n    ) {\n      output.push(0x25)\n    }\n\n    // 3. Otherwise:\n    else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2])\n      const bytePoint = Number.parseInt(nextTwoBytes, 16)\n\n      // 2. Append a byte whose value is bytePoint to output.\n      output.push(bytePoint)\n\n      // 3. Skip the next two bytes in input.\n      i += 2\n    }\n  }\n\n  // 3. Return output.\n  return Uint8Array.of(...output)\n}\n\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */\nfunction parseMIMEType (input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = input.trim()\n\n  // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n  const type = collectASequenceOfCodePoints(\n    (char) => char !== '/',\n    input,\n    position\n  )\n\n  // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n  if (type.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(type)) {\n    return 'failure'\n  }\n\n  // 5. If position is past the end of input, then return\n  // failure\n  if (position.position > input.length) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1. (This skips past U+002F (/).)\n  position.position++\n\n  // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n  let subtype = collectASequenceOfCodePoints(\n    (char) => char !== ';',\n    input,\n    position\n  )\n\n  // 8. Remove any trailing HTTP whitespace from subtype.\n  subtype = subtype.trim()\n\n  // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  if (subtype.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(subtype)) {\n    return 'failure'\n  }\n\n  // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n  const mimeType = {\n    type: type.toLowerCase(),\n    subtype: subtype.toLowerCase(),\n    /** @type {Map<string, string>} */\n    parameters: new Map()\n  }\n\n  // 11. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++\n\n    // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n    collectASequenceOfCodePoints(\n      // https://fetch.spec.whatwg.org/#http-whitespace\n      (char) => /(\\u000A|\\u000D|\\u0009|\\u0020)/.test(char),\n      input,\n      position\n    )\n\n    // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n    let parameterName = collectASequenceOfCodePoints(\n      (char) => char !== ';' && char !== '=',\n      input,\n      position\n    )\n\n    // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n    parameterName = parameterName.toLowerCase()\n\n    // 5. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue\n      }\n\n      // 2. Advance position by 1. (This skips past U+003D (=).)\n      position.position++\n    }\n\n    // 6. If position is past the end of input, then break.\n    if (position.position > input.length) {\n      break\n    }\n\n    // 7. Let parameterValue be null.\n    let parameterValue = null\n\n    // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      // Undici implementation note: extract-value is never\n      // defined or mentioned anywhere.\n      parameterValue = collectAnHTTPQuotedString(input, position/*, extractValue */)\n\n      // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n      collectASequenceOfCodePoints(\n        (char) => char !== ';',\n        input,\n        position\n      )\n    }\n\n    // 9. Otherwise:\n    else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePoints(\n        (char) => char !== ';',\n        input,\n        position\n      )\n\n      // 2. Remove any trailing HTTP whitespace from parameterValue.\n      parameterValue = parameterValue.trim()\n\n      // 3. If parameterValue is the empty string, then continue.\n      if (parameterValue.length === 0) {\n        continue\n      }\n    }\n\n    // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeType’s parameters[parameterName] does not exist\n    // then set mimeType’s parameters[parameterName] to parameterValue.\n    if (\n      parameterName.length !== 0 &&\n      /^[!#$%&'*+-.^_|~A-z0-9]+$/.test(parameterName) &&\n      // https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n      !/^(\\u0009|\\x{0020}-\\x{007E}|\\x{0080}-\\x{00FF})+$/.test(parameterValue) &&\n      !mimeType.parameters.has(parameterName)\n    ) {\n      mimeType.parameters.set(parameterName, parameterValue)\n    }\n  }\n\n  // 12. Return mimeType.\n  return mimeType\n}\n\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */\nfunction forgivingBase64 (data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, '')\n\n  // 2. If data’s code point length divides by 4 leaving\n  // no remainder, then:\n  if (data.length % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    data = data.replace(/=?=$/, '')\n  }\n\n  // 3. If data’s code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n  if (data.length % 4 === 1) {\n    return 'failure'\n  }\n\n  // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n  if (/[^+/0-9A-Za-z]/.test(data)) {\n    return 'failure'\n  }\n\n  const binary = atob(data)\n  const bytes = new Uint8Array(binary.length)\n\n  for (let byte = 0; byte < binary.length; byte++) {\n    bytes[byte] = binary.charCodeAt(byte)\n  }\n\n  return bytes\n}\n\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */\nfunction collectAnHTTPQuotedString (input, position, extractValue) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position\n\n  // 2. Let value be the empty string.\n  let value = ''\n\n  // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n  assert(input[position.position] === '\"')\n\n  // 4. Advance position by 1.\n  position.position++\n\n  // 5. While true:\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== '\\\\',\n      input,\n      position\n    )\n\n    // 2. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break\n    }\n\n    // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n    const quoteOrBackslash = input[position.position]\n\n    // 4. Advance position by 1.\n    position.position++\n\n    // 5. If quoteOrBackslash is U+005C (\\), then:\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\'\n        break\n      }\n\n      // 2. Append the code point at position within input to value.\n      value += input[position.position]\n\n      // 3. Advance position by 1.\n      position.position++\n    }\n\n    // 6. Otherwise:\n    else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"')\n\n      // 2. Break.\n      break\n    }\n  }\n\n  // 6. If the extract-value flag is set, then return value.\n  if (extractValue) {\n    return value\n  }\n\n  // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n  return input.slice(positionStart, position.position)\n}\n\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  collectASequenceOfCodePoints,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString\n}\n"]},"metadata":{},"sourceType":"script"}