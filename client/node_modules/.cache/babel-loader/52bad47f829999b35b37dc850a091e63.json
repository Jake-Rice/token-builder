{"ast":null,"code":"'use strict';\n\nconst {\n  isBlobLike,\n  isFileLike,\n  toUSVString\n} = require('./util');\n\nconst {\n  kState\n} = require('./symbols');\n\nconst {\n  File,\n  FileLike\n} = require('./file');\n\nconst {\n  Blob\n} = require('buffer');\n\nclass FormData {\n  constructor() {\n    if (arguments.length > 0 && !((arguments.length <= 0 ? undefined : arguments[0])?.constructor?.name === 'HTMLFormElement')) {\n      throw new TypeError(\"Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'\");\n    }\n\n    this[kState] = [];\n  }\n\n  append() {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    if (arguments.length < 2) {\n      throw new TypeError(`Failed to execute 'append' on 'FormData': 2 arguments required, but only ${arguments.length} present.`);\n    }\n\n    if (arguments.length === 3 && !isBlobLike(arguments.length <= 1 ? undefined : arguments[1])) {\n      throw new TypeError(\"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'\");\n    }\n\n    const name = toUSVString(arguments.length <= 0 ? undefined : arguments[0]);\n    const filename = arguments.length === 3 ? toUSVString(arguments.length <= 2 ? undefined : arguments[2]) : undefined; // 1. Let value be value if given; otherwise blobValue.\n\n    const value = isBlobLike(arguments.length <= 1 ? undefined : arguments[1]) ? arguments.length <= 1 ? undefined : arguments[1] : toUSVString(arguments.length <= 1 ? undefined : arguments[1]); // 2. Let entry be the result of creating an entry with\n    // name, value, and filename if given.\n\n    const entry = makeEntry(name, value, filename); // 3. Append entry to this’s entry list.\n\n    this[kState].push(entry);\n  }\n\n  delete() {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    if (arguments.length < 1) {\n      throw new TypeError(`Failed to execute 'delete' on 'FormData': 1 arguments required, but only ${arguments.length} present.`);\n    }\n\n    const name = toUSVString(arguments.length <= 0 ? undefined : arguments[0]); // The delete(name) method steps are to remove all entries whose name\n    // is name from this’s entry list.\n\n    const next = [];\n\n    for (const entry of this[kState]) {\n      if (entry.name !== name) {\n        next.push(entry);\n      }\n    }\n\n    this[kState] = next;\n  }\n\n  get() {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    if (arguments.length < 1) {\n      throw new TypeError(`Failed to execute 'get' on 'FormData': 1 arguments required, but only ${arguments.length} present.`);\n    }\n\n    const name = toUSVString(arguments.length <= 0 ? undefined : arguments[0]); // 1. If there is no entry whose name is name in this’s entry list,\n    // then return null.\n\n    const idx = this[kState].findIndex(entry => entry.name === name);\n\n    if (idx === -1) {\n      return null;\n    } // 2. Return the value of the first entry whose name is name from\n    // this’s entry list.\n\n\n    return this[kState][idx].value;\n  }\n\n  getAll() {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    if (arguments.length < 1) {\n      throw new TypeError(`Failed to execute 'getAll' on 'FormData': 1 arguments required, but only ${arguments.length} present.`);\n    }\n\n    const name = toUSVString(arguments.length <= 0 ? undefined : arguments[0]); // 1. If there is no entry whose name is name in this’s entry list,\n    // then return the empty list.\n    // 2. Return the values of all entries whose name is name, in order,\n    // from this’s entry list.\n\n    return this[kState].filter(entry => entry.name === name).map(entry => entry.value);\n  }\n\n  has() {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    if (arguments.length < 1) {\n      throw new TypeError(`Failed to execute 'has' on 'FormData': 1 arguments required, but only ${arguments.length} present.`);\n    }\n\n    const name = toUSVString(arguments.length <= 0 ? undefined : arguments[0]); // The has(name) method steps are to return true if there is an entry\n    // whose name is name in this’s entry list; otherwise false.\n\n    return this[kState].findIndex(entry => entry.name === name) !== -1;\n  }\n\n  set() {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    if (arguments.length < 2) {\n      throw new TypeError(`Failed to execute 'set' on 'FormData': 2 arguments required, but only ${arguments.length} present.`);\n    }\n\n    if (arguments.length === 3 && !isBlobLike(arguments.length <= 1 ? undefined : arguments[1])) {\n      throw new TypeError(\"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'\");\n    }\n\n    const name = toUSVString(arguments.length <= 0 ? undefined : arguments[0]);\n    const filename = arguments.length === 3 ? toUSVString(arguments.length <= 2 ? undefined : arguments[2]) : undefined; // The set(name, value) and set(name, blobValue, filename) method steps\n    // are:\n    // 1. Let value be value if given; otherwise blobValue.\n\n    const value = isBlobLike(arguments.length <= 1 ? undefined : arguments[1]) ? arguments.length <= 1 ? undefined : arguments[1] : toUSVString(arguments.length <= 1 ? undefined : arguments[1]); // 2. Let entry be the result of creating an entry with name, value, and\n    // filename if given.\n\n    const entry = makeEntry(name, value, filename); // 3. If there are entries in this’s entry list whose name is name, then\n    // replace the first such entry with entry and remove the others.\n\n    const idx = this[kState].findIndex(entry => entry.name === name);\n\n    if (idx !== -1) {\n      this[kState] = [...this[kState].slice(0, idx), entry, ...this[kState].slice(idx + 1).filter(entry => entry.name !== name)];\n    } else {\n      // 4. Otherwise, append entry to this’s entry list.\n      this[kState].push(entry);\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    return this.constructor.name;\n  }\n\n  *entries() {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    for (const pair of this) {\n      yield pair;\n    }\n  }\n\n  *keys() {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    for (const [key] of this) {\n      yield key;\n    }\n  }\n\n  *values() {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    for (const [, value] of this) {\n      yield value;\n    }\n  }\n\n  *[Symbol.iterator]() {\n    // The value pairs to iterate over are this’s entry list’s entries with\n    // the key being the name and the value being the value.\n    for (const {\n      name,\n      value\n    } of this[kState]) {\n      yield [name, value];\n    }\n  }\n\n}\n\nfunction makeEntry(name, value, filename) {\n  // To create an entry for name, value, and optionally a filename, run these\n  // steps:\n  // 1. Let entry be a new entry.\n  const entry = {\n    name: null,\n    value: null\n  }; // 2. Set entry’s name to name.\n\n  entry.name = name; // 3. If value is a Blob object and not a File object, then set value to a new File\n  // object, representing the same bytes, whose name attribute value is \"blob\".\n\n  if (isBlobLike(value) && !isFileLike(value)) {\n    value = value instanceof Blob ? new File([value], 'blob') : new FileLike(value, 'blob');\n  } // 4. If value is (now) a File object and filename is given, then set value to a\n  // new File object, representing the same bytes, whose name attribute value is\n  // filename.\n  // TODO: This is a bit weird... What if passed value is a File?\n  // Do we just override the name attribute? Since it says \"if value is (now)\"\n  // does that mean that this lives inside the previous condition? In which case\n  // creating one more File instance doesn't make much sense....\n\n\n  if (isFileLike(value) && filename != null) {\n    value = value instanceof File ? new File([value], filename) : new FileLike(value, filename);\n  } // 5. Set entry’s value to value.\n\n\n  entry.value = value; // 6. Return entry.\n\n  return entry;\n}\n\nmodule.exports = {\n  FormData: globalThis.FormData ?? FormData\n};","map":{"version":3,"sources":["/Users/jake/workspace/token-builder/node_modules/undici/lib/fetch/formdata.js"],"names":["isBlobLike","isFileLike","toUSVString","require","kState","File","FileLike","Blob","FormData","constructor","length","name","TypeError","append","filename","undefined","value","entry","makeEntry","push","delete","next","get","idx","findIndex","getAll","filter","map","has","set","slice","Symbol","toStringTag","entries","pair","keys","key","values","iterator","module","exports","globalThis"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { isBlobLike, isFileLike, toUSVString } = require('./util')\nconst { kState } = require('./symbols')\nconst { File, FileLike } = require('./file')\nconst { Blob } = require('buffer')\n\nclass FormData {\n  constructor (...args) {\n    if (args.length > 0 && !(args[0]?.constructor?.name === 'HTMLFormElement')) {\n      throw new TypeError(\n        \"Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'\"\n      )\n    }\n\n    this[kState] = []\n  }\n\n  append (...args) {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    if (args.length < 2) {\n      throw new TypeError(\n        `Failed to execute 'append' on 'FormData': 2 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    if (args.length === 3 && !isBlobLike(args[1])) {\n      throw new TypeError(\n        \"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'\"\n      )\n    }\n\n    const name = toUSVString(args[0])\n    const filename = args.length === 3 ? toUSVString(args[2]) : undefined\n\n    // 1. Let value be value if given; otherwise blobValue.\n    const value = isBlobLike(args[1]) ? args[1] : toUSVString(args[1])\n\n    // 2. Let entry be the result of creating an entry with\n    // name, value, and filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. Append entry to this’s entry list.\n    this[kState].push(entry)\n  }\n\n  delete (...args) {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'delete' on 'FormData': 1 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const name = toUSVString(args[0])\n\n    // The delete(name) method steps are to remove all entries whose name\n    // is name from this’s entry list.\n    const next = []\n    for (const entry of this[kState]) {\n      if (entry.name !== name) {\n        next.push(entry)\n      }\n    }\n\n    this[kState] = next\n  }\n\n  get (...args) {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'get' on 'FormData': 1 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const name = toUSVString(args[0])\n\n    // 1. If there is no entry whose name is name in this’s entry list,\n    // then return null.\n    const idx = this[kState].findIndex((entry) => entry.name === name)\n    if (idx === -1) {\n      return null\n    }\n\n    // 2. Return the value of the first entry whose name is name from\n    // this’s entry list.\n    return this[kState][idx].value\n  }\n\n  getAll (...args) {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'getAll' on 'FormData': 1 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const name = toUSVString(args[0])\n\n    // 1. If there is no entry whose name is name in this’s entry list,\n    // then return the empty list.\n    // 2. Return the values of all entries whose name is name, in order,\n    // from this’s entry list.\n    return this[kState]\n      .filter((entry) => entry.name === name)\n      .map((entry) => entry.value)\n  }\n\n  has (...args) {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'has' on 'FormData': 1 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const name = toUSVString(args[0])\n\n    // The has(name) method steps are to return true if there is an entry\n    // whose name is name in this’s entry list; otherwise false.\n    return this[kState].findIndex((entry) => entry.name === name) !== -1\n  }\n\n  set (...args) {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    if (args.length < 2) {\n      throw new TypeError(\n        `Failed to execute 'set' on 'FormData': 2 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    if (args.length === 3 && !isBlobLike(args[1])) {\n      throw new TypeError(\n        \"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'\"\n      )\n    }\n    const name = toUSVString(args[0])\n    const filename = args.length === 3 ? toUSVString(args[2]) : undefined\n\n    // The set(name, value) and set(name, blobValue, filename) method steps\n    // are:\n\n    // 1. Let value be value if given; otherwise blobValue.\n    const value = isBlobLike(args[1]) ? args[1] : toUSVString(args[1])\n\n    // 2. Let entry be the result of creating an entry with name, value, and\n    // filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. If there are entries in this’s entry list whose name is name, then\n    // replace the first such entry with entry and remove the others.\n    const idx = this[kState].findIndex((entry) => entry.name === name)\n    if (idx !== -1) {\n      this[kState] = [\n        ...this[kState].slice(0, idx),\n        entry,\n        ...this[kState].slice(idx + 1).filter((entry) => entry.name !== name)\n      ]\n    } else {\n      // 4. Otherwise, append entry to this’s entry list.\n      this[kState].push(entry)\n    }\n  }\n\n  get [Symbol.toStringTag] () {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this.constructor.name\n  }\n\n  * entries () {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    for (const pair of this) {\n      yield pair\n    }\n  }\n\n  * keys () {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    for (const [key] of this) {\n      yield key\n    }\n  }\n\n  * values () {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    for (const [, value] of this) {\n      yield value\n    }\n  }\n\n  * [Symbol.iterator] () {\n    // The value pairs to iterate over are this’s entry list’s entries with\n    // the key being the name and the value being the value.\n    for (const { name, value } of this[kState]) {\n      yield [name, value]\n    }\n  }\n}\n\nfunction makeEntry (name, value, filename) {\n  // To create an entry for name, value, and optionally a filename, run these\n  // steps:\n\n  // 1. Let entry be a new entry.\n  const entry = {\n    name: null,\n    value: null\n  }\n\n  // 2. Set entry’s name to name.\n  entry.name = name\n\n  // 3. If value is a Blob object and not a File object, then set value to a new File\n  // object, representing the same bytes, whose name attribute value is \"blob\".\n  if (isBlobLike(value) && !isFileLike(value)) {\n    value = value instanceof Blob\n      ? new File([value], 'blob')\n      : new FileLike(value, 'blob')\n  }\n\n  // 4. If value is (now) a File object and filename is given, then set value to a\n  // new File object, representing the same bytes, whose name attribute value is\n  // filename.\n  // TODO: This is a bit weird... What if passed value is a File?\n  // Do we just override the name attribute? Since it says \"if value is (now)\"\n  // does that mean that this lives inside the previous condition? In which case\n  // creating one more File instance doesn't make much sense....\n  if (isFileLike(value) && filename != null) {\n    value = value instanceof File\n      ? new File([value], filename)\n      : new FileLike(value, filename)\n  }\n\n  // 5. Set entry’s value to value.\n  entry.value = value\n\n  // 6. Return entry.\n  return entry\n}\n\nmodule.exports = { FormData: globalThis.FormData ?? FormData }\n"]},"metadata":{},"sourceType":"script"}