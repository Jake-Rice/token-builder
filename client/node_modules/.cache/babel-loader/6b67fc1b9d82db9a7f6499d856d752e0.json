{"ast":null,"code":"'use strict';\n\nconst {\n  BalancedPoolMissingUpstreamError,\n  InvalidArgumentError\n} = require('./core/errors');\n\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n} = require('./pool-base');\n\nconst Pool = require('./pool');\n\nconst {\n  kUrl\n} = require('./core/symbols');\n\nconst {\n  parseOrigin\n} = require('./core/util');\n\nconst kFactory = Symbol('factory');\nconst kOptions = Symbol('options');\n\nfunction defaultFactory(origin, opts) {\n  return new Pool(origin, opts);\n}\n\nclass BalancedPool extends PoolBase {\n  constructor() {\n    let upstreams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let {\n      factory = defaultFactory,\n      ...opts\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this[kOptions] = opts;\n\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams];\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.');\n    }\n\n    this[kFactory] = factory;\n\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream);\n    }\n  }\n\n  addUpstream(upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin;\n\n    if (this[kClients].find(pool => pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true)) {\n      return this;\n    }\n\n    this[kAddClient](this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions])));\n    return this;\n  }\n\n  removeUpstream(upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin;\n    const pool = this[kClients].find(pool => pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true);\n\n    if (pool) {\n      this[kRemoveClient](pool);\n    }\n\n    return this;\n  }\n\n  get upstreams() {\n    return this[kClients].filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true).map(p => p[kUrl].origin);\n  }\n\n  [kGetDispatcher]() {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kClients].length === 0) {\n      throw new BalancedPoolMissingUpstreamError();\n    }\n\n    const dispatcher = this[kClients].find(dispatcher => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);\n\n    if (!dispatcher) {\n      return;\n    }\n\n    this[kClients].splice(this[kClients].indexOf(dispatcher), 1);\n    this[kClients].push(dispatcher);\n    return dispatcher;\n  }\n\n}\n\nmodule.exports = BalancedPool;","map":{"version":3,"sources":["/Users/jake/workspace/token-builder/node_modules/undici/lib/balanced-pool.js"],"names":["BalancedPoolMissingUpstreamError","InvalidArgumentError","require","PoolBase","kClients","kNeedDrain","kAddClient","kRemoveClient","kGetDispatcher","Pool","kUrl","parseOrigin","kFactory","Symbol","kOptions","defaultFactory","origin","opts","BalancedPool","constructor","upstreams","factory","Array","isArray","upstream","addUpstream","upstreamOrigin","find","pool","closed","destroyed","Object","assign","removeUpstream","filter","dispatcher","map","p","length","splice","indexOf","push","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst {\n  BalancedPoolMissingUpstreamError,\n  InvalidArgumentError\n} = require('./core/errors')\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n} = require('./pool-base')\nconst Pool = require('./pool')\nconst { kUrl } = require('./core/symbols')\nconst { parseOrigin } = require('./core/util')\nconst kFactory = Symbol('factory')\n\nconst kOptions = Symbol('options')\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts);\n}\n\nclass BalancedPool extends PoolBase {\n  constructor (upstreams = [], { factory = defaultFactory, ...opts } = {}) {\n    super()\n\n    this[kOptions] = opts\n\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams]\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    this[kFactory] = factory\n\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream)\n    }\n  }\n\n  addUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    if (this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))) {\n      return this\n    }\n\n    this[kAddClient](this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions])))\n\n    return this\n  }\n\n  removeUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    const pool = this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))\n\n    if (pool) {\n      this[kRemoveClient](pool)\n    }\n\n    return this\n  }\n\n  get upstreams () {\n    return this[kClients]\n      .filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true)\n      .map((p) => p[kUrl].origin)\n  }\n\n  [kGetDispatcher] () {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kClients].length === 0) {\n      throw new BalancedPoolMissingUpstreamError()\n    }\n\n    const dispatcher = this[kClients].find(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n\n    if (!dispatcher) {\n      return\n    }\n\n    this[kClients].splice(this[kClients].indexOf(dispatcher), 1)\n    this[kClients].push(dispatcher)\n\n    return dispatcher\n  }\n}\n\nmodule.exports = BalancedPool\n"]},"metadata":{},"sourceType":"script"}