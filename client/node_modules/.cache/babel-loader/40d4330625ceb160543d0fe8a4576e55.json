{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst chalk_1 = __importDefault(require(\"chalk\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst constants_1 = require(\"../internal/constants\");\n\nconst config_env_1 = require(\"../internal/core/config/config-env\");\n\nconst typescript_support_1 = require(\"../internal/core/typescript-support\");\n\nconst disk_cache_1 = require(\"../internal/hardhat-network/provider/utils/disk-cache\");\n\nconst fork_recomendations_banner_1 = require(\"../internal/hardhat-network/provider/utils/fork-recomendations-banner\");\n\nconst glob_1 = require(\"../internal/util/glob\");\n\nconst strings_1 = require(\"../internal/util/strings\");\n\nconst task_names_1 = require(\"./task-names\");\n\n(0, config_env_1.subtask)(task_names_1.TASK_TEST_GET_TEST_FILES).addOptionalVariadicPositionalParam(\"testFiles\", \"An optional list of files to test\", []).setAction(async (_ref, _ref2) => {\n  let {\n    testFiles\n  } = _ref;\n  let {\n    config\n  } = _ref2;\n\n  if (testFiles.length !== 0) {\n    const testFilesAbsolutePaths = testFiles.map(x => path_1.default.resolve(process.cwd(), x));\n    return testFilesAbsolutePaths;\n  }\n\n  const jsFiles = await (0, glob_1.glob)(path_1.default.join(config.paths.tests, \"**/*.js\"));\n\n  if (!(0, typescript_support_1.isRunningWithTypescript)(config)) {\n    return jsFiles;\n  }\n\n  const tsFiles = await (0, glob_1.glob)(path_1.default.join(config.paths.tests, \"**/*.ts\"));\n  return [...jsFiles, ...tsFiles];\n});\n(0, config_env_1.subtask)(task_names_1.TASK_TEST_SETUP_TEST_ENVIRONMENT, async () => {});\n(0, config_env_1.subtask)(task_names_1.TASK_TEST_RUN_MOCHA_TESTS).addFlag(\"parallel\", \"Run tests in parallel\").addFlag(\"bail\", \"Stop running tests after the first test failure\").addOptionalParam(\"grep\", \"Only run tests matching the given string or regexp\").addOptionalVariadicPositionalParam(\"testFiles\", \"An optional list of files to test\", []).setAction(async (taskArgs, _ref3) => {\n  let {\n    config\n  } = _ref3;\n\n  var _a;\n\n  const {\n    default: Mocha\n  } = await Promise.resolve().then(() => __importStar(require(\"mocha\")));\n  const mochaConfig = Object.assign(Object.assign({}, config.mocha), {\n    grep: taskArgs.grep\n  });\n\n  if (taskArgs.bail) {\n    mochaConfig.bail = true;\n  }\n\n  if (taskArgs.parallel) {\n    mochaConfig.parallel = true;\n  }\n\n  if (mochaConfig.parallel === true) {\n    const mochaRequire = (_a = mochaConfig.require) !== null && _a !== void 0 ? _a : [];\n\n    if (!mochaRequire.includes(\"hardhat/register\")) {\n      mochaRequire.push(\"hardhat/register\");\n    }\n\n    mochaConfig.require = mochaRequire;\n  }\n\n  const mocha = new Mocha(mochaConfig);\n  taskArgs.testFiles.forEach(file => mocha.addFile(file));\n  const testFailures = await new Promise(resolve => {\n    mocha.run(resolve);\n  });\n  mocha.dispose();\n  return testFailures;\n});\n(0, config_env_1.subtask)(task_names_1.TASK_TEST_RUN_SHOW_FORK_RECOMMENDATIONS).setAction(async (_, _ref4) => {\n  let {\n    config,\n    network\n  } = _ref4;\n\n  if (network.name !== constants_1.HARDHAT_NETWORK_NAME) {\n    return;\n  }\n\n  const forkCache = (0, disk_cache_1.getForkCacheDirPath)(config.paths);\n  await (0, fork_recomendations_banner_1.showForkRecommendationsBannerIfNecessary)(network.config, forkCache);\n});\n(0, config_env_1.task)(task_names_1.TASK_TEST, \"Runs mocha tests\").addOptionalVariadicPositionalParam(\"testFiles\", \"An optional list of files to test\", []).addFlag(\"noCompile\", \"Don't compile before running this task\").addFlag(\"parallel\", \"Run tests in parallel\").addFlag(\"bail\", \"Stop running tests after the first test failure\").addOptionalParam(\"grep\", \"Only run tests matching the given string or regexp\").setAction(async (_ref5, _ref6) => {\n  let {\n    testFiles,\n    noCompile,\n    parallel,\n    bail,\n    grep\n  } = _ref5;\n  let {\n    run,\n    network\n  } = _ref6;\n\n  if (!noCompile) {\n    await run(task_names_1.TASK_COMPILE, {\n      quiet: true\n    });\n  }\n\n  const files = await run(task_names_1.TASK_TEST_GET_TEST_FILES, {\n    testFiles\n  });\n  await run(task_names_1.TASK_TEST_SETUP_TEST_ENVIRONMENT);\n  await run(task_names_1.TASK_TEST_RUN_SHOW_FORK_RECOMMENDATIONS);\n  const testFailures = await run(task_names_1.TASK_TEST_RUN_MOCHA_TESTS, {\n    testFiles: files,\n    parallel,\n    bail,\n    grep\n  });\n\n  if (network.name === constants_1.HARDHAT_NETWORK_NAME) {\n    const stackTracesFailures = await network.provider.send(\"hardhat_getStackTraceFailuresCount\");\n\n    if (stackTracesFailures !== 0) {\n      console.warn(chalk_1.default.yellow(`Failed to generate ${stackTracesFailures} ${(0, strings_1.pluralize)(stackTracesFailures, \"stack trace\")}. Run Hardhat with --verbose to learn more.`));\n    }\n  }\n\n  process.exitCode = testFailures;\n  return testFailures;\n});","map":{"version":3,"mappings":"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","names":["task_names_1","addOptionalVariadicPositionalParam","setAction","testFiles","config","length","testFilesAbsolutePaths","map","x","path_1","resolve","process","cwd","jsFiles","join","paths","tests","tsFiles","addFlag","addOptionalParam","taskArgs","default","Mocha","mochaConfig","mocha","grep","bail","parallel","mochaRequire","require","_a","includes","push","forEach","file","addFile","testFailures","Promise","run","dispose","_","network","name","constants_1","forkCache","noCompile","quiet","files","stackTracesFailures","provider","send","console","warn","chalk_1","yellow","exitCode"],"sources":["/Users/jake/workspace/token-builder/node_modules/hardhat/src/builtin-tasks/test.ts"],"sourcesContent":["import type { MochaOptions } from \"mocha\";\n\nimport chalk from \"chalk\";\nimport path from \"path\";\n\nimport { HARDHAT_NETWORK_NAME } from \"../internal/constants\";\nimport { subtask, task } from \"../internal/core/config/config-env\";\nimport { isRunningWithTypescript } from \"../internal/core/typescript-support\";\nimport { getForkCacheDirPath } from \"../internal/hardhat-network/provider/utils/disk-cache\";\nimport { showForkRecommendationsBannerIfNecessary } from \"../internal/hardhat-network/provider/utils/fork-recomendations-banner\";\nimport { glob } from \"../internal/util/glob\";\nimport { pluralize } from \"../internal/util/strings\";\n\nimport {\n  TASK_COMPILE,\n  TASK_TEST,\n  TASK_TEST_GET_TEST_FILES,\n  TASK_TEST_RUN_MOCHA_TESTS,\n  TASK_TEST_RUN_SHOW_FORK_RECOMMENDATIONS,\n  TASK_TEST_SETUP_TEST_ENVIRONMENT,\n} from \"./task-names\";\n\nsubtask(TASK_TEST_GET_TEST_FILES)\n  .addOptionalVariadicPositionalParam(\n    \"testFiles\",\n    \"An optional list of files to test\",\n    []\n  )\n  .setAction(async ({ testFiles }: { testFiles: string[] }, { config }) => {\n    if (testFiles.length !== 0) {\n      const testFilesAbsolutePaths = testFiles.map((x) =>\n        path.resolve(process.cwd(), x)\n      );\n\n      return testFilesAbsolutePaths;\n    }\n\n    const jsFiles = await glob(path.join(config.paths.tests, \"**/*.js\"));\n\n    if (!isRunningWithTypescript(config)) {\n      return jsFiles;\n    }\n\n    const tsFiles = await glob(path.join(config.paths.tests, \"**/*.ts\"));\n\n    return [...jsFiles, ...tsFiles];\n  });\n\nsubtask(TASK_TEST_SETUP_TEST_ENVIRONMENT, async () => {});\n\nsubtask(TASK_TEST_RUN_MOCHA_TESTS)\n  .addFlag(\"parallel\", \"Run tests in parallel\")\n  .addFlag(\"bail\", \"Stop running tests after the first test failure\")\n  .addOptionalParam(\n    \"grep\",\n    \"Only run tests matching the given string or regexp\"\n  )\n  .addOptionalVariadicPositionalParam(\n    \"testFiles\",\n    \"An optional list of files to test\",\n    []\n  )\n  .setAction(\n    async (\n      taskArgs: {\n        bail: boolean;\n        parallel: boolean;\n        testFiles: string[];\n        grep?: string;\n      },\n      { config }\n    ) => {\n      const { default: Mocha } = await import(\"mocha\");\n\n      const mochaConfig: MochaOptions = {\n        ...config.mocha,\n        grep: taskArgs.grep,\n      };\n\n      if (taskArgs.bail) {\n        mochaConfig.bail = true;\n      }\n      if (taskArgs.parallel) {\n        mochaConfig.parallel = true;\n      }\n\n      if (mochaConfig.parallel === true) {\n        const mochaRequire = mochaConfig.require ?? [];\n        if (!mochaRequire.includes(\"hardhat/register\")) {\n          mochaRequire.push(\"hardhat/register\");\n        }\n        mochaConfig.require = mochaRequire;\n      }\n\n      const mocha = new Mocha(mochaConfig);\n      taskArgs.testFiles.forEach((file) => mocha.addFile(file));\n\n      const testFailures = await new Promise<number>((resolve) => {\n        mocha.run(resolve);\n      });\n\n      mocha.dispose();\n\n      return testFailures;\n    }\n  );\n\nsubtask(TASK_TEST_RUN_SHOW_FORK_RECOMMENDATIONS).setAction(\n  async (_, { config, network }) => {\n    if (network.name !== HARDHAT_NETWORK_NAME) {\n      return;\n    }\n\n    const forkCache = getForkCacheDirPath(config.paths);\n    await showForkRecommendationsBannerIfNecessary(network.config, forkCache);\n  }\n);\n\ntask(TASK_TEST, \"Runs mocha tests\")\n  .addOptionalVariadicPositionalParam(\n    \"testFiles\",\n    \"An optional list of files to test\",\n    []\n  )\n  .addFlag(\"noCompile\", \"Don't compile before running this task\")\n  .addFlag(\"parallel\", \"Run tests in parallel\")\n  .addFlag(\"bail\", \"Stop running tests after the first test failure\")\n  .addOptionalParam(\n    \"grep\",\n    \"Only run tests matching the given string or regexp\"\n  )\n  .setAction(\n    async (\n      {\n        testFiles,\n        noCompile,\n        parallel,\n        bail,\n        grep,\n      }: {\n        testFiles: string[];\n        noCompile: boolean;\n        parallel: boolean;\n        bail: boolean;\n        grep?: string;\n      },\n      { run, network }\n    ) => {\n      if (!noCompile) {\n        await run(TASK_COMPILE, { quiet: true });\n      }\n\n      const files = await run(TASK_TEST_GET_TEST_FILES, { testFiles });\n\n      await run(TASK_TEST_SETUP_TEST_ENVIRONMENT);\n\n      await run(TASK_TEST_RUN_SHOW_FORK_RECOMMENDATIONS);\n\n      const testFailures = await run(TASK_TEST_RUN_MOCHA_TESTS, {\n        testFiles: files,\n        parallel,\n        bail,\n        grep,\n      });\n\n      if (network.name === HARDHAT_NETWORK_NAME) {\n        const stackTracesFailures = await network.provider.send(\n          \"hardhat_getStackTraceFailuresCount\"\n        );\n\n        if (stackTracesFailures !== 0) {\n          console.warn(\n            chalk.yellow(\n              `Failed to generate ${stackTracesFailures} ${pluralize(\n                stackTracesFailures,\n                \"stack trace\"\n              )}. Run Hardhat with --verbose to learn more.`\n            )\n          );\n        }\n      }\n\n      process.exitCode = testFailures;\n      return testFailures;\n    }\n  );\n"]},"metadata":{},"sourceType":"script"}