{"ast":null,"code":"'use strict';\n\nconst {\n  MockNotMatchedError\n} = require('./mock-errors');\n\nconst {\n  kHeadersList\n} = require('../core/symbols');\n\nconst {\n  kDispatches,\n  kMockAgent,\n  kOriginalDispatch,\n  kOrigin,\n  kIsMockActive,\n  kGetNetConnect\n} = require('./mock-symbols');\n\nfunction matchValue(match, value) {\n  if (typeof match === 'string') {\n    return match === value;\n  }\n\n  if (match instanceof RegExp) {\n    return match.test(value);\n  }\n\n  if (typeof match === 'function') {\n    return match(value) === true;\n  }\n\n  return false;\n}\n\nfunction matchHeaders(mockDispatch, headers) {\n  if (typeof mockDispatch.headers === 'undefined') {\n    return true;\n  }\n\n  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {\n    return false;\n  }\n\n  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {\n    const header = typeof headers.get === 'function' ? headers.get(matchHeaderName) : headers[matchHeaderName];\n\n    if (!matchValue(matchHeaderValue, header)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction matchKey(mockDispatch, _ref) {\n  let {\n    path,\n    method,\n    body,\n    headers\n  } = _ref;\n  const pathMatch = matchValue(mockDispatch.path, path);\n  const methodMatch = matchValue(mockDispatch.method, method);\n  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true;\n  const headersMatch = matchHeaders(mockDispatch, headers);\n  return pathMatch && methodMatch && bodyMatch && headersMatch;\n}\n\nfunction getResponseData(data) {\n  if (Buffer.isBuffer(data)) {\n    return data;\n  } else if (typeof data === 'object') {\n    return JSON.stringify(data);\n  } else {\n    return data.toString();\n  }\n}\n\nfunction getMockDispatch(mockDispatches, key) {\n  // Match path\n  let matchedMockDispatches = mockDispatches.filter(_ref2 => {\n    let {\n      consumed\n    } = _ref2;\n    return !consumed;\n  }).filter(_ref3 => {\n    let {\n      path\n    } = _ref3;\n    return matchValue(path, key.path);\n  });\n\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for path '${key.path}'`);\n  } // Match method\n\n\n  matchedMockDispatches = matchedMockDispatches.filter(_ref4 => {\n    let {\n      method\n    } = _ref4;\n    return matchValue(method, key.method);\n  });\n\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);\n  } // Match body\n\n\n  matchedMockDispatches = matchedMockDispatches.filter(_ref5 => {\n    let {\n      body\n    } = _ref5;\n    return typeof body !== 'undefined' ? matchValue(body, key.body) : true;\n  });\n\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);\n  } // Match headers\n\n\n  matchedMockDispatches = matchedMockDispatches.filter(mockDispatch => matchHeaders(mockDispatch, key.headers));\n\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers}'`);\n  }\n\n  return matchedMockDispatches[0];\n}\n\nfunction addMockDispatch(mockDispatches, key, data) {\n  const baseData = {\n    times: null,\n    persist: false,\n    consumed: false\n  };\n  const replyData = typeof data === 'function' ? {\n    callback: data\n  } : { ...data\n  };\n  const newMockDispatch = { ...baseData,\n    ...key,\n    data: {\n      error: null,\n      ...replyData\n    }\n  };\n  mockDispatches.push(newMockDispatch);\n  return newMockDispatch;\n}\n\nfunction deleteMockDispatch(mockDispatches, key) {\n  const index = mockDispatches.findIndex(dispatch => {\n    if (!dispatch.consumed) {\n      return false;\n    }\n\n    return matchKey(dispatch, key);\n  });\n\n  if (index !== -1) {\n    mockDispatches.splice(index, 1);\n  }\n}\n\nfunction buildKey(opts) {\n  const {\n    path,\n    method,\n    body,\n    headers\n  } = opts;\n  return {\n    path,\n    method,\n    body,\n    headers\n  };\n}\n\nfunction generateKeyValues(data) {\n  return Object.entries(data).reduce((keyValuePairs, _ref6) => {\n    let [key, value] = _ref6;\n    return [...keyValuePairs, key, value];\n  }, []);\n}\n\nasync function getResponse(body) {\n  const buffers = [];\n\n  for await (const data of body) {\n    buffers.push(data);\n  }\n\n  return Buffer.concat(buffers).toString('utf8');\n}\n/**\n * Mock dispatch function used to simulate undici dispatches\n */\n\n\nfunction mockDispatch(opts, handler) {\n  // Get mock dispatch from built key\n  const key = buildKey(opts);\n  let mockDispatch = getMockDispatch(this[kDispatches], key); // Here's where we resolve a callback if a callback is present for the dispatch data.\n\n  if (mockDispatch.data.callback) {\n    mockDispatch.data = { ...mockDispatch.data,\n      ...mockDispatch.data.callback(opts)\n    };\n  } // Parse mockDispatch data\n\n\n  const {\n    data: {\n      statusCode,\n      data,\n      headers,\n      trailers,\n      error\n    },\n    delay,\n    persist\n  } = mockDispatch;\n  let {\n    times\n  } = mockDispatch;\n\n  if (typeof times === 'number' && times > 0) {\n    times = --mockDispatch.times;\n  } // If persist is true, skip\n  // Or if times is a number and > 0, skip\n  // Otherwise, mark as consumed\n\n\n  if (!(persist === true || typeof times === 'number' && times > 0)) {\n    mockDispatch.consumed = true;\n  } // If specified, trigger dispatch error\n\n\n  if (error !== null) {\n    deleteMockDispatch(this[kDispatches], key);\n    handler.onError(error);\n    return true;\n  } // Handle the request with a delay if necessary\n\n\n  if (typeof delay === 'number' && delay > 0) {\n    setTimeout(() => {\n      handleReply(this[kDispatches]);\n    }, delay);\n  } else {\n    handleReply(this[kDispatches]);\n  }\n\n  function handleReply(mockDispatches) {\n    const responseData = getResponseData(typeof data === 'function' ? data(opts) : data);\n    const responseHeaders = generateKeyValues(headers);\n    const responseTrailers = generateKeyValues(trailers);\n    handler.onHeaders(statusCode, responseHeaders, resume);\n    handler.onData(Buffer.from(responseData));\n    handler.onComplete(responseTrailers);\n    deleteMockDispatch(mockDispatches, key);\n  }\n\n  function resume() {}\n\n  return true;\n}\n\nfunction buildMockDispatch() {\n  const agent = this[kMockAgent];\n  const origin = this[kOrigin];\n  const originalDispatch = this[kOriginalDispatch];\n  return function dispatch(opts, handler) {\n    if (agent[kIsMockActive]) {\n      try {\n        mockDispatch.call(this, opts, handler);\n      } catch (error) {\n        if (error instanceof MockNotMatchedError) {\n          const netConnect = agent[kGetNetConnect]();\n\n          if (netConnect === false) {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);\n          }\n\n          if (checkNetConnect(netConnect, origin)) {\n            originalDispatch.call(this, opts, handler);\n          } else {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);\n          }\n        } else {\n          throw error;\n        }\n      }\n    } else {\n      originalDispatch.call(this, opts, handler);\n    }\n  };\n}\n\nfunction checkNetConnect(netConnect, origin) {\n  const url = new URL(origin);\n\n  if (netConnect === true) {\n    return true;\n  } else if (Array.isArray(netConnect) && netConnect.some(matcher => matchValue(matcher, url.host))) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction buildMockOptions(opts) {\n  if (opts) {\n    const {\n      agent,\n      ...mockOptions\n    } = opts;\n    return mockOptions;\n  }\n}\n\nmodule.exports = {\n  getResponseData,\n  getMockDispatch,\n  addMockDispatch,\n  deleteMockDispatch,\n  buildKey,\n  generateKeyValues,\n  matchValue,\n  getResponse,\n  mockDispatch,\n  buildMockDispatch,\n  checkNetConnect,\n  buildMockOptions\n};","map":{"version":3,"sources":["/Users/jake/workspace/token-builder/node_modules/undici/lib/mock/mock-utils.js"],"names":["MockNotMatchedError","require","kHeadersList","kDispatches","kMockAgent","kOriginalDispatch","kOrigin","kIsMockActive","kGetNetConnect","matchValue","match","value","RegExp","test","matchHeaders","mockDispatch","headers","matchHeaderName","matchHeaderValue","Object","entries","header","get","matchKey","path","method","body","pathMatch","methodMatch","bodyMatch","headersMatch","getResponseData","data","Buffer","isBuffer","JSON","stringify","toString","getMockDispatch","mockDispatches","key","matchedMockDispatches","filter","consumed","length","addMockDispatch","baseData","times","persist","replyData","callback","newMockDispatch","error","push","deleteMockDispatch","index","findIndex","dispatch","splice","buildKey","opts","generateKeyValues","reduce","keyValuePairs","getResponse","buffers","concat","handler","statusCode","trailers","delay","onError","setTimeout","handleReply","responseData","responseHeaders","responseTrailers","onHeaders","resume","onData","from","onComplete","buildMockDispatch","agent","origin","originalDispatch","call","netConnect","message","checkNetConnect","url","URL","Array","isArray","some","matcher","host","buildMockOptions","mockOptions","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { MockNotMatchedError } = require('./mock-errors')\nconst { kHeadersList } = require('../core/symbols')\nconst {\n  kDispatches,\n  kMockAgent,\n  kOriginalDispatch,\n  kOrigin,\n  kIsMockActive,\n  kGetNetConnect\n} = require('./mock-symbols')\n\nfunction matchValue (match, value) {\n  if (typeof match === 'string') {\n    return match === value\n  }\n  if (match instanceof RegExp) {\n    return match.test(value)\n  }\n  if (typeof match === 'function') {\n    return match(value) === true\n  }\n  return false\n}\n\nfunction matchHeaders (mockDispatch, headers) {\n  if (typeof mockDispatch.headers === 'undefined') {\n    return true\n  }\n  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {\n    return false\n  }\n\n  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {\n    const header = typeof headers.get === 'function' ? headers.get(matchHeaderName) : headers[matchHeaderName]\n\n    if (!matchValue(matchHeaderValue, header)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction matchKey (mockDispatch, { path, method, body, headers }) {\n  const pathMatch = matchValue(mockDispatch.path, path)\n  const methodMatch = matchValue(mockDispatch.method, method)\n  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true\n  const headersMatch = matchHeaders(mockDispatch, headers)\n  return pathMatch && methodMatch && bodyMatch && headersMatch\n}\n\nfunction getResponseData (data) {\n  if (Buffer.isBuffer(data)) {\n    return data\n  } else if (typeof data === 'object') {\n    return JSON.stringify(data)\n  } else {\n    return data.toString()\n  }\n}\n\nfunction getMockDispatch (mockDispatches, key) {\n  // Match path\n  let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(path, key.path))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for path '${key.path}'`)\n  }\n\n  // Match method\n  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`)\n  }\n\n  // Match body\n  matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true)\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`)\n  }\n\n  // Match headers\n  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers}'`)\n  }\n\n  return matchedMockDispatches[0]\n}\n\nfunction addMockDispatch (mockDispatches, key, data) {\n  const baseData = { times: null, persist: false, consumed: false }\n  const replyData = typeof data === 'function' ? { callback: data } : { ...data };\n  const newMockDispatch = { ...baseData, ...key, data: { error: null, ...replyData } }\n  mockDispatches.push(newMockDispatch)\n  return newMockDispatch\n}\n\nfunction deleteMockDispatch (mockDispatches, key) {\n  const index = mockDispatches.findIndex(dispatch => {\n    if (!dispatch.consumed) {\n      return false\n    }\n    return matchKey(dispatch, key)\n  })\n  if (index !== -1) {\n    mockDispatches.splice(index, 1)\n  }\n}\n\nfunction buildKey (opts) {\n  const { path, method, body, headers } = opts\n  return {\n    path,\n    method,\n    body,\n    headers\n  }\n}\n\nfunction generateKeyValues (data) {\n  return Object.entries(data).reduce((keyValuePairs, [key, value]) => [...keyValuePairs, key, value], [])\n}\n\nasync function getResponse (body) {\n  const buffers = []\n  for await (const data of body) {\n    buffers.push(data)\n  }\n  return Buffer.concat(buffers).toString('utf8')\n}\n\n/**\n * Mock dispatch function used to simulate undici dispatches\n */\nfunction mockDispatch (opts, handler) {\n  // Get mock dispatch from built key\n  const key = buildKey(opts)\n  let mockDispatch = getMockDispatch(this[kDispatches], key)\n\n  // Here's where we resolve a callback if a callback is present for the dispatch data.\n  if (mockDispatch.data.callback) {\n    mockDispatch.data = { ...mockDispatch.data, ...mockDispatch.data.callback(opts) }\n  }\n\n  // Parse mockDispatch data\n  const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch\n  let { times } = mockDispatch\n  if (typeof times === 'number' && times > 0) {\n    times = --mockDispatch.times\n  }\n\n  // If persist is true, skip\n  // Or if times is a number and > 0, skip\n  // Otherwise, mark as consumed\n\n  if (!(persist === true || (typeof times === 'number' && times > 0))) {\n    mockDispatch.consumed = true\n  }\n\n  // If specified, trigger dispatch error\n  if (error !== null) {\n    deleteMockDispatch(this[kDispatches], key)\n    handler.onError(error)\n    return true\n  }\n\n  // Handle the request with a delay if necessary\n  if (typeof delay === 'number' && delay > 0) {\n    setTimeout(() => {\n      handleReply(this[kDispatches])\n    }, delay)\n  } else {\n    handleReply(this[kDispatches])\n  }\n\n  function handleReply (mockDispatches) {\n    const responseData = getResponseData(typeof data === 'function' ? data(opts) : data);\n    const responseHeaders = generateKeyValues(headers)\n    const responseTrailers = generateKeyValues(trailers)\n\n    handler.onHeaders(statusCode, responseHeaders, resume)\n    handler.onData(Buffer.from(responseData))\n    handler.onComplete(responseTrailers)\n    deleteMockDispatch(mockDispatches, key)\n  }\n\n  function resume () {}\n\n  return true\n}\n\nfunction buildMockDispatch () {\n  const agent = this[kMockAgent]\n  const origin = this[kOrigin]\n  const originalDispatch = this[kOriginalDispatch]\n\n  return function dispatch (opts, handler) {\n    if (agent[kIsMockActive]) {\n      try {\n        mockDispatch.call(this, opts, handler)\n      } catch (error) {\n        if (error instanceof MockNotMatchedError) {\n          const netConnect = agent[kGetNetConnect]()\n          if (netConnect === false) {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)\n          }\n          if (checkNetConnect(netConnect, origin)) {\n            originalDispatch.call(this, opts, handler)\n          } else {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)\n          }\n        } else {\n          throw error\n        }\n      }\n    } else {\n      originalDispatch.call(this, opts, handler)\n    }\n  }\n}\n\nfunction checkNetConnect (netConnect, origin) {\n  const url = new URL(origin)\n  if (netConnect === true) {\n    return true\n  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {\n    return true\n  }\n  return false\n}\n\nfunction buildMockOptions (opts) {\n  if (opts) {\n    const { agent, ...mockOptions } = opts\n    return mockOptions\n  }\n}\n\nmodule.exports = {\n  getResponseData,\n  getMockDispatch,\n  addMockDispatch,\n  deleteMockDispatch,\n  buildKey,\n  generateKeyValues,\n  matchValue,\n  getResponse,\n  mockDispatch,\n  buildMockDispatch,\n  checkNetConnect,\n  buildMockOptions\n}\n"]},"metadata":{},"sourceType":"script"}