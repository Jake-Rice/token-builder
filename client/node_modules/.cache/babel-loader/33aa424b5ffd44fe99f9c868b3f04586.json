{"ast":null,"code":"'use strict';\n\nconst {\n  Readable,\n  Duplex,\n  PassThrough\n} = require('stream');\n\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = require('../core/errors');\n\nconst util = require('../core/util');\n\nconst {\n  AsyncResource\n} = require('async_hooks');\n\nconst {\n  addSignal,\n  removeSignal\n} = require('./abort-signal');\n\nconst assert = require('assert');\n\nconst kResume = Symbol('resume');\n\nclass PipelineRequest extends Readable {\n  constructor() {\n    super({\n      autoDestroy: true\n    });\n    this[kResume] = null;\n  }\n\n  _read() {\n    const {\n      [kResume]: resume\n    } = this;\n\n    if (resume) {\n      this[kResume] = null;\n      resume();\n    }\n  }\n\n  _destroy(err, callback) {\n    this._read();\n\n    callback(err);\n  }\n\n}\n\nclass PipelineResponse extends Readable {\n  constructor(resume) {\n    super({\n      autoDestroy: true\n    });\n    this[kResume] = resume;\n  }\n\n  _read() {\n    this[kResume]();\n  }\n\n  _destroy(err, callback) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError();\n    }\n\n    callback(err);\n  }\n\n}\n\nclass PipelineHandler extends AsyncResource {\n  constructor(opts, handler) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts');\n    }\n\n    if (typeof handler !== 'function') {\n      throw new InvalidArgumentError('invalid handler');\n    }\n\n    const {\n      signal,\n      method,\n      opaque,\n      onInfo,\n      responseHeaders\n    } = opts;\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n    }\n\n    if (method === 'CONNECT') {\n      throw new InvalidArgumentError('invalid method');\n    }\n\n    if (onInfo && typeof onInfo !== 'function') {\n      throw new InvalidArgumentError('invalid onInfo callback');\n    }\n\n    super('UNDICI_PIPELINE');\n    this.opaque = opaque || null;\n    this.responseHeaders = responseHeaders || null;\n    this.handler = handler;\n    this.abort = null;\n    this.context = null;\n    this.onInfo = onInfo || null;\n    this.req = new PipelineRequest().on('error', util.nop);\n    this.ret = new Duplex({\n      readableObjectMode: opts.objectMode,\n      autoDestroy: true,\n      read: () => {\n        const {\n          body\n        } = this;\n\n        if (body && body.resume) {\n          body.resume();\n        }\n      },\n      write: (chunk, encoding, callback) => {\n        const {\n          req\n        } = this;\n\n        if (req.push(chunk, encoding) || req._readableState.destroyed) {\n          callback();\n        } else {\n          req[kResume] = callback;\n        }\n      },\n      destroy: (err, callback) => {\n        const {\n          body,\n          req,\n          res,\n          ret,\n          abort\n        } = this;\n\n        if (!err && !ret._readableState.endEmitted) {\n          err = new RequestAbortedError();\n        }\n\n        if (abort && err) {\n          abort();\n        }\n\n        util.destroy(body, err);\n        util.destroy(req, err);\n        util.destroy(res, err);\n        removeSignal(this);\n        callback(err);\n      }\n    }).on('prefinish', () => {\n      const {\n        req\n      } = this; // Node < 15 does not call _final in same tick.\n\n      req.push(null);\n    });\n    this.res = null;\n    addSignal(this, signal);\n  }\n\n  onConnect(abort, context) {\n    const {\n      ret,\n      res\n    } = this;\n    assert(!res, 'pipeline cannot be retried');\n\n    if (ret.destroyed) {\n      throw new RequestAbortedError();\n    }\n\n    this.abort = abort;\n    this.context = context;\n  }\n\n  onHeaders(statusCode, rawHeaders, resume) {\n    const {\n      opaque,\n      handler,\n      context\n    } = this;\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        this.onInfo({\n          statusCode,\n          headers\n        });\n      }\n\n      return;\n    }\n\n    this.res = new PipelineResponse(resume);\n    let body;\n\n    try {\n      this.handler = null;\n      const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n      body = this.runInAsyncScope(handler, null, {\n        statusCode,\n        headers,\n        opaque,\n        body: this.res,\n        context\n      });\n    } catch (err) {\n      this.res.on('error', util.nop);\n      throw err;\n    }\n\n    if (!body || typeof body.on !== 'function') {\n      throw new InvalidReturnValueError('expected Readable');\n    }\n\n    body.on('data', chunk => {\n      const {\n        ret,\n        body\n      } = this;\n\n      if (!ret.push(chunk) && body.pause) {\n        body.pause();\n      }\n    }).on('error', err => {\n      const {\n        ret\n      } = this;\n      util.destroy(ret, err);\n    }).on('end', () => {\n      const {\n        ret\n      } = this;\n      ret.push(null);\n    }).on('close', () => {\n      const {\n        ret\n      } = this;\n\n      if (!ret._readableState.ended) {\n        util.destroy(ret, new RequestAbortedError());\n      }\n    });\n    this.body = body;\n  }\n\n  onData(chunk) {\n    const {\n      res\n    } = this;\n    return res.push(chunk);\n  }\n\n  onComplete(trailers) {\n    const {\n      res\n    } = this;\n    res.push(null);\n  }\n\n  onError(err) {\n    const {\n      ret\n    } = this;\n    this.handler = null;\n    util.destroy(ret, err);\n  }\n\n}\n\nfunction pipeline(opts, handler) {\n  try {\n    const pipelineHandler = new PipelineHandler(opts, handler);\n    this.dispatch({ ...opts,\n      body: pipelineHandler.req\n    }, pipelineHandler);\n    return pipelineHandler.ret;\n  } catch (err) {\n    return new PassThrough().destroy(err);\n  }\n}\n\nmodule.exports = pipeline;","map":{"version":3,"sources":["/Users/jake/workspace/token-builder/node_modules/undici/lib/api/api-pipeline.js"],"names":["Readable","Duplex","PassThrough","require","InvalidArgumentError","InvalidReturnValueError","RequestAbortedError","util","AsyncResource","addSignal","removeSignal","assert","kResume","Symbol","PipelineRequest","constructor","autoDestroy","_read","resume","_destroy","err","callback","PipelineResponse","_readableState","endEmitted","PipelineHandler","opts","handler","signal","method","opaque","onInfo","responseHeaders","on","addEventListener","abort","context","req","nop","ret","readableObjectMode","objectMode","read","body","write","chunk","encoding","push","destroyed","destroy","res","onConnect","onHeaders","statusCode","rawHeaders","headers","parseRawHeaders","parseHeaders","runInAsyncScope","pause","ended","onData","onComplete","trailers","onError","pipeline","pipelineHandler","dispatch","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst {\n  Readable,\n  Duplex,\n  PassThrough\n} = require('stream')\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = require('../core/errors')\nconst util = require('../core/util')\nconst { AsyncResource } = require('async_hooks')\nconst { addSignal, removeSignal } = require('./abort-signal')\nconst assert = require('assert')\n\nconst kResume = Symbol('resume')\n\nclass PipelineRequest extends Readable {\n  constructor () {\n    super({ autoDestroy: true })\n\n    this[kResume] = null\n  }\n\n  _read () {\n    const { [kResume]: resume } = this\n\n    if (resume) {\n      this[kResume] = null\n      resume()\n    }\n  }\n\n  _destroy (err, callback) {\n    this._read()\n\n    callback(err)\n  }\n}\n\nclass PipelineResponse extends Readable {\n  constructor (resume) {\n    super({ autoDestroy: true })\n    this[kResume] = resume\n  }\n\n  _read () {\n    this[kResume]()\n  }\n\n  _destroy (err, callback) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    callback(err)\n  }\n}\n\nclass PipelineHandler extends AsyncResource {\n  constructor (opts, handler) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof handler !== 'function') {\n      throw new InvalidArgumentError('invalid handler')\n    }\n\n    const { signal, method, opaque, onInfo, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    if (method === 'CONNECT') {\n      throw new InvalidArgumentError('invalid method')\n    }\n\n    if (onInfo && typeof onInfo !== 'function') {\n      throw new InvalidArgumentError('invalid onInfo callback')\n    }\n\n    super('UNDICI_PIPELINE')\n\n    this.opaque = opaque || null\n    this.responseHeaders = responseHeaders || null\n    this.handler = handler\n    this.abort = null\n    this.context = null\n    this.onInfo = onInfo || null\n\n    this.req = new PipelineRequest().on('error', util.nop)\n\n    this.ret = new Duplex({\n      readableObjectMode: opts.objectMode,\n      autoDestroy: true,\n      read: () => {\n        const { body } = this\n\n        if (body && body.resume) {\n          body.resume()\n        }\n      },\n      write: (chunk, encoding, callback) => {\n        const { req } = this\n\n        if (req.push(chunk, encoding) || req._readableState.destroyed) {\n          callback()\n        } else {\n          req[kResume] = callback\n        }\n      },\n      destroy: (err, callback) => {\n        const { body, req, res, ret, abort } = this\n\n        if (!err && !ret._readableState.endEmitted) {\n          err = new RequestAbortedError()\n        }\n\n        if (abort && err) {\n          abort()\n        }\n\n        util.destroy(body, err)\n        util.destroy(req, err)\n        util.destroy(res, err)\n\n        removeSignal(this)\n\n        callback(err)\n      }\n    }).on('prefinish', () => {\n      const { req } = this\n\n      // Node < 15 does not call _final in same tick.\n      req.push(null)\n    })\n\n    this.res = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    const { ret, res } = this\n\n    assert(!res, 'pipeline cannot be retried')\n\n    if (ret.destroyed) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume) {\n    const { opaque, handler, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.res = new PipelineResponse(resume)\n\n    let body\n    try {\n      this.handler = null\n      const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n      body = this.runInAsyncScope(handler, null, {\n        statusCode,\n        headers,\n        opaque,\n        body: this.res,\n        context\n      })\n    } catch (err) {\n      this.res.on('error', util.nop)\n      throw err\n    }\n\n    if (!body || typeof body.on !== 'function') {\n      throw new InvalidReturnValueError('expected Readable')\n    }\n\n    body\n      .on('data', (chunk) => {\n        const { ret, body } = this\n\n        if (!ret.push(chunk) && body.pause) {\n          body.pause()\n        }\n      })\n      .on('error', (err) => {\n        const { ret } = this\n\n        util.destroy(ret, err)\n      })\n      .on('end', () => {\n        const { ret } = this\n\n        ret.push(null)\n      })\n      .on('close', () => {\n        const { ret } = this\n\n        if (!ret._readableState.ended) {\n          util.destroy(ret, new RequestAbortedError())\n        }\n      })\n\n    this.body = body\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n    res.push(null)\n  }\n\n  onError (err) {\n    const { ret } = this\n    this.handler = null\n    util.destroy(ret, err)\n  }\n}\n\nfunction pipeline (opts, handler) {\n  try {\n    const pipelineHandler = new PipelineHandler(opts, handler)\n    this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler)\n    return pipelineHandler.ret\n  } catch (err) {\n    return new PassThrough().destroy(err)\n  }\n}\n\nmodule.exports = pipeline\n"]},"metadata":{},"sourceType":"script"}