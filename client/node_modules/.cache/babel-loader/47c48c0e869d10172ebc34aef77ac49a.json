{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.instructionToCallstackStackTraceEntry = exports.ErrorInferrer = void 0;\n\nconst exceptions_1 = require(\"@ethereumjs/vm/dist/exceptions\");\n\nconst abi_1 = require(\"@ethersproject/abi\");\n\nconst semver_1 = __importDefault(require(\"semver\"));\n\nconst abi_helpers_1 = require(\"../../util/abi-helpers\");\n\nconst return_data_1 = require(\"../provider/return-data\");\n\nconst message_trace_1 = require(\"./message-trace\");\n\nconst model_1 = require(\"./model\");\n\nconst opcodes_1 = require(\"./opcodes\");\n\nconst solidity_stack_trace_1 = require(\"./solidity-stack-trace\");\n\nconst FIRST_SOLC_VERSION_CREATE_PARAMS_VALIDATION = \"0.5.9\";\nconst FIRST_SOLC_VERSION_RECEIVE_FUNCTION = \"0.6.0\";\nconst FIRST_SOLC_VERSION_WITH_UNMAPPED_REVERTS = \"0.6.3\";\nconst EIP170_BYTECODE_SIZE_INCLUSIVE_LIMIT = 0x6000;\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\n\nclass ErrorInferrer {\n  inferBeforeTracingCallMessage(trace) {\n    if (this._isDirectLibraryCall(trace)) {\n      return this._getDirectLibraryCallErrorStackTrace(trace);\n    }\n\n    const calledFunction = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n\n    if (this._isFunctionNotPayableError(trace, calledFunction)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.FUNCTION_NOT_PAYABLE_ERROR,\n        sourceReference: this._getFunctionStartSourceReference(trace, calledFunction),\n        value: trace.value\n      }];\n    }\n\n    if (this._isMissingFunctionAndFallbackError(trace, calledFunction)) {\n      if (this._emptyCalldataAndNoReceive(trace)) {\n        return [{\n          type: solidity_stack_trace_1.StackTraceEntryType.MISSING_FALLBACK_OR_RECEIVE_ERROR,\n          sourceReference: this._getContractStartWithoutFunctionSourceReference(trace)\n        }];\n      }\n\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_FUNCTION_WITHOUT_FALLBACK_ERROR,\n        sourceReference: this._getContractStartWithoutFunctionSourceReference(trace)\n      }];\n    }\n\n    if (this._isFallbackNotPayableError(trace, calledFunction)) {\n      if (this._emptyCalldataAndNoReceive(trace)) {\n        return [{\n          type: solidity_stack_trace_1.StackTraceEntryType.FALLBACK_NOT_PAYABLE_AND_NO_RECEIVE_ERROR,\n          sourceReference: this._getFallbackStartSourceReference(trace),\n          value: trace.value\n        }];\n      }\n\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.FALLBACK_NOT_PAYABLE_ERROR,\n        sourceReference: this._getFallbackStartSourceReference(trace),\n        value: trace.value\n      }];\n    }\n  }\n\n  inferBeforeTracingCreateMessage(trace) {\n    if (this._isConstructorNotPayableError(trace)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.FUNCTION_NOT_PAYABLE_ERROR,\n        sourceReference: this._getConstructorStartSourceReference(trace),\n        value: trace.value\n      }];\n    }\n\n    if (this._isConstructorInvalidArgumentsError(trace)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n        sourceReference: this._getConstructorStartSourceReference(trace)\n      }];\n    }\n  }\n\n  inferAfterTracing(trace, stacktrace, functionJumpdests, jumpedIntoFunction, lastSubmessageData) {\n    var _a, _b, _c, _d, _e, _f;\n\n    return (_f = (_e = (_d = (_c = (_b = (_a = this._checkLastSubmessage(trace, stacktrace, lastSubmessageData)) !== null && _a !== void 0 ? _a : this._checkFailedLastCall(trace, stacktrace)) !== null && _b !== void 0 ? _b : this._checkLastInstruction(trace, stacktrace, functionJumpdests, jumpedIntoFunction)) !== null && _c !== void 0 ? _c : this._checkNonContractCalled(trace, stacktrace)) !== null && _d !== void 0 ? _d : this._checkSolidity063UnmappedRevert(trace, stacktrace)) !== null && _e !== void 0 ? _e : this._checkContractTooLarge(trace)) !== null && _f !== void 0 ? _f : this._otherExecutionErrorStacktrace(trace, stacktrace);\n  }\n\n  filterRedundantFrames(stacktrace) {\n    return stacktrace.filter((frame, i) => {\n      if (i + 1 === stacktrace.length) {\n        return true;\n      }\n\n      const nextFrame = stacktrace[i + 1]; // we can only filter frames if we know their sourceReference\n      // and the one from the next frame\n\n      if (frame.sourceReference === undefined || nextFrame.sourceReference === undefined) {\n        return true;\n      } // look TWO frames ahead to determine if this is a specific occurrence of\n      // a redundant CALLSTACK_ENTRY frame observed when using Solidity 0.8.5:\n\n\n      if (frame.type === solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY && i + 2 < stacktrace.length && stacktrace[i + 2].sourceReference !== undefined && stacktrace[i + 2].type === solidity_stack_trace_1.StackTraceEntryType.RETURNDATA_SIZE_ERROR) {\n        // ! below for tsc. we confirmed existence in the enclosing conditional.\n        const thatSrcRef = stacktrace[i + 2].sourceReference;\n\n        if (frame.sourceReference.range[0] === thatSrcRef.range[0] && frame.sourceReference.range[1] === thatSrcRef.range[1] && frame.sourceReference.line === thatSrcRef.line) {\n          return false;\n        }\n      } // constructors contain the whole contract, so we ignore them\n\n\n      if (frame.sourceReference.function === \"constructor\" && nextFrame.sourceReference.function !== \"constructor\") {\n        return true;\n      } // this is probably a recursive call\n\n\n      if (i > 0 && frame.type === nextFrame.type && frame.sourceReference.range[0] === nextFrame.sourceReference.range[0] && frame.sourceReference.range[1] === nextFrame.sourceReference.range[1] && frame.sourceReference.line === nextFrame.sourceReference.line) {\n        return true;\n      }\n\n      if (frame.sourceReference.range[0] <= nextFrame.sourceReference.range[0] && frame.sourceReference.range[1] >= nextFrame.sourceReference.range[1]) {\n        return false;\n      }\n\n      return true;\n    });\n  } // Heuristics\n\n  /**\n   * Check if the last submessage can be used to generate the stack trace.\n   */\n\n\n  _checkLastSubmessage(trace, stacktrace, lastSubmessageData) {\n    if (lastSubmessageData === undefined) {\n      return undefined;\n    }\n\n    const inferredStacktrace = [...stacktrace]; // get the instruction before the submessage and add it to the stack trace\n\n    const callStep = trace.steps[lastSubmessageData.stepIndex - 1];\n\n    if (!(0, message_trace_1.isEvmStep)(callStep)) {\n      throw new Error(\"This should not happen: MessageTrace should be preceded by a EVM step\");\n    }\n\n    const callInst = trace.bytecode.getInstruction(callStep.pc);\n    const callStackFrame = instructionToCallstackStackTraceEntry(trace.bytecode, callInst);\n    const lastMessageFailed = lastSubmessageData.messageTrace.error !== undefined;\n\n    if (lastMessageFailed) {\n      // add the call/create that generated the message to the stack trace\n      inferredStacktrace.push(callStackFrame);\n\n      if (this._isSubtraceErrorPropagated(trace, lastSubmessageData.stepIndex) || this._isProxyErrorPropagated(trace, lastSubmessageData.stepIndex)) {\n        inferredStacktrace.push(...lastSubmessageData.stacktrace);\n\n        if (this._isContractCallRunOutOfGasError(trace, lastSubmessageData.stepIndex)) {\n          const lastFrame = inferredStacktrace.pop();\n          inferredStacktrace.push({\n            type: solidity_stack_trace_1.StackTraceEntryType.CONTRACT_CALL_RUN_OUT_OF_GAS_ERROR,\n            sourceReference: lastFrame.sourceReference\n          });\n        }\n\n        return this._fixInitialModifier(trace, inferredStacktrace);\n      }\n    } else {\n      const isReturnDataSizeError = this._failsRightAfterCall(trace, lastSubmessageData.stepIndex);\n\n      if (isReturnDataSizeError) {\n        inferredStacktrace.push({\n          type: solidity_stack_trace_1.StackTraceEntryType.RETURNDATA_SIZE_ERROR,\n          sourceReference: callStackFrame.sourceReference\n        });\n        return this._fixInitialModifier(trace, inferredStacktrace);\n      }\n    }\n  }\n  /**\n   * Check if the last call/create that was done failed.\n   */\n\n\n  _checkFailedLastCall(trace, stacktrace) {\n    for (let stepIndex = trace.steps.length - 2; stepIndex >= 0; stepIndex--) {\n      const step = trace.steps[stepIndex];\n      const nextStep = trace.steps[stepIndex + 1];\n\n      if (!(0, message_trace_1.isEvmStep)(step)) {\n        return;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n      const isCallOrCreate = (0, opcodes_1.isCall)(inst.opcode) || (0, opcodes_1.isCreate)(inst.opcode);\n\n      if (isCallOrCreate && (0, message_trace_1.isEvmStep)(nextStep)) {\n        if (this._isCallFailedError(trace, stepIndex, inst)) {\n          const inferredStacktrace = [...stacktrace, this._callInstructionToCallFailedToExecuteStackTraceEntry(trace.bytecode, inst)];\n          return this._fixInitialModifier(trace, inferredStacktrace);\n        }\n      }\n    }\n  }\n  /**\n   * Check if the execution stopped with a revert or an invalid opcode.\n   */\n\n\n  _checkRevertOrInvalidOpcode(trace, stacktrace, lastInstruction, functionJumpdests, jumpedIntoFunction) {\n    var _a;\n\n    if (lastInstruction.opcode !== opcodes_1.Opcode.REVERT && lastInstruction.opcode !== opcodes_1.Opcode.INVALID) {\n      return;\n    }\n\n    const inferredStacktrace = [...stacktrace];\n\n    if (lastInstruction.location !== undefined && (!(0, message_trace_1.isDecodedCallTrace)(trace) || jumpedIntoFunction)) {\n      // There should always be a function here, but that's not the case with optimizations.\n      //\n      // If this is a create trace, we already checked args and nonpayable failures before\n      // calling this function.\n      //\n      // If it's a call trace, we already jumped into a function. But optimizations can happen.\n      const failingFunction = lastInstruction.location.getContainingFunction(); // If the failure is in a modifier we add an entry with the function/constructor\n\n      if (failingFunction !== undefined && failingFunction.type === model_1.ContractFunctionType.MODIFIER) {\n        inferredStacktrace.push(this._getEntryBeforeFailureInModifier(trace, functionJumpdests));\n      }\n    }\n\n    const panicStacktrace = this._checkPanic(trace, inferredStacktrace, lastInstruction);\n\n    if (panicStacktrace !== undefined) {\n      return panicStacktrace;\n    }\n\n    const customErrorStacktrace = this._checkCustomErrors(trace, inferredStacktrace, lastInstruction);\n\n    if (customErrorStacktrace !== undefined) {\n      return customErrorStacktrace;\n    }\n\n    if (lastInstruction.location !== undefined && (!(0, message_trace_1.isDecodedCallTrace)(trace) || jumpedIntoFunction)) {\n      const failingFunction = lastInstruction.location.getContainingFunction();\n\n      if (failingFunction !== undefined) {\n        inferredStacktrace.push(this._instructionWithinFunctionToRevertStackTraceEntry(trace, lastInstruction));\n      } else if ((0, message_trace_1.isDecodedCallTrace)(trace)) {\n        // This is here because of the optimizations\n        inferredStacktrace.push({\n          type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n          sourceReference: this._getFunctionStartSourceReference(trace, trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4))),\n          message: new return_data_1.ReturnData(trace.returnData),\n          isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID\n        });\n      } else {\n        // This is here because of the optimizations\n        inferredStacktrace.push({\n          type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n          sourceReference: this._getConstructorStartSourceReference(trace),\n          message: new return_data_1.ReturnData(trace.returnData),\n          isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID\n        });\n      }\n\n      return this._fixInitialModifier(trace, inferredStacktrace);\n    } // If the revert instruction is not mapped but there is return data,\n    // we add the frame anyway, sith the best sourceReference we can get\n\n\n    if (lastInstruction.location === undefined && trace.returnData.length > 0) {\n      const revertFrame = {\n        type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n        sourceReference: (_a = this._getLastSourceReference(trace)) !== null && _a !== void 0 ? _a : this._getContractStartWithoutFunctionSourceReference(trace),\n        message: new return_data_1.ReturnData(trace.returnData),\n        isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID\n      };\n      inferredStacktrace.push(revertFrame);\n      return this._fixInitialModifier(trace, inferredStacktrace);\n    }\n  }\n  /**\n   * Check if the trace reverted with a panic error.\n   */\n\n\n  _checkPanic(trace, stacktrace, lastInstruction) {\n    if (!this._isPanicReturnData(trace.returnData)) {\n      return;\n    } // If the last frame is an internal function, it means that the trace\n    // jumped there to return the panic. If that's the case, we remove that\n    // frame.\n\n\n    const lastFrame = stacktrace[stacktrace.length - 1];\n\n    if ((lastFrame === null || lastFrame === void 0 ? void 0 : lastFrame.type) === solidity_stack_trace_1.StackTraceEntryType.INTERNAL_FUNCTION_CALLSTACK_ENTRY) {\n      stacktrace.splice(-1);\n    }\n\n    const panicReturnData = new return_data_1.ReturnData(trace.returnData);\n    const errorCode = panicReturnData.decodePanic(); // if the error comes from a call to a zero-initialized function,\n    // we remove the last frame, which represents the call, to avoid\n    // having duplicated frames\n\n    if (errorCode.eqn(0x51)) {\n      stacktrace.splice(-1);\n    }\n\n    const inferredStacktrace = [...stacktrace];\n    inferredStacktrace.push(this._instructionWithinFunctionToPanicStackTraceEntry(trace, lastInstruction, errorCode));\n    return this._fixInitialModifier(trace, inferredStacktrace);\n  }\n\n  _checkCustomErrors(trace, stacktrace, lastInstruction) {\n    const returnData = new return_data_1.ReturnData(trace.returnData);\n\n    if (returnData.isEmpty() || returnData.isErrorReturnData()) {\n      // if there is no return data, or if it's a Error(string),\n      // then it can't be a custom error\n      return;\n    }\n\n    let errorMessage = \"reverted with an unrecognized custom error\";\n\n    for (const customError of trace.bytecode.contract.customErrors) {\n      if (returnData.matchesSelector(customError.selector)) {\n        // if the return data matches a custom error in the called contract,\n        // we format the message using the returnData and the custom error instance\n        const decodedValues = abi_1.defaultAbiCoder.decode(customError.paramTypes, returnData.value.slice(4));\n        const params = abi_helpers_1.AbiHelpers.formatValues([...decodedValues]);\n        errorMessage = `reverted with custom error '${customError.name}(${params})'`;\n        break;\n      }\n    }\n\n    const inferredStacktrace = [...stacktrace];\n    inferredStacktrace.push(this._instructionWithinFunctionToCustomErrorStackTraceEntry(trace, lastInstruction, errorMessage));\n    return this._fixInitialModifier(trace, inferredStacktrace);\n  }\n  /**\n   * Check last instruction to try to infer the error.\n   */\n\n\n  _checkLastInstruction(trace, stacktrace, functionJumpdests, jumpedIntoFunction) {\n    const lastStep = trace.steps[trace.steps.length - 1];\n\n    if (!(0, message_trace_1.isEvmStep)(lastStep)) {\n      throw new Error(\"This should not happen: MessageTrace ends with a subtrace\");\n    }\n\n    const lastInstruction = trace.bytecode.getInstruction(lastStep.pc);\n\n    const revertOrInvalidStacktrace = this._checkRevertOrInvalidOpcode(trace, stacktrace, lastInstruction, functionJumpdests, jumpedIntoFunction);\n\n    if (revertOrInvalidStacktrace !== undefined) {\n      return revertOrInvalidStacktrace;\n    }\n\n    if ((0, message_trace_1.isDecodedCallTrace)(trace) && !jumpedIntoFunction) {\n      if (this._hasFailedInsideTheFallbackFunction(trace) || this._hasFailedInsideTheReceiveFunction(trace)) {\n        return [this._instructionWithinFunctionToRevertStackTraceEntry(trace, lastInstruction)];\n      } // Sometimes we do fail inside of a function but there's no jump into\n\n\n      if (lastInstruction.location !== undefined) {\n        const failingFunction = lastInstruction.location.getContainingFunction();\n\n        if (failingFunction !== undefined) {\n          return [{\n            type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n            sourceReference: this._getFunctionStartSourceReference(trace, failingFunction),\n            message: new return_data_1.ReturnData(trace.returnData),\n            isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID\n          }];\n        }\n      }\n\n      const calledFunction = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n\n      if (calledFunction !== undefined) {\n        return [{\n          type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n          sourceReference: this._getFunctionStartSourceReference(trace, calledFunction)\n        }];\n      }\n\n      if (this._solidity063MaybeUnmappedRevert(trace)) {\n        const revertFrame = this._solidity063GetFrameForUnmappedRevertBeforeFunction(trace);\n\n        if (revertFrame !== undefined) {\n          return [revertFrame];\n        }\n      }\n\n      return [this._getOtherErrorBeforeCalledFunctionStackTraceEntry(trace)];\n    }\n  }\n\n  _checkNonContractCalled(trace, stacktrace) {\n    if (this._isCalledNonContractAccountError(trace)) {\n      const nonContractCalledFrame = {\n        type: solidity_stack_trace_1.StackTraceEntryType.NONCONTRACT_ACCOUNT_CALLED_ERROR,\n        // We are sure this is not undefined because there was at least a call instruction\n        sourceReference: this._getLastSourceReference(trace)\n      };\n      return [...stacktrace, nonContractCalledFrame];\n    }\n  }\n\n  _checkSolidity063UnmappedRevert(trace, stacktrace) {\n    if (this._solidity063MaybeUnmappedRevert(trace)) {\n      const revertFrame = this._solidity063GetFrameForUnmappedRevertWithinFunction(trace);\n\n      if (revertFrame !== undefined) {\n        return [...stacktrace, revertFrame];\n      }\n    }\n  }\n\n  _checkContractTooLarge(trace) {\n    if ((0, message_trace_1.isCreateTrace)(trace) && this._isContractTooLargeError(trace)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.CONTRACT_TOO_LARGE_ERROR,\n        sourceReference: this._getConstructorStartSourceReference(trace)\n      }];\n    }\n  }\n\n  _otherExecutionErrorStacktrace(trace, stacktrace) {\n    const otherExecutionErrorFrame = {\n      type: solidity_stack_trace_1.StackTraceEntryType.OTHER_EXECUTION_ERROR,\n      sourceReference: this._getLastSourceReference(trace)\n    };\n    return [...stacktrace, otherExecutionErrorFrame];\n  } // Helpers\n\n\n  _fixInitialModifier(trace, stacktrace) {\n    const firstEntry = stacktrace[0];\n\n    if (firstEntry !== undefined && firstEntry.type === solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY && firstEntry.functionType === model_1.ContractFunctionType.MODIFIER) {\n      return [this._getEntryBeforeInitialModifierCallstackEntry(trace), ...stacktrace];\n    }\n\n    return stacktrace;\n  }\n\n  _isDirectLibraryCall(trace) {\n    return trace.depth === 0 && trace.bytecode.contract.type === model_1.ContractType.LIBRARY;\n  }\n\n  _getDirectLibraryCallErrorStackTrace(trace) {\n    const func = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n\n    if (func !== undefined) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.DIRECT_LIBRARY_CALL_ERROR,\n        sourceReference: this._getFunctionStartSourceReference(trace, func)\n      }];\n    }\n\n    return [{\n      type: solidity_stack_trace_1.StackTraceEntryType.DIRECT_LIBRARY_CALL_ERROR,\n      sourceReference: this._getContractStartWithoutFunctionSourceReference(trace)\n    }];\n  }\n\n  _isFunctionNotPayableError(trace, calledFunction) {\n    if (calledFunction === undefined) {\n      return false;\n    } // This error doesn't return data\n\n\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    if (trace.value.lten(0)) {\n      return false;\n    } // Libraries don't have a nonpayable check\n\n\n    if (trace.bytecode.contract.type === model_1.ContractType.LIBRARY) {\n      return false;\n    }\n\n    return calledFunction.isPayable === undefined || !calledFunction.isPayable;\n  }\n\n  _getFunctionStartSourceReference(trace, func) {\n    return {\n      sourceName: func.location.file.sourceName,\n      sourceContent: func.location.file.content,\n      contract: trace.bytecode.contract.name,\n      function: func.name,\n      line: func.location.getStartingLineNumber(),\n      range: [func.location.offset, func.location.offset + func.location.length]\n    };\n  }\n\n  _isMissingFunctionAndFallbackError(trace, calledFunction) {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    } // the called function exists in the contract\n\n\n    if (calledFunction !== undefined) {\n      return false;\n    } // there's a receive function and no calldata\n\n\n    if (trace.calldata.length === 0 && trace.bytecode.contract.receive !== undefined) {\n      return false;\n    }\n\n    return trace.bytecode.contract.fallback === undefined;\n  }\n\n  _emptyCalldataAndNoReceive(trace) {\n    // this only makes sense when receive functions are available\n    if (semver_1.default.lt(trace.bytecode.compilerVersion, FIRST_SOLC_VERSION_RECEIVE_FUNCTION)) {\n      return false;\n    }\n\n    return trace.calldata.length === 0 && trace.bytecode.contract.receive === undefined;\n  }\n\n  _getContractStartWithoutFunctionSourceReference(trace) {\n    const location = trace.bytecode.contract.location;\n    return {\n      sourceName: location.file.sourceName,\n      sourceContent: location.file.content,\n      contract: trace.bytecode.contract.name,\n      line: location.getStartingLineNumber(),\n      range: [location.offset, location.offset + location.length]\n    };\n  }\n\n  _isFallbackNotPayableError(trace, calledFunction) {\n    if (calledFunction !== undefined) {\n      return false;\n    } // This error doesn't return data\n\n\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    if (trace.value.lten(0)) {\n      return false;\n    }\n\n    if (trace.bytecode.contract.fallback === undefined) {\n      return false;\n    }\n\n    const isPayable = trace.bytecode.contract.fallback.isPayable;\n    return isPayable === undefined || !isPayable;\n  }\n\n  _getFallbackStartSourceReference(trace) {\n    const func = trace.bytecode.contract.fallback;\n\n    if (func === undefined) {\n      throw new Error(\"This shouldn't happen: trying to get fallback source reference from a contract without fallback\");\n    }\n\n    return {\n      sourceName: func.location.file.sourceName,\n      sourceContent: func.location.file.content,\n      contract: trace.bytecode.contract.name,\n      function: solidity_stack_trace_1.FALLBACK_FUNCTION_NAME,\n      line: func.location.getStartingLineNumber(),\n      range: [func.location.offset, func.location.offset + func.location.length]\n    };\n  }\n\n  _isConstructorNotPayableError(trace) {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    const constructor = trace.bytecode.contract.constructorFunction; // This function is only matters with contracts that have constructors defined. The ones that\n    // don't are abstract contracts, or their constructor doesn't take any argument.\n\n    if (constructor === undefined) {\n      return false;\n    }\n\n    return trace.value.gtn(0) && (constructor.isPayable === undefined || !constructor.isPayable);\n  }\n  /**\n   * Returns a source reference pointing to the constructor if it exists, or to the contract\n   * otherwise.\n   */\n\n\n  _getConstructorStartSourceReference(trace) {\n    const contract = trace.bytecode.contract;\n    const constructor = contract.constructorFunction;\n    const line = constructor !== undefined ? constructor.location.getStartingLineNumber() : contract.location.getStartingLineNumber();\n    return {\n      sourceName: contract.location.file.sourceName,\n      sourceContent: contract.location.file.content,\n      contract: contract.name,\n      function: solidity_stack_trace_1.CONSTRUCTOR_FUNCTION_NAME,\n      line,\n      range: [contract.location.offset, contract.location.offset + contract.location.length]\n    };\n  }\n\n  _isConstructorInvalidArgumentsError(trace) {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    const contract = trace.bytecode.contract;\n    const constructor = contract.constructorFunction; // This function is only matters with contracts that have constructors defined. The ones that\n    // don't are abstract contracts, or their constructor doesn't take any argument.\n\n    if (constructor === undefined) {\n      return false;\n    }\n\n    if (semver_1.default.lt(trace.bytecode.compilerVersion, FIRST_SOLC_VERSION_CREATE_PARAMS_VALIDATION)) {\n      return false;\n    }\n\n    const lastStep = trace.steps[trace.steps.length - 1];\n\n    if (!(0, message_trace_1.isEvmStep)(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n\n    if (lastInst.opcode !== opcodes_1.Opcode.REVERT || lastInst.location !== undefined) {\n      return false;\n    }\n\n    let hasReadDeploymentCodeSize = false; // eslint-disable-next-line @typescript-eslint/prefer-for-of\n\n    for (let stepIndex = 0; stepIndex < trace.steps.length; stepIndex++) {\n      const step = trace.steps[stepIndex];\n\n      if (!(0, message_trace_1.isEvmStep)(step)) {\n        return false;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      if (inst.location !== undefined && !contract.location.equals(inst.location) && !constructor.location.equals(inst.location)) {\n        return false;\n      }\n\n      if (inst.opcode === opcodes_1.Opcode.CODESIZE && (0, message_trace_1.isCreateTrace)(trace)) {\n        hasReadDeploymentCodeSize = true;\n      }\n    }\n\n    return hasReadDeploymentCodeSize;\n  }\n\n  _getEntryBeforeInitialModifierCallstackEntry(trace) {\n    if ((0, message_trace_1.isDecodedCreateTrace)(trace)) {\n      return {\n        type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n        sourceReference: this._getConstructorStartSourceReference(trace),\n        functionType: model_1.ContractFunctionType.CONSTRUCTOR\n      };\n    }\n\n    const calledFunction = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n\n    if (calledFunction !== undefined) {\n      return {\n        type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n        sourceReference: this._getFunctionStartSourceReference(trace, calledFunction),\n        functionType: model_1.ContractFunctionType.FUNCTION\n      };\n    } // If it failed or made a call from within a modifier, and the selector doesn't match\n    // any function, it must have a fallback.\n\n\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n      sourceReference: this._getFallbackStartSourceReference(trace),\n      functionType: model_1.ContractFunctionType.FALLBACK\n    };\n  }\n\n  _getLastSourceReference(trace) {\n    for (let i = trace.steps.length - 1; i >= 0; i--) {\n      const step = trace.steps[i];\n\n      if (!(0, message_trace_1.isEvmStep)(step)) {\n        continue;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      if (inst.location === undefined) {\n        continue;\n      }\n\n      return sourceLocationToSourceReference(trace.bytecode, inst.location);\n    }\n\n    return undefined;\n  }\n\n  _hasFailedInsideTheFallbackFunction(trace) {\n    const contract = trace.bytecode.contract;\n\n    if (contract.fallback === undefined) {\n      return false;\n    }\n\n    return this._hasFailedInsideFunction(trace, contract.fallback);\n  }\n\n  _hasFailedInsideTheReceiveFunction(trace) {\n    const contract = trace.bytecode.contract;\n\n    if (contract.receive === undefined) {\n      return false;\n    }\n\n    return this._hasFailedInsideFunction(trace, contract.receive);\n  }\n\n  _hasFailedInsideFunction(trace, func) {\n    const lastStep = trace.steps[trace.steps.length - 1];\n    const lastInstruction = trace.bytecode.getInstruction(lastStep.pc);\n    return lastInstruction.location !== undefined && lastInstruction.opcode === opcodes_1.Opcode.REVERT && func.location.contains(lastInstruction.location);\n  }\n\n  _instructionWithinFunctionToRevertStackTraceEntry(trace, inst) {\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n      sourceReference: sourceLocationToSourceReference(trace.bytecode, inst.location),\n      message: new return_data_1.ReturnData(trace.returnData),\n      isInvalidOpcodeError: inst.opcode === opcodes_1.Opcode.INVALID\n    };\n  }\n\n  _instructionWithinFunctionToPanicStackTraceEntry(trace, inst, errorCode) {\n    var _a;\n\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.PANIC_ERROR,\n      sourceReference: (_a = sourceLocationToSourceReference(trace.bytecode, inst.location)) !== null && _a !== void 0 ? _a : this._getLastSourceReference(trace),\n      errorCode\n    };\n  }\n\n  _instructionWithinFunctionToCustomErrorStackTraceEntry(trace, inst, message) {\n    var _a;\n\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CUSTOM_ERROR,\n      sourceReference: (_a = sourceLocationToSourceReference(trace.bytecode, inst.location)) !== null && _a !== void 0 ? _a : this._getLastSourceReference(trace),\n      message\n    };\n  }\n\n  _solidity063MaybeUnmappedRevert(trace) {\n    const lastStep = trace.steps[trace.steps.length - 1];\n\n    if (!(0, message_trace_1.isEvmStep)(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n    return semver_1.default.satisfies(trace.bytecode.compilerVersion, `^${FIRST_SOLC_VERSION_WITH_UNMAPPED_REVERTS}`) && lastInst.opcode === opcodes_1.Opcode.REVERT;\n  } // Solidity 0.6.3 unmapped reverts special handling\n  // For more info: https://github.com/ethereum/solidity/issues/9006\n\n\n  _solidity063GetFrameForUnmappedRevertBeforeFunction(trace) {\n    let revertFrame = this._solidity063GetFrameForUnmappedRevertWithinFunction(trace);\n\n    if (revertFrame === undefined || revertFrame.sourceReference === undefined) {\n      if (trace.bytecode.contract.receive === undefined || trace.calldata.length > 0) {\n        if (trace.bytecode.contract.fallback !== undefined) {\n          // Failed within the fallback\n          const location = trace.bytecode.contract.fallback.location;\n          revertFrame = {\n            type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n            sourceReference: {\n              contract: trace.bytecode.contract.name,\n              function: solidity_stack_trace_1.FALLBACK_FUNCTION_NAME,\n              sourceName: location.file.sourceName,\n              sourceContent: location.file.content,\n              line: location.getStartingLineNumber(),\n              range: [location.offset, location.offset + location.length]\n            }\n          };\n\n          this._solidity063CorrectLineNumber(revertFrame);\n        }\n      } else {\n        // Failed within the receive function\n        const location = trace.bytecode.contract.receive.location;\n        revertFrame = {\n          type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n          sourceReference: {\n            contract: trace.bytecode.contract.name,\n            function: solidity_stack_trace_1.RECEIVE_FUNCTION_NAME,\n            sourceName: location.file.sourceName,\n            sourceContent: location.file.content,\n            line: location.getStartingLineNumber(),\n            range: [location.offset, location.offset + location.length]\n          }\n        };\n\n        this._solidity063CorrectLineNumber(revertFrame);\n      }\n    }\n\n    return revertFrame;\n  }\n\n  _getOtherErrorBeforeCalledFunctionStackTraceEntry(trace) {\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.OTHER_EXECUTION_ERROR,\n      sourceReference: this._getContractStartWithoutFunctionSourceReference(trace)\n    };\n  }\n\n  _isCalledNonContractAccountError(trace) {\n    // We could change this to checking that the last valid location maps to a call, but\n    // it's way more complex as we need to get the ast node from that location.\n    const lastIndex = this._getLastInstructionWithValidLocationStepIndex(trace);\n\n    if (lastIndex === undefined || lastIndex === 0) {\n      return false;\n    }\n\n    const lastStep = trace.steps[lastIndex]; // We know this is an EVM step\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n\n    if (lastInst.opcode !== opcodes_1.Opcode.ISZERO) {\n      return false;\n    }\n\n    const prevStep = trace.steps[lastIndex - 1]; // We know this is an EVM step\n\n    const prevInst = trace.bytecode.getInstruction(prevStep.pc);\n    return prevInst.opcode === opcodes_1.Opcode.EXTCODESIZE;\n  }\n\n  _solidity063GetFrameForUnmappedRevertWithinFunction(trace) {\n    // If we are within a function there's a last valid location. It may\n    // be the entire contract.\n    const prevInst = this._getLastInstructionWithValidLocation(trace);\n\n    const lastStep = trace.steps[trace.steps.length - 1];\n    const nextInstPc = lastStep.pc + 1;\n    const hasNextInst = trace.bytecode.hasInstruction(nextInstPc);\n\n    if (hasNextInst) {\n      const nextInst = trace.bytecode.getInstruction(nextInstPc);\n      const prevLoc = prevInst.location;\n      const nextLoc = nextInst.location;\n      const prevFunc = prevLoc.getContainingFunction();\n      const nextFunc = nextLoc === null || nextLoc === void 0 ? void 0 : nextLoc.getContainingFunction(); // This is probably a require. This means that we have the exact\n      // line, but the stack trace may be degraded (e.g. missing our\n      // synthetic call frames when failing in a modifier) so we still\n      // add this frame as UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n\n      if (prevFunc !== undefined && nextLoc !== undefined && prevLoc.equals(nextLoc)) {\n        return Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, nextInst)), {\n          type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n        });\n      }\n\n      let revertFrame; // If the previous and next location don't match, we try to use the\n      // previous one if it's inside a function, otherwise we use the next one\n\n      if (prevFunc !== undefined) {\n        revertFrame = Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, prevInst)), {\n          type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n        });\n      } else if (nextFunc !== undefined) {\n        revertFrame = Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, nextInst)), {\n          type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n        });\n      }\n\n      if (revertFrame !== undefined) {\n        this._solidity063CorrectLineNumber(revertFrame);\n      }\n\n      return revertFrame;\n    }\n\n    if ((0, message_trace_1.isCreateTrace)(trace)) {\n      // Solidity is smart enough to stop emitting extra instructions after\n      // an unconditional revert happens in a constructor. If this is the case\n      // we just return a special error.\n      const constructorRevertFrame = Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, prevInst)), {\n        type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n      }); // When the latest instruction is not within a function we need\n      // some default sourceReference to show to the user\n\n      if (constructorRevertFrame.sourceReference === undefined) {\n        const location = trace.bytecode.contract.location;\n        const defaultSourceReference = {\n          function: solidity_stack_trace_1.CONSTRUCTOR_FUNCTION_NAME,\n          contract: trace.bytecode.contract.name,\n          sourceName: location.file.sourceName,\n          sourceContent: location.file.content,\n          line: location.getStartingLineNumber(),\n          range: [location.offset, location.offset + location.length]\n        };\n\n        if (trace.bytecode.contract.constructorFunction !== undefined) {\n          defaultSourceReference.line = trace.bytecode.contract.constructorFunction.location.getStartingLineNumber();\n        }\n\n        constructorRevertFrame.sourceReference = defaultSourceReference;\n      } else {\n        this._solidity063CorrectLineNumber(constructorRevertFrame);\n      }\n\n      return constructorRevertFrame;\n    } // We may as well just be in a function or modifier and just happen\n    // to be at the last instruction of the runtime bytecode.\n    // In this case we just return whatever the last mapped intruction\n    // points to.\n\n\n    const latestInstructionRevertFrame = Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, prevInst)), {\n      type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n    });\n\n    if (latestInstructionRevertFrame.sourceReference !== undefined) {\n      this._solidity063CorrectLineNumber(latestInstructionRevertFrame);\n    }\n\n    return latestInstructionRevertFrame;\n  }\n\n  _isContractTooLargeError(trace) {\n    if (trace.error === undefined || trace.error.error !== exceptions_1.ERROR.OUT_OF_GAS) {\n      return false;\n    } // This error doesn't come from solidity, but actually from the VM.\n    // The deployment code executes correctly, but it OOGs.\n\n\n    const lastStep = trace.steps[trace.steps.length - 1];\n\n    if (!(0, message_trace_1.isEvmStep)(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n\n    if (lastInst.opcode !== opcodes_1.Opcode.RETURN) {\n      return false;\n    } // TODO: This is an over approximation, as we should be comparing the\n    //  runtime bytecode.\n\n\n    if (trace.bytecode.normalizedCode.length <= EIP170_BYTECODE_SIZE_INCLUSIVE_LIMIT) {\n      return false;\n    } // TODO: What happens if it's an actual out of gas that OOGs at the return?\n    //   maybe traces should have gasLimit and gasUsed.\n\n\n    return true;\n  }\n\n  _solidity063CorrectLineNumber(revertFrame) {\n    const lines = revertFrame.sourceReference.sourceContent.split(\"\\n\");\n    const currentLine = lines[revertFrame.sourceReference.line - 1];\n\n    if (currentLine.includes(\"require\") || currentLine.includes(\"revert\")) {\n      return;\n    }\n\n    const nextLines = lines.slice(revertFrame.sourceReference.line);\n    const firstNonEmptyLine = nextLines.findIndex(l => l.trim() !== \"\");\n\n    if (firstNonEmptyLine === -1) {\n      return;\n    }\n\n    const nextLine = nextLines[firstNonEmptyLine];\n\n    if (nextLine.includes(\"require\") || nextLine.includes(\"revert\")) {\n      revertFrame.sourceReference.line += 1 + firstNonEmptyLine;\n    }\n  }\n\n  _getLastInstructionWithValidLocationStepIndex(trace) {\n    for (let i = trace.steps.length - 1; i >= 0; i--) {\n      const step = trace.steps[i];\n\n      if (!(0, message_trace_1.isEvmStep)(step)) {\n        return undefined;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      if (inst.location !== undefined) {\n        return i;\n      }\n    }\n\n    return undefined;\n  }\n\n  _getLastInstructionWithValidLocation(trace) {\n    const lastLocationIndex = this._getLastInstructionWithValidLocationStepIndex(trace);\n\n    if (lastLocationIndex === undefined) {\n      return undefined;\n    }\n\n    const lastLocationStep = trace.steps[lastLocationIndex];\n\n    if ((0, message_trace_1.isEvmStep)(lastLocationStep)) {\n      const lastInstructionWithLocation = trace.bytecode.getInstruction(lastLocationStep.pc);\n      return lastInstructionWithLocation;\n    }\n\n    return undefined;\n  }\n\n  _callInstructionToCallFailedToExecuteStackTraceEntry(bytecode, callInst) {\n    // Calls only happen within functions\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CALL_FAILED_ERROR,\n      sourceReference: sourceLocationToSourceReference(bytecode, callInst.location)\n    };\n  }\n\n  _getEntryBeforeFailureInModifier(trace, functionJumpdests) {\n    // If there's a jumpdest, this modifier belongs to the last function that it represents\n    if (functionJumpdests.length > 0) {\n      return instructionToCallstackStackTraceEntry(trace.bytecode, functionJumpdests[functionJumpdests.length - 1]);\n    } // This function is only called after we jumped into the initial function in call traces, so\n    // there should always be at least a function jumpdest.\n\n\n    if (!(0, message_trace_1.isDecodedCreateTrace)(trace)) {\n      throw new Error(\"This shouldn't happen: a call trace has no functionJumpdest but has already jumped into a function\");\n    } // If there's no jump dest, we point to the constructor.\n\n\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n      sourceReference: this._getConstructorStartSourceReference(trace),\n      functionType: model_1.ContractFunctionType.CONSTRUCTOR\n    };\n  }\n\n  _failsRightAfterCall(trace, callSubtraceStepIndex) {\n    const lastStep = trace.steps[trace.steps.length - 1];\n\n    if (!(0, message_trace_1.isEvmStep)(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n\n    if (lastInst.opcode !== opcodes_1.Opcode.REVERT) {\n      return false;\n    }\n\n    const callOpcodeStep = trace.steps[callSubtraceStepIndex - 1];\n    const callInst = trace.bytecode.getInstruction(callOpcodeStep.pc);\n    return this._isLastLocation(trace, callSubtraceStepIndex + 1, callInst.location // Calls are always made from within functions\n    );\n  }\n\n  _isCallFailedError(trace, instIndex, callInstruction) {\n    const callLocation = callInstruction.location; // Calls are always made from within functions\n\n    return this._isLastLocation(trace, instIndex, callLocation);\n  }\n\n  _isLastLocation(trace, fromStep, location) {\n    for (let i = fromStep; i < trace.steps.length; i++) {\n      const step = trace.steps[i];\n\n      if (!(0, message_trace_1.isEvmStep)(step)) {\n        return false;\n      }\n\n      const stepInst = trace.bytecode.getInstruction(step.pc);\n\n      if (stepInst.location === undefined) {\n        continue;\n      }\n\n      if (!location.equals(stepInst.location)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _isSubtraceErrorPropagated(trace, callSubtraceStepIndex) {\n    var _a, _b;\n\n    const call = trace.steps[callSubtraceStepIndex];\n\n    if (!trace.returnData.equals(call.returnData)) {\n      return false;\n    }\n\n    if (((_a = trace.error) === null || _a === void 0 ? void 0 : _a.error) === exceptions_1.ERROR.OUT_OF_GAS && ((_b = call.error) === null || _b === void 0 ? void 0 : _b.error) === exceptions_1.ERROR.OUT_OF_GAS) {\n      return true;\n    }\n\n    return this._failsRightAfterCall(trace, callSubtraceStepIndex);\n  }\n\n  _isProxyErrorPropagated(trace, callSubtraceStepIndex) {\n    if (!(0, message_trace_1.isDecodedCallTrace)(trace)) {\n      return false;\n    }\n\n    const callStep = trace.steps[callSubtraceStepIndex - 1];\n\n    if (!(0, message_trace_1.isEvmStep)(callStep)) {\n      return false;\n    }\n\n    const callInst = trace.bytecode.getInstruction(callStep.pc);\n\n    if (callInst.opcode !== opcodes_1.Opcode.DELEGATECALL) {\n      return false;\n    }\n\n    const subtrace = trace.steps[callSubtraceStepIndex];\n\n    if ((0, message_trace_1.isEvmStep)(subtrace)) {\n      return false;\n    }\n\n    if ((0, message_trace_1.isPrecompileTrace)(subtrace)) {\n      return false;\n    } // If we can't recognize the implementation we'd better don't consider it as such\n\n\n    if (subtrace.bytecode === undefined) {\n      return false;\n    }\n\n    if (subtrace.bytecode.contract.type === model_1.ContractType.LIBRARY) {\n      return false;\n    }\n\n    if (!trace.returnData.equals(subtrace.returnData)) {\n      return false;\n    }\n\n    for (let i = callSubtraceStepIndex + 1; i < trace.steps.length; i++) {\n      const step = trace.steps[i];\n\n      if (!(0, message_trace_1.isEvmStep)(step)) {\n        return false;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc); // All the remaining locations should be valid, as they are part of the inline asm\n\n      if (inst.location === undefined) {\n        return false;\n      }\n\n      if (inst.jumpType === model_1.JumpType.INTO_FUNCTION || inst.jumpType === model_1.JumpType.OUTOF_FUNCTION) {\n        return false;\n      }\n    }\n\n    const lastStep = trace.steps[trace.steps.length - 1];\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n    return lastInst.opcode === opcodes_1.Opcode.REVERT;\n  }\n\n  _isContractCallRunOutOfGasError(trace, callStepIndex) {\n    var _a, _b;\n\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    if (((_a = trace.error) === null || _a === void 0 ? void 0 : _a.error) !== exceptions_1.ERROR.REVERT) {\n      return false;\n    }\n\n    const call = trace.steps[callStepIndex];\n\n    if (((_b = call.error) === null || _b === void 0 ? void 0 : _b.error) !== exceptions_1.ERROR.OUT_OF_GAS) {\n      return false;\n    }\n\n    return this._failsRightAfterCall(trace, callStepIndex);\n  }\n\n  _isPanicReturnData(returnData) {\n    return new return_data_1.ReturnData(returnData).isPanicReturnData();\n  }\n\n}\n\nexports.ErrorInferrer = ErrorInferrer;\n\nfunction instructionToCallstackStackTraceEntry(bytecode, inst) {\n  // This means that a jump is made from within an internal solc function.\n  // These are normally made from yul code, so they don't map to any Solidity\n  // function\n  if (inst.location === undefined) {\n    const location = bytecode.contract.location;\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.INTERNAL_FUNCTION_CALLSTACK_ENTRY,\n      pc: inst.pc,\n      sourceReference: {\n        sourceName: bytecode.contract.location.file.sourceName,\n        sourceContent: bytecode.contract.location.file.content,\n        contract: bytecode.contract.name,\n        function: undefined,\n        line: bytecode.contract.location.getStartingLineNumber(),\n        range: [location.offset, location.offset + location.length]\n      }\n    };\n  }\n\n  const func = inst.location.getContainingFunction();\n\n  if (func !== undefined) {\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n      sourceReference: sourceLocationToSourceReference(bytecode, inst.location),\n      functionType: func.type\n    };\n  }\n\n  return {\n    type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n    sourceReference: {\n      function: undefined,\n      contract: bytecode.contract.name,\n      sourceName: inst.location.file.sourceName,\n      sourceContent: inst.location.file.content,\n      line: inst.location.getStartingLineNumber(),\n      range: [inst.location.offset, inst.location.offset + inst.location.length]\n    },\n    functionType: model_1.ContractFunctionType.FUNCTION\n  };\n}\n\nexports.instructionToCallstackStackTraceEntry = instructionToCallstackStackTraceEntry;\n\nfunction sourceLocationToSourceReference(bytecode, location) {\n  if (location === undefined) {\n    return undefined;\n  }\n\n  const func = location.getContainingFunction();\n\n  if (func === undefined) {\n    return undefined;\n  }\n\n  let funcName = func.name;\n\n  if (func.type === model_1.ContractFunctionType.CONSTRUCTOR) {\n    funcName = solidity_stack_trace_1.CONSTRUCTOR_FUNCTION_NAME;\n  } else if (func.type === model_1.ContractFunctionType.FALLBACK) {\n    funcName = solidity_stack_trace_1.FALLBACK_FUNCTION_NAME;\n  } else if (func.type === model_1.ContractFunctionType.RECEIVE) {\n    funcName = solidity_stack_trace_1.RECEIVE_FUNCTION_NAME;\n  }\n\n  return {\n    function: funcName,\n    contract: func.type === model_1.ContractFunctionType.FREE_FUNCTION ? undefined : bytecode.contract.name,\n    sourceName: func.location.file.sourceName,\n    sourceContent: func.location.file.content,\n    line: location.getStartingLineNumber(),\n    range: [location.offset, location.offset + location.length]\n  };\n}","map":{"version":3,"mappings":"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","names":["FIRST_SOLC_VERSION_CREATE_PARAMS_VALIDATION","FIRST_SOLC_VERSION_RECEIVE_FUNCTION","FIRST_SOLC_VERSION_WITH_UNMAPPED_REVERTS","EIP170_BYTECODE_SIZE_INCLUSIVE_LIMIT","ErrorInferrer","inferBeforeTracingCallMessage","trace","_isDirectLibraryCall","_getDirectLibraryCallErrorStackTrace","calledFunction","bytecode","contract","getFunctionFromSelector","calldata","slice","_isFunctionNotPayableError","type","solidity_stack_trace_1","FUNCTION_NOT_PAYABLE_ERROR","sourceReference","_getFunctionStartSourceReference","value","_isMissingFunctionAndFallbackError","_emptyCalldataAndNoReceive","MISSING_FALLBACK_OR_RECEIVE_ERROR","_getContractStartWithoutFunctionSourceReference","UNRECOGNIZED_FUNCTION_WITHOUT_FALLBACK_ERROR","_isFallbackNotPayableError","FALLBACK_NOT_PAYABLE_AND_NO_RECEIVE_ERROR","_getFallbackStartSourceReference","FALLBACK_NOT_PAYABLE_ERROR","inferBeforeTracingCreateMessage","_isConstructorNotPayableError","_getConstructorStartSourceReference","_isConstructorInvalidArgumentsError","INVALID_PARAMS_ERROR","inferAfterTracing","stacktrace","functionJumpdests","jumpedIntoFunction","lastSubmessageData","_checkLastSubmessage","_a","_checkFailedLastCall","_b","_checkLastInstruction","_c","_checkNonContractCalled","_d","_checkSolidity063UnmappedRevert","_e","_checkContractTooLarge","_f","_otherExecutionErrorStacktrace","filterRedundantFrames","filter","frame","i","length","nextFrame","undefined","CALLSTACK_ENTRY","RETURNDATA_SIZE_ERROR","thatSrcRef","range","line","function","inferredStacktrace","callStep","steps","stepIndex","Error","callInst","getInstruction","pc","callStackFrame","instructionToCallstackStackTraceEntry","lastMessageFailed","messageTrace","error","push","_isSubtraceErrorPropagated","_isProxyErrorPropagated","_isContractCallRunOutOfGasError","lastFrame","pop","CONTRACT_CALL_RUN_OUT_OF_GAS_ERROR","_fixInitialModifier","isReturnDataSizeError","_failsRightAfterCall","step","nextStep","inst","isCallOrCreate","opcode","_isCallFailedError","_callInstructionToCallFailedToExecuteStackTraceEntry","_checkRevertOrInvalidOpcode","lastInstruction","opcodes_1","REVERT","INVALID","location","failingFunction","getContainingFunction","model_1","MODIFIER","_getEntryBeforeFailureInModifier","panicStacktrace","_checkPanic","customErrorStacktrace","_checkCustomErrors","_instructionWithinFunctionToRevertStackTraceEntry","REVERT_ERROR","message","return_data_1","returnData","isInvalidOpcodeError","revertFrame","_getLastSourceReference","_isPanicReturnData","INTERNAL_FUNCTION_CALLSTACK_ENTRY","splice","panicReturnData","errorCode","decodePanic","eqn","_instructionWithinFunctionToPanicStackTraceEntry","isEmpty","isErrorReturnData","errorMessage","customError","customErrors","matchesSelector","selector","decodedValues","abi_1","decode","paramTypes","params","abi_helpers_1","formatValues","name","_instructionWithinFunctionToCustomErrorStackTraceEntry","lastStep","revertOrInvalidStacktrace","_hasFailedInsideTheFallbackFunction","_hasFailedInsideTheReceiveFunction","_solidity063MaybeUnmappedRevert","_solidity063GetFrameForUnmappedRevertBeforeFunction","_getOtherErrorBeforeCalledFunctionStackTraceEntry","_isCalledNonContractAccountError","nonContractCalledFrame","NONCONTRACT_ACCOUNT_CALLED_ERROR","_solidity063GetFrameForUnmappedRevertWithinFunction","_isContractTooLargeError","CONTRACT_TOO_LARGE_ERROR","otherExecutionErrorFrame","OTHER_EXECUTION_ERROR","firstEntry","functionType","_getEntryBeforeInitialModifierCallstackEntry","depth","LIBRARY","func","DIRECT_LIBRARY_CALL_ERROR","lten","isPayable","sourceName","file","sourceContent","content","getStartingLineNumber","offset","receive","fallback","semver_1","lt","compilerVersion","constructor","constructorFunction","gtn","lastInst","hasReadDeploymentCodeSize","equals","CODESIZE","CONSTRUCTOR","FUNCTION","FALLBACK","sourceLocationToSourceReference","_hasFailedInsideFunction","contains","PANIC_ERROR","CUSTOM_ERROR","satisfies","UNMAPPED_SOLC_0_6_3_REVERT_ERROR","_solidity063CorrectLineNumber","lastIndex","_getLastInstructionWithValidLocationStepIndex","ISZERO","prevStep","prevInst","EXTCODESIZE","_getLastInstructionWithValidLocation","nextInstPc","hasNextInst","hasInstruction","nextInst","prevLoc","nextLoc","prevFunc","nextFunc","constructorRevertFrame","defaultSourceReference","latestInstructionRevertFrame","exceptions_1","OUT_OF_GAS","RETURN","normalizedCode","lines","split","currentLine","includes","nextLines","firstNonEmptyLine","findIndex","l","trim","nextLine","lastLocationIndex","lastLocationStep","lastInstructionWithLocation","CALL_FAILED_ERROR","callSubtraceStepIndex","callOpcodeStep","_isLastLocation","instIndex","callInstruction","callLocation","fromStep","stepInst","call","DELEGATECALL","subtrace","jumpType","INTO_FUNCTION","OUTOF_FUNCTION","callStepIndex","isPanicReturnData","exports","funcName","RECEIVE","FREE_FUNCTION"],"sources":["/Users/jake/workspace/token-builder/node_modules/hardhat/src/internal/hardhat-network/stack-traces/error-inferrer.ts"],"sourcesContent":["import { ERROR } from \"@ethereumjs/vm/dist/exceptions\";\nimport { defaultAbiCoder as abi } from \"@ethersproject/abi\";\nimport { BN } from \"ethereumjs-util\";\nimport semver from \"semver\";\n\nimport { AbiHelpers } from \"../../util/abi-helpers\";\nimport { ReturnData } from \"../provider/return-data\";\n\nimport {\n  DecodedCallMessageTrace,\n  DecodedCreateMessageTrace,\n  DecodedEvmMessageTrace,\n  EvmStep,\n  isCreateTrace,\n  isDecodedCallTrace,\n  isDecodedCreateTrace,\n  isEvmStep,\n  isPrecompileTrace,\n  MessageTrace,\n} from \"./message-trace\";\nimport {\n  Bytecode,\n  ContractFunction,\n  ContractFunctionType,\n  ContractType,\n  Instruction,\n  JumpType,\n  SourceLocation,\n} from \"./model\";\nimport { isCall, isCreate, Opcode } from \"./opcodes\";\nimport {\n  CallFailedErrorStackTraceEntry,\n  CallstackEntryStackTraceEntry,\n  CONSTRUCTOR_FUNCTION_NAME,\n  CustomErrorStackTraceEntry,\n  FALLBACK_FUNCTION_NAME,\n  InternalFunctionCallStackEntry,\n  OtherExecutionErrorStackTraceEntry,\n  PanicErrorStackTraceEntry,\n  RECEIVE_FUNCTION_NAME,\n  RevertErrorStackTraceEntry,\n  SolidityStackTrace,\n  SolidityStackTraceEntry,\n  SourceReference,\n  StackTraceEntryType,\n  UnmappedSolc063RevertErrorStackTraceEntry,\n} from \"./solidity-stack-trace\";\n\nconst FIRST_SOLC_VERSION_CREATE_PARAMS_VALIDATION = \"0.5.9\";\nconst FIRST_SOLC_VERSION_RECEIVE_FUNCTION = \"0.6.0\";\nconst FIRST_SOLC_VERSION_WITH_UNMAPPED_REVERTS = \"0.6.3\";\n\nconst EIP170_BYTECODE_SIZE_INCLUSIVE_LIMIT = 0x6000;\n\nexport interface SubmessageData {\n  messageTrace: MessageTrace;\n  stacktrace: SolidityStackTrace;\n  stepIndex: number;\n}\n\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\n\nexport class ErrorInferrer {\n  public inferBeforeTracingCallMessage(\n    trace: DecodedCallMessageTrace\n  ): SolidityStackTrace | undefined {\n    if (this._isDirectLibraryCall(trace)) {\n      return this._getDirectLibraryCallErrorStackTrace(trace);\n    }\n\n    const calledFunction = trace.bytecode.contract.getFunctionFromSelector(\n      trace.calldata.slice(0, 4)\n    );\n\n    if (this._isFunctionNotPayableError(trace, calledFunction)) {\n      return [\n        {\n          type: StackTraceEntryType.FUNCTION_NOT_PAYABLE_ERROR,\n          sourceReference: this._getFunctionStartSourceReference(\n            trace,\n            calledFunction!\n          ),\n          value: trace.value,\n        },\n      ];\n    }\n\n    if (this._isMissingFunctionAndFallbackError(trace, calledFunction)) {\n      if (this._emptyCalldataAndNoReceive(trace)) {\n        return [\n          {\n            type: StackTraceEntryType.MISSING_FALLBACK_OR_RECEIVE_ERROR,\n            sourceReference:\n              this._getContractStartWithoutFunctionSourceReference(trace),\n          },\n        ];\n      }\n\n      return [\n        {\n          type: StackTraceEntryType.UNRECOGNIZED_FUNCTION_WITHOUT_FALLBACK_ERROR,\n          sourceReference:\n            this._getContractStartWithoutFunctionSourceReference(trace),\n        },\n      ];\n    }\n\n    if (this._isFallbackNotPayableError(trace, calledFunction)) {\n      if (this._emptyCalldataAndNoReceive(trace)) {\n        return [\n          {\n            type: StackTraceEntryType.FALLBACK_NOT_PAYABLE_AND_NO_RECEIVE_ERROR,\n            sourceReference: this._getFallbackStartSourceReference(trace),\n            value: trace.value,\n          },\n        ];\n      }\n\n      return [\n        {\n          type: StackTraceEntryType.FALLBACK_NOT_PAYABLE_ERROR,\n          sourceReference: this._getFallbackStartSourceReference(trace),\n          value: trace.value,\n        },\n      ];\n    }\n  }\n\n  public inferBeforeTracingCreateMessage(\n    trace: DecodedCreateMessageTrace\n  ): SolidityStackTrace | undefined {\n    if (this._isConstructorNotPayableError(trace)) {\n      return [\n        {\n          type: StackTraceEntryType.FUNCTION_NOT_PAYABLE_ERROR,\n          sourceReference: this._getConstructorStartSourceReference(trace),\n          value: trace.value,\n        },\n      ];\n    }\n\n    if (this._isConstructorInvalidArgumentsError(trace)) {\n      return [\n        {\n          type: StackTraceEntryType.INVALID_PARAMS_ERROR,\n          sourceReference: this._getConstructorStartSourceReference(trace),\n        },\n      ];\n    }\n  }\n\n  public inferAfterTracing(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace,\n    functionJumpdests: Instruction[],\n    jumpedIntoFunction: boolean,\n    lastSubmessageData: SubmessageData | undefined\n  ): SolidityStackTrace {\n    return (\n      this._checkLastSubmessage(trace, stacktrace, lastSubmessageData) ??\n      this._checkFailedLastCall(trace, stacktrace) ??\n      this._checkLastInstruction(\n        trace,\n        stacktrace,\n        functionJumpdests,\n        jumpedIntoFunction\n      ) ??\n      this._checkNonContractCalled(trace, stacktrace) ??\n      this._checkSolidity063UnmappedRevert(trace, stacktrace) ??\n      this._checkContractTooLarge(trace) ??\n      this._otherExecutionErrorStacktrace(trace, stacktrace)\n    );\n  }\n\n  public filterRedundantFrames(\n    stacktrace: SolidityStackTrace\n  ): SolidityStackTrace {\n    return stacktrace.filter((frame, i) => {\n      if (i + 1 === stacktrace.length) {\n        return true;\n      }\n\n      const nextFrame = stacktrace[i + 1];\n\n      // we can only filter frames if we know their sourceReference\n      // and the one from the next frame\n      if (\n        frame.sourceReference === undefined ||\n        nextFrame.sourceReference === undefined\n      ) {\n        return true;\n      }\n\n      // look TWO frames ahead to determine if this is a specific occurrence of\n      // a redundant CALLSTACK_ENTRY frame observed when using Solidity 0.8.5:\n      if (\n        frame.type === StackTraceEntryType.CALLSTACK_ENTRY &&\n        i + 2 < stacktrace.length &&\n        stacktrace[i + 2].sourceReference !== undefined &&\n        stacktrace[i + 2].type === StackTraceEntryType.RETURNDATA_SIZE_ERROR\n      ) {\n        // ! below for tsc. we confirmed existence in the enclosing conditional.\n        const thatSrcRef = stacktrace[i + 2].sourceReference!;\n        if (\n          frame.sourceReference.range[0] === thatSrcRef.range[0] &&\n          frame.sourceReference.range[1] === thatSrcRef.range[1] &&\n          frame.sourceReference.line === thatSrcRef.line\n        ) {\n          return false;\n        }\n      }\n\n      // constructors contain the whole contract, so we ignore them\n      if (\n        frame.sourceReference.function === \"constructor\" &&\n        nextFrame.sourceReference.function !== \"constructor\"\n      ) {\n        return true;\n      }\n\n      // this is probably a recursive call\n      if (\n        i > 0 &&\n        frame.type === nextFrame.type &&\n        frame.sourceReference.range[0] === nextFrame.sourceReference.range[0] &&\n        frame.sourceReference.range[1] === nextFrame.sourceReference.range[1] &&\n        frame.sourceReference.line === nextFrame.sourceReference.line\n      ) {\n        return true;\n      }\n\n      if (\n        frame.sourceReference.range[0] <= nextFrame.sourceReference.range[0] &&\n        frame.sourceReference.range[1] >= nextFrame.sourceReference.range[1]\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  // Heuristics\n\n  /**\n   * Check if the last submessage can be used to generate the stack trace.\n   */\n  private _checkLastSubmessage(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace,\n    lastSubmessageData: SubmessageData | undefined\n  ): SolidityStackTrace | undefined {\n    if (lastSubmessageData === undefined) {\n      return undefined;\n    }\n\n    const inferredStacktrace = [...stacktrace];\n\n    // get the instruction before the submessage and add it to the stack trace\n    const callStep = trace.steps[lastSubmessageData.stepIndex - 1];\n\n    if (!isEvmStep(callStep)) {\n      throw new Error(\n        \"This should not happen: MessageTrace should be preceded by a EVM step\"\n      );\n    }\n\n    const callInst = trace.bytecode.getInstruction(callStep.pc);\n    const callStackFrame = instructionToCallstackStackTraceEntry(\n      trace.bytecode,\n      callInst\n    );\n\n    const lastMessageFailed =\n      lastSubmessageData.messageTrace.error !== undefined;\n    if (lastMessageFailed) {\n      // add the call/create that generated the message to the stack trace\n      inferredStacktrace.push(callStackFrame);\n\n      if (\n        this._isSubtraceErrorPropagated(trace, lastSubmessageData.stepIndex) ||\n        this._isProxyErrorPropagated(trace, lastSubmessageData.stepIndex)\n      ) {\n        inferredStacktrace.push(...lastSubmessageData.stacktrace);\n\n        if (\n          this._isContractCallRunOutOfGasError(\n            trace,\n            lastSubmessageData.stepIndex\n          )\n        ) {\n          const lastFrame = inferredStacktrace.pop()!;\n          inferredStacktrace.push({\n            type: StackTraceEntryType.CONTRACT_CALL_RUN_OUT_OF_GAS_ERROR,\n            sourceReference: lastFrame.sourceReference,\n          });\n        }\n\n        return this._fixInitialModifier(trace, inferredStacktrace);\n      }\n    } else {\n      const isReturnDataSizeError = this._failsRightAfterCall(\n        trace,\n        lastSubmessageData.stepIndex\n      );\n      if (isReturnDataSizeError) {\n        inferredStacktrace.push({\n          type: StackTraceEntryType.RETURNDATA_SIZE_ERROR,\n          sourceReference: callStackFrame.sourceReference,\n        });\n\n        return this._fixInitialModifier(trace, inferredStacktrace);\n      }\n    }\n  }\n\n  /**\n   * Check if the last call/create that was done failed.\n   */\n  private _checkFailedLastCall(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace\n  ): SolidityStackTrace | undefined {\n    for (let stepIndex = trace.steps.length - 2; stepIndex >= 0; stepIndex--) {\n      const step = trace.steps[stepIndex];\n      const nextStep = trace.steps[stepIndex + 1];\n\n      if (!isEvmStep(step)) {\n        return;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      const isCallOrCreate = isCall(inst.opcode) || isCreate(inst.opcode);\n\n      if (isCallOrCreate && isEvmStep(nextStep)) {\n        if (this._isCallFailedError(trace, stepIndex, inst)) {\n          const inferredStacktrace = [\n            ...stacktrace,\n            this._callInstructionToCallFailedToExecuteStackTraceEntry(\n              trace.bytecode,\n              inst\n            ),\n          ];\n\n          return this._fixInitialModifier(trace, inferredStacktrace);\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if the execution stopped with a revert or an invalid opcode.\n   */\n  private _checkRevertOrInvalidOpcode(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace,\n    lastInstruction: Instruction,\n    functionJumpdests: Instruction[],\n    jumpedIntoFunction: boolean\n  ): SolidityStackTrace | undefined {\n    if (\n      lastInstruction.opcode !== Opcode.REVERT &&\n      lastInstruction.opcode !== Opcode.INVALID\n    ) {\n      return;\n    }\n\n    const inferredStacktrace = [...stacktrace];\n\n    if (\n      lastInstruction.location !== undefined &&\n      (!isDecodedCallTrace(trace) || jumpedIntoFunction)\n    ) {\n      // There should always be a function here, but that's not the case with optimizations.\n      //\n      // If this is a create trace, we already checked args and nonpayable failures before\n      // calling this function.\n      //\n      // If it's a call trace, we already jumped into a function. But optimizations can happen.\n      const failingFunction = lastInstruction.location.getContainingFunction();\n\n      // If the failure is in a modifier we add an entry with the function/constructor\n      if (\n        failingFunction !== undefined &&\n        failingFunction.type === ContractFunctionType.MODIFIER\n      ) {\n        inferredStacktrace.push(\n          this._getEntryBeforeFailureInModifier(trace, functionJumpdests)\n        );\n      }\n    }\n\n    const panicStacktrace = this._checkPanic(\n      trace,\n      inferredStacktrace,\n      lastInstruction\n    );\n    if (panicStacktrace !== undefined) {\n      return panicStacktrace;\n    }\n\n    const customErrorStacktrace = this._checkCustomErrors(\n      trace,\n      inferredStacktrace,\n      lastInstruction\n    );\n    if (customErrorStacktrace !== undefined) {\n      return customErrorStacktrace;\n    }\n\n    if (\n      lastInstruction.location !== undefined &&\n      (!isDecodedCallTrace(trace) || jumpedIntoFunction)\n    ) {\n      const failingFunction = lastInstruction.location.getContainingFunction();\n\n      if (failingFunction !== undefined) {\n        inferredStacktrace.push(\n          this._instructionWithinFunctionToRevertStackTraceEntry(\n            trace,\n            lastInstruction\n          )\n        );\n      } else if (isDecodedCallTrace(trace)) {\n        // This is here because of the optimizations\n        inferredStacktrace.push({\n          type: StackTraceEntryType.REVERT_ERROR,\n          sourceReference: this._getFunctionStartSourceReference(\n            trace,\n            trace.bytecode.contract.getFunctionFromSelector(\n              trace.calldata.slice(0, 4)\n            )!\n          ),\n          message: new ReturnData(trace.returnData),\n          isInvalidOpcodeError: lastInstruction.opcode === Opcode.INVALID,\n        });\n      } else {\n        // This is here because of the optimizations\n        inferredStacktrace.push({\n          type: StackTraceEntryType.REVERT_ERROR,\n          sourceReference: this._getConstructorStartSourceReference(trace),\n          message: new ReturnData(trace.returnData),\n          isInvalidOpcodeError: lastInstruction.opcode === Opcode.INVALID,\n        });\n      }\n\n      return this._fixInitialModifier(trace, inferredStacktrace);\n    }\n\n    // If the revert instruction is not mapped but there is return data,\n    // we add the frame anyway, sith the best sourceReference we can get\n    if (lastInstruction.location === undefined && trace.returnData.length > 0) {\n      const revertFrame: RevertErrorStackTraceEntry = {\n        type: StackTraceEntryType.REVERT_ERROR,\n        sourceReference:\n          this._getLastSourceReference(trace) ??\n          this._getContractStartWithoutFunctionSourceReference(trace),\n        message: new ReturnData(trace.returnData),\n        isInvalidOpcodeError: lastInstruction.opcode === Opcode.INVALID,\n      };\n      inferredStacktrace.push(revertFrame);\n\n      return this._fixInitialModifier(trace, inferredStacktrace);\n    }\n  }\n\n  /**\n   * Check if the trace reverted with a panic error.\n   */\n  private _checkPanic(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace,\n    lastInstruction: Instruction\n  ): SolidityStackTrace | undefined {\n    if (!this._isPanicReturnData(trace.returnData)) {\n      return;\n    }\n\n    // If the last frame is an internal function, it means that the trace\n    // jumped there to return the panic. If that's the case, we remove that\n    // frame.\n    const lastFrame = stacktrace[stacktrace.length - 1];\n    if (\n      lastFrame?.type === StackTraceEntryType.INTERNAL_FUNCTION_CALLSTACK_ENTRY\n    ) {\n      stacktrace.splice(-1);\n    }\n\n    const panicReturnData = new ReturnData(trace.returnData);\n    const errorCode = panicReturnData.decodePanic();\n\n    // if the error comes from a call to a zero-initialized function,\n    // we remove the last frame, which represents the call, to avoid\n    // having duplicated frames\n    if (errorCode.eqn(0x51)) {\n      stacktrace.splice(-1);\n    }\n\n    const inferredStacktrace = [...stacktrace];\n    inferredStacktrace.push(\n      this._instructionWithinFunctionToPanicStackTraceEntry(\n        trace,\n        lastInstruction,\n        errorCode\n      )\n    );\n\n    return this._fixInitialModifier(trace, inferredStacktrace);\n  }\n\n  private _checkCustomErrors(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace,\n    lastInstruction: Instruction\n  ): SolidityStackTrace | undefined {\n    const returnData = new ReturnData(trace.returnData);\n\n    if (returnData.isEmpty() || returnData.isErrorReturnData()) {\n      // if there is no return data, or if it's a Error(string),\n      // then it can't be a custom error\n      return;\n    }\n\n    let errorMessage = \"reverted with an unrecognized custom error\";\n\n    for (const customError of trace.bytecode.contract.customErrors) {\n      if (returnData.matchesSelector(customError.selector)) {\n        // if the return data matches a custom error in the called contract,\n        // we format the message using the returnData and the custom error instance\n        const decodedValues = abi.decode(\n          customError.paramTypes,\n          returnData.value.slice(4)\n        );\n\n        const params = AbiHelpers.formatValues([...decodedValues]);\n        errorMessage = `reverted with custom error '${customError.name}(${params})'`;\n        break;\n      }\n    }\n\n    const inferredStacktrace = [...stacktrace];\n    inferredStacktrace.push(\n      this._instructionWithinFunctionToCustomErrorStackTraceEntry(\n        trace,\n        lastInstruction,\n        errorMessage\n      )\n    );\n\n    return this._fixInitialModifier(trace, inferredStacktrace);\n  }\n\n  /**\n   * Check last instruction to try to infer the error.\n   */\n  private _checkLastInstruction(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace,\n    functionJumpdests: Instruction[],\n    jumpedIntoFunction: boolean\n  ): SolidityStackTrace | undefined {\n    const lastStep = trace.steps[trace.steps.length - 1];\n\n    if (!isEvmStep(lastStep)) {\n      throw new Error(\n        \"This should not happen: MessageTrace ends with a subtrace\"\n      );\n    }\n\n    const lastInstruction = trace.bytecode.getInstruction(lastStep.pc);\n\n    const revertOrInvalidStacktrace = this._checkRevertOrInvalidOpcode(\n      trace,\n      stacktrace,\n      lastInstruction,\n      functionJumpdests,\n      jumpedIntoFunction\n    );\n\n    if (revertOrInvalidStacktrace !== undefined) {\n      return revertOrInvalidStacktrace;\n    }\n\n    if (isDecodedCallTrace(trace) && !jumpedIntoFunction) {\n      if (\n        this._hasFailedInsideTheFallbackFunction(trace) ||\n        this._hasFailedInsideTheReceiveFunction(trace)\n      ) {\n        return [\n          this._instructionWithinFunctionToRevertStackTraceEntry(\n            trace,\n            lastInstruction\n          ),\n        ];\n      }\n\n      // Sometimes we do fail inside of a function but there's no jump into\n      if (lastInstruction.location !== undefined) {\n        const failingFunction =\n          lastInstruction.location.getContainingFunction();\n        if (failingFunction !== undefined) {\n          return [\n            {\n              type: StackTraceEntryType.REVERT_ERROR,\n              sourceReference: this._getFunctionStartSourceReference(\n                trace,\n                failingFunction\n              ),\n              message: new ReturnData(trace.returnData),\n              isInvalidOpcodeError: lastInstruction.opcode === Opcode.INVALID,\n            },\n          ];\n        }\n      }\n\n      const calledFunction = trace.bytecode.contract.getFunctionFromSelector(\n        trace.calldata.slice(0, 4)\n      );\n\n      if (calledFunction !== undefined) {\n        return [\n          {\n            type: StackTraceEntryType.INVALID_PARAMS_ERROR,\n            sourceReference: this._getFunctionStartSourceReference(\n              trace,\n              calledFunction\n            ),\n          },\n        ];\n      }\n\n      if (this._solidity063MaybeUnmappedRevert(trace)) {\n        const revertFrame =\n          this._solidity063GetFrameForUnmappedRevertBeforeFunction(trace);\n\n        if (revertFrame !== undefined) {\n          return [revertFrame];\n        }\n      }\n\n      return [this._getOtherErrorBeforeCalledFunctionStackTraceEntry(trace)];\n    }\n  }\n\n  private _checkNonContractCalled(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace\n  ): SolidityStackTrace | undefined {\n    if (this._isCalledNonContractAccountError(trace)) {\n      const nonContractCalledFrame: SolidityStackTraceEntry = {\n        type: StackTraceEntryType.NONCONTRACT_ACCOUNT_CALLED_ERROR,\n        // We are sure this is not undefined because there was at least a call instruction\n        sourceReference: this._getLastSourceReference(trace)!,\n      };\n\n      return [...stacktrace, nonContractCalledFrame];\n    }\n  }\n\n  private _checkSolidity063UnmappedRevert(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace\n  ): SolidityStackTrace | undefined {\n    if (this._solidity063MaybeUnmappedRevert(trace)) {\n      const revertFrame =\n        this._solidity063GetFrameForUnmappedRevertWithinFunction(trace);\n\n      if (revertFrame !== undefined) {\n        return [...stacktrace, revertFrame];\n      }\n    }\n  }\n\n  private _checkContractTooLarge(\n    trace: DecodedEvmMessageTrace\n  ): SolidityStackTrace | undefined {\n    if (isCreateTrace(trace) && this._isContractTooLargeError(trace)) {\n      return [\n        {\n          type: StackTraceEntryType.CONTRACT_TOO_LARGE_ERROR,\n          sourceReference: this._getConstructorStartSourceReference(trace),\n        },\n      ];\n    }\n  }\n\n  private _otherExecutionErrorStacktrace(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace\n  ): SolidityStackTrace {\n    const otherExecutionErrorFrame: SolidityStackTraceEntry = {\n      type: StackTraceEntryType.OTHER_EXECUTION_ERROR,\n      sourceReference: this._getLastSourceReference(trace),\n    };\n\n    return [...stacktrace, otherExecutionErrorFrame];\n  }\n\n  // Helpers\n\n  private _fixInitialModifier(\n    trace: DecodedEvmMessageTrace,\n    stacktrace: SolidityStackTrace\n  ): SolidityStackTrace {\n    const firstEntry = stacktrace[0];\n    if (\n      firstEntry !== undefined &&\n      firstEntry.type === StackTraceEntryType.CALLSTACK_ENTRY &&\n      firstEntry.functionType === ContractFunctionType.MODIFIER\n    ) {\n      return [\n        this._getEntryBeforeInitialModifierCallstackEntry(trace),\n        ...stacktrace,\n      ];\n    }\n\n    return stacktrace;\n  }\n\n  private _isDirectLibraryCall(trace: DecodedCallMessageTrace): boolean {\n    return (\n      trace.depth === 0 && trace.bytecode.contract.type === ContractType.LIBRARY\n    );\n  }\n\n  private _getDirectLibraryCallErrorStackTrace(\n    trace: DecodedCallMessageTrace\n  ): SolidityStackTrace {\n    const func = trace.bytecode.contract.getFunctionFromSelector(\n      trace.calldata.slice(0, 4)\n    );\n\n    if (func !== undefined) {\n      return [\n        {\n          type: StackTraceEntryType.DIRECT_LIBRARY_CALL_ERROR,\n          sourceReference: this._getFunctionStartSourceReference(trace, func),\n        },\n      ];\n    }\n\n    return [\n      {\n        type: StackTraceEntryType.DIRECT_LIBRARY_CALL_ERROR,\n        sourceReference:\n          this._getContractStartWithoutFunctionSourceReference(trace),\n      },\n    ];\n  }\n\n  private _isFunctionNotPayableError(\n    trace: DecodedCallMessageTrace,\n    calledFunction: ContractFunction | undefined\n  ): boolean {\n    if (calledFunction === undefined) {\n      return false;\n    }\n\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    if (trace.value.lten(0)) {\n      return false;\n    }\n\n    // Libraries don't have a nonpayable check\n    if (trace.bytecode.contract.type === ContractType.LIBRARY) {\n      return false;\n    }\n\n    return calledFunction.isPayable === undefined || !calledFunction.isPayable;\n  }\n\n  private _getFunctionStartSourceReference(\n    trace: DecodedEvmMessageTrace,\n    func: ContractFunction\n  ): SourceReference {\n    return {\n      sourceName: func.location.file.sourceName,\n      sourceContent: func.location.file.content,\n      contract: trace.bytecode.contract.name,\n      function: func.name,\n      line: func.location.getStartingLineNumber(),\n      range: [\n        func.location.offset,\n        func.location.offset + func.location.length,\n      ],\n    };\n  }\n\n  private _isMissingFunctionAndFallbackError(\n    trace: DecodedCallMessageTrace,\n    calledFunction: ContractFunction | undefined\n  ): boolean {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    // the called function exists in the contract\n    if (calledFunction !== undefined) {\n      return false;\n    }\n\n    // there's a receive function and no calldata\n    if (\n      trace.calldata.length === 0 &&\n      trace.bytecode.contract.receive !== undefined\n    ) {\n      return false;\n    }\n\n    return trace.bytecode.contract.fallback === undefined;\n  }\n\n  private _emptyCalldataAndNoReceive(trace: DecodedCallMessageTrace): boolean {\n    // this only makes sense when receive functions are available\n    if (\n      semver.lt(\n        trace.bytecode.compilerVersion,\n        FIRST_SOLC_VERSION_RECEIVE_FUNCTION\n      )\n    ) {\n      return false;\n    }\n\n    return (\n      trace.calldata.length === 0 &&\n      trace.bytecode.contract.receive === undefined\n    );\n  }\n\n  private _getContractStartWithoutFunctionSourceReference(\n    trace: DecodedEvmMessageTrace\n  ): SourceReference {\n    const location = trace.bytecode.contract.location;\n    return {\n      sourceName: location.file.sourceName,\n      sourceContent: location.file.content,\n      contract: trace.bytecode.contract.name,\n      line: location.getStartingLineNumber(),\n      range: [location.offset, location.offset + location.length],\n    };\n  }\n\n  private _isFallbackNotPayableError(\n    trace: DecodedCallMessageTrace,\n    calledFunction: ContractFunction | undefined\n  ): boolean {\n    if (calledFunction !== undefined) {\n      return false;\n    }\n\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    if (trace.value.lten(0)) {\n      return false;\n    }\n\n    if (trace.bytecode.contract.fallback === undefined) {\n      return false;\n    }\n\n    const isPayable = trace.bytecode.contract.fallback.isPayable;\n\n    return isPayable === undefined || !isPayable;\n  }\n\n  private _getFallbackStartSourceReference(\n    trace: DecodedCallMessageTrace\n  ): SourceReference {\n    const func = trace.bytecode.contract.fallback;\n\n    if (func === undefined) {\n      throw new Error(\n        \"This shouldn't happen: trying to get fallback source reference from a contract without fallback\"\n      );\n    }\n\n    return {\n      sourceName: func.location.file.sourceName,\n      sourceContent: func.location.file.content,\n      contract: trace.bytecode.contract.name,\n      function: FALLBACK_FUNCTION_NAME,\n      line: func.location.getStartingLineNumber(),\n      range: [\n        func.location.offset,\n        func.location.offset + func.location.length,\n      ],\n    };\n  }\n\n  private _isConstructorNotPayableError(\n    trace: DecodedCreateMessageTrace\n  ): boolean {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    const constructor = trace.bytecode.contract.constructorFunction;\n\n    // This function is only matters with contracts that have constructors defined. The ones that\n    // don't are abstract contracts, or their constructor doesn't take any argument.\n    if (constructor === undefined) {\n      return false;\n    }\n\n    return (\n      trace.value.gtn(0) &&\n      (constructor.isPayable === undefined || !constructor.isPayable)\n    );\n  }\n\n  /**\n   * Returns a source reference pointing to the constructor if it exists, or to the contract\n   * otherwise.\n   */\n  private _getConstructorStartSourceReference(\n    trace: DecodedCreateMessageTrace\n  ): SourceReference {\n    const contract = trace.bytecode.contract;\n    const constructor = contract.constructorFunction;\n\n    const line =\n      constructor !== undefined\n        ? constructor.location.getStartingLineNumber()\n        : contract.location.getStartingLineNumber();\n\n    return {\n      sourceName: contract.location.file.sourceName,\n      sourceContent: contract.location.file.content,\n      contract: contract.name,\n      function: CONSTRUCTOR_FUNCTION_NAME,\n      line,\n      range: [\n        contract.location.offset,\n        contract.location.offset + contract.location.length,\n      ],\n    };\n  }\n\n  private _isConstructorInvalidArgumentsError(\n    trace: DecodedCreateMessageTrace\n  ): boolean {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    const contract = trace.bytecode.contract;\n    const constructor = contract.constructorFunction;\n\n    // This function is only matters with contracts that have constructors defined. The ones that\n    // don't are abstract contracts, or their constructor doesn't take any argument.\n    if (constructor === undefined) {\n      return false;\n    }\n\n    if (\n      semver.lt(\n        trace.bytecode.compilerVersion,\n        FIRST_SOLC_VERSION_CREATE_PARAMS_VALIDATION\n      )\n    ) {\n      return false;\n    }\n\n    const lastStep = trace.steps[trace.steps.length - 1];\n    if (!isEvmStep(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n    if (lastInst.opcode !== Opcode.REVERT || lastInst.location !== undefined) {\n      return false;\n    }\n\n    let hasReadDeploymentCodeSize = false;\n\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let stepIndex = 0; stepIndex < trace.steps.length; stepIndex++) {\n      const step = trace.steps[stepIndex];\n      if (!isEvmStep(step)) {\n        return false;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      if (\n        inst.location !== undefined &&\n        !contract.location.equals(inst.location) &&\n        !constructor.location.equals(inst.location)\n      ) {\n        return false;\n      }\n\n      if (inst.opcode === Opcode.CODESIZE && isCreateTrace(trace)) {\n        hasReadDeploymentCodeSize = true;\n      }\n    }\n\n    return hasReadDeploymentCodeSize;\n  }\n\n  private _getEntryBeforeInitialModifierCallstackEntry(\n    trace: DecodedEvmMessageTrace\n  ): SolidityStackTraceEntry {\n    if (isDecodedCreateTrace(trace)) {\n      return {\n        type: StackTraceEntryType.CALLSTACK_ENTRY,\n        sourceReference: this._getConstructorStartSourceReference(trace),\n        functionType: ContractFunctionType.CONSTRUCTOR,\n      };\n    }\n\n    const calledFunction = trace.bytecode.contract.getFunctionFromSelector(\n      trace.calldata.slice(0, 4)\n    );\n\n    if (calledFunction !== undefined) {\n      return {\n        type: StackTraceEntryType.CALLSTACK_ENTRY,\n        sourceReference: this._getFunctionStartSourceReference(\n          trace,\n          calledFunction\n        ),\n        functionType: ContractFunctionType.FUNCTION,\n      };\n    }\n\n    // If it failed or made a call from within a modifier, and the selector doesn't match\n    // any function, it must have a fallback.\n    return {\n      type: StackTraceEntryType.CALLSTACK_ENTRY,\n      sourceReference: this._getFallbackStartSourceReference(trace),\n      functionType: ContractFunctionType.FALLBACK,\n    };\n  }\n\n  private _getLastSourceReference(\n    trace: DecodedEvmMessageTrace\n  ): SourceReference | undefined {\n    for (let i = trace.steps.length - 1; i >= 0; i--) {\n      const step = trace.steps[i];\n      if (!isEvmStep(step)) {\n        continue;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      if (inst.location === undefined) {\n        continue;\n      }\n\n      return sourceLocationToSourceReference(trace.bytecode, inst.location);\n    }\n\n    return undefined;\n  }\n\n  private _hasFailedInsideTheFallbackFunction(\n    trace: DecodedCallMessageTrace\n  ): boolean {\n    const contract = trace.bytecode.contract;\n\n    if (contract.fallback === undefined) {\n      return false;\n    }\n\n    return this._hasFailedInsideFunction(trace, contract.fallback);\n  }\n\n  private _hasFailedInsideTheReceiveFunction(\n    trace: DecodedCallMessageTrace\n  ): boolean {\n    const contract = trace.bytecode.contract;\n\n    if (contract.receive === undefined) {\n      return false;\n    }\n\n    return this._hasFailedInsideFunction(trace, contract.receive);\n  }\n\n  private _hasFailedInsideFunction(\n    trace: DecodedCallMessageTrace,\n    func: ContractFunction\n  ) {\n    const lastStep = trace.steps[trace.steps.length - 1] as EvmStep;\n    const lastInstruction = trace.bytecode.getInstruction(lastStep.pc);\n\n    return (\n      lastInstruction.location !== undefined &&\n      lastInstruction.opcode === Opcode.REVERT &&\n      func.location.contains(lastInstruction.location)\n    );\n  }\n\n  private _instructionWithinFunctionToRevertStackTraceEntry(\n    trace: DecodedEvmMessageTrace,\n    inst: Instruction\n  ): RevertErrorStackTraceEntry {\n    return {\n      type: StackTraceEntryType.REVERT_ERROR,\n      sourceReference: sourceLocationToSourceReference(\n        trace.bytecode,\n        inst.location\n      )!,\n      message: new ReturnData(trace.returnData),\n      isInvalidOpcodeError: inst.opcode === Opcode.INVALID,\n    };\n  }\n\n  private _instructionWithinFunctionToPanicStackTraceEntry(\n    trace: DecodedEvmMessageTrace,\n    inst: Instruction,\n    errorCode: BN\n  ): PanicErrorStackTraceEntry {\n    return {\n      type: StackTraceEntryType.PANIC_ERROR,\n      sourceReference:\n        sourceLocationToSourceReference(trace.bytecode, inst.location) ??\n        this._getLastSourceReference(trace)!,\n      errorCode,\n    };\n  }\n\n  private _instructionWithinFunctionToCustomErrorStackTraceEntry(\n    trace: DecodedEvmMessageTrace,\n    inst: Instruction,\n    message: string\n  ): CustomErrorStackTraceEntry {\n    return {\n      type: StackTraceEntryType.CUSTOM_ERROR,\n      sourceReference:\n        sourceLocationToSourceReference(trace.bytecode, inst.location) ??\n        this._getLastSourceReference(trace)!,\n      message,\n    };\n  }\n\n  private _solidity063MaybeUnmappedRevert(trace: DecodedEvmMessageTrace) {\n    const lastStep = trace.steps[trace.steps.length - 1];\n    if (!isEvmStep(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n\n    return (\n      semver.satisfies(\n        trace.bytecode.compilerVersion,\n        `^${FIRST_SOLC_VERSION_WITH_UNMAPPED_REVERTS}`\n      ) && lastInst.opcode === Opcode.REVERT\n    );\n  }\n\n  // Solidity 0.6.3 unmapped reverts special handling\n  // For more info: https://github.com/ethereum/solidity/issues/9006\n  private _solidity063GetFrameForUnmappedRevertBeforeFunction(\n    trace: DecodedCallMessageTrace\n  ) {\n    let revertFrame =\n      this._solidity063GetFrameForUnmappedRevertWithinFunction(trace);\n\n    if (\n      revertFrame === undefined ||\n      revertFrame.sourceReference === undefined\n    ) {\n      if (\n        trace.bytecode.contract.receive === undefined ||\n        trace.calldata.length > 0\n      ) {\n        if (trace.bytecode.contract.fallback !== undefined) {\n          // Failed within the fallback\n          const location = trace.bytecode.contract.fallback.location;\n          revertFrame = {\n            type: StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n            sourceReference: {\n              contract: trace.bytecode.contract.name,\n              function: FALLBACK_FUNCTION_NAME,\n              sourceName: location.file.sourceName,\n              sourceContent: location.file.content,\n              line: location.getStartingLineNumber(),\n              range: [location.offset, location.offset + location.length],\n            },\n          };\n\n          this._solidity063CorrectLineNumber(revertFrame);\n        }\n      } else {\n        // Failed within the receive function\n        const location = trace.bytecode.contract.receive.location;\n        revertFrame = {\n          type: StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n          sourceReference: {\n            contract: trace.bytecode.contract.name,\n            function: RECEIVE_FUNCTION_NAME,\n            sourceName: location.file.sourceName,\n            sourceContent: location.file.content,\n            line: location.getStartingLineNumber(),\n            range: [location.offset, location.offset + location.length],\n          },\n        };\n\n        this._solidity063CorrectLineNumber(revertFrame);\n      }\n    }\n    return revertFrame;\n  }\n\n  private _getOtherErrorBeforeCalledFunctionStackTraceEntry(\n    trace: DecodedCallMessageTrace\n  ): OtherExecutionErrorStackTraceEntry {\n    return {\n      type: StackTraceEntryType.OTHER_EXECUTION_ERROR,\n      sourceReference:\n        this._getContractStartWithoutFunctionSourceReference(trace),\n    };\n  }\n\n  private _isCalledNonContractAccountError(\n    trace: DecodedEvmMessageTrace\n  ): boolean {\n    // We could change this to checking that the last valid location maps to a call, but\n    // it's way more complex as we need to get the ast node from that location.\n\n    const lastIndex = this._getLastInstructionWithValidLocationStepIndex(trace);\n    if (lastIndex === undefined || lastIndex === 0) {\n      return false;\n    }\n\n    const lastStep = trace.steps[lastIndex] as EvmStep; // We know this is an EVM step\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n    if (lastInst.opcode !== Opcode.ISZERO) {\n      return false;\n    }\n\n    const prevStep = trace.steps[lastIndex - 1] as EvmStep; // We know this is an EVM step\n    const prevInst = trace.bytecode.getInstruction(prevStep.pc);\n    return prevInst.opcode === Opcode.EXTCODESIZE;\n  }\n\n  private _solidity063GetFrameForUnmappedRevertWithinFunction(\n    trace: DecodedEvmMessageTrace\n  ): UnmappedSolc063RevertErrorStackTraceEntry | undefined {\n    // If we are within a function there's a last valid location. It may\n    // be the entire contract.\n    const prevInst = this._getLastInstructionWithValidLocation(trace)!;\n    const lastStep = trace.steps[trace.steps.length - 1] as EvmStep;\n    const nextInstPc = lastStep.pc + 1;\n    const hasNextInst = trace.bytecode.hasInstruction(nextInstPc);\n\n    if (hasNextInst) {\n      const nextInst = trace.bytecode.getInstruction(nextInstPc);\n      const prevLoc = prevInst.location!;\n      const nextLoc = nextInst.location;\n      const prevFunc = prevLoc.getContainingFunction();\n      const nextFunc = nextLoc?.getContainingFunction();\n\n      // This is probably a require. This means that we have the exact\n      // line, but the stack trace may be degraded (e.g. missing our\n      // synthetic call frames when failing in a modifier) so we still\n      // add this frame as UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n      if (\n        prevFunc !== undefined &&\n        nextLoc !== undefined &&\n        prevLoc.equals(nextLoc)\n      ) {\n        return {\n          ...this._instructionWithinFunctionToRevertStackTraceEntry(\n            trace,\n            nextInst\n          ),\n          type: StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n        };\n      }\n\n      let revertFrame: UnmappedSolc063RevertErrorStackTraceEntry | undefined;\n\n      // If the previous and next location don't match, we try to use the\n      // previous one if it's inside a function, otherwise we use the next one\n      if (prevFunc !== undefined) {\n        revertFrame = {\n          ...this._instructionWithinFunctionToRevertStackTraceEntry(\n            trace,\n            prevInst\n          ),\n          type: StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n        };\n      } else if (nextFunc !== undefined) {\n        revertFrame = {\n          ...this._instructionWithinFunctionToRevertStackTraceEntry(\n            trace,\n            nextInst\n          ),\n          type: StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n        };\n      }\n\n      if (revertFrame !== undefined) {\n        this._solidity063CorrectLineNumber(revertFrame);\n      }\n\n      return revertFrame;\n    }\n\n    if (isCreateTrace(trace)) {\n      // Solidity is smart enough to stop emitting extra instructions after\n      // an unconditional revert happens in a constructor. If this is the case\n      // we just return a special error.\n      const constructorRevertFrame: UnmappedSolc063RevertErrorStackTraceEntry =\n        {\n          ...this._instructionWithinFunctionToRevertStackTraceEntry(\n            trace,\n            prevInst\n          ),\n          type: StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n        };\n\n      // When the latest instruction is not within a function we need\n      // some default sourceReference to show to the user\n      if (constructorRevertFrame.sourceReference === undefined) {\n        const location = trace.bytecode.contract.location;\n        const defaultSourceReference: SourceReference = {\n          function: CONSTRUCTOR_FUNCTION_NAME,\n          contract: trace.bytecode.contract.name,\n          sourceName: location.file.sourceName,\n          sourceContent: location.file.content,\n          line: location.getStartingLineNumber(),\n          range: [location.offset, location.offset + location.length],\n        };\n\n        if (trace.bytecode.contract.constructorFunction !== undefined) {\n          defaultSourceReference.line =\n            trace.bytecode.contract.constructorFunction.location.getStartingLineNumber();\n        }\n\n        constructorRevertFrame.sourceReference = defaultSourceReference;\n      } else {\n        this._solidity063CorrectLineNumber(constructorRevertFrame);\n      }\n\n      return constructorRevertFrame;\n    }\n\n    // We may as well just be in a function or modifier and just happen\n    // to be at the last instruction of the runtime bytecode.\n    // In this case we just return whatever the last mapped intruction\n    // points to.\n    const latestInstructionRevertFrame: UnmappedSolc063RevertErrorStackTraceEntry =\n      {\n        ...this._instructionWithinFunctionToRevertStackTraceEntry(\n          trace,\n          prevInst\n        ),\n        type: StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n      };\n\n    if (latestInstructionRevertFrame.sourceReference !== undefined) {\n      this._solidity063CorrectLineNumber(latestInstructionRevertFrame);\n    }\n\n    return latestInstructionRevertFrame;\n  }\n\n  private _isContractTooLargeError(trace: DecodedCreateMessageTrace) {\n    if (trace.error === undefined || trace.error.error !== ERROR.OUT_OF_GAS) {\n      return false;\n    }\n\n    // This error doesn't come from solidity, but actually from the VM.\n    // The deployment code executes correctly, but it OOGs.\n    const lastStep = trace.steps[trace.steps.length - 1];\n    if (!isEvmStep(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n    if (lastInst.opcode !== Opcode.RETURN) {\n      return false;\n    }\n\n    // TODO: This is an over approximation, as we should be comparing the\n    //  runtime bytecode.\n    if (\n      trace.bytecode.normalizedCode.length <=\n      EIP170_BYTECODE_SIZE_INCLUSIVE_LIMIT\n    ) {\n      return false;\n    }\n\n    // TODO: What happens if it's an actual out of gas that OOGs at the return?\n    //   maybe traces should have gasLimit and gasUsed.\n    return true;\n  }\n\n  private _solidity063CorrectLineNumber(\n    revertFrame: UnmappedSolc063RevertErrorStackTraceEntry\n  ) {\n    const lines = revertFrame.sourceReference.sourceContent.split(\"\\n\");\n\n    const currentLine = lines[revertFrame.sourceReference.line - 1];\n\n    if (currentLine.includes(\"require\") || currentLine.includes(\"revert\")) {\n      return;\n    }\n\n    const nextLines = lines.slice(revertFrame.sourceReference.line);\n    const firstNonEmptyLine = nextLines.findIndex((l) => l.trim() !== \"\");\n\n    if (firstNonEmptyLine === -1) {\n      return;\n    }\n\n    const nextLine = nextLines[firstNonEmptyLine];\n\n    if (nextLine.includes(\"require\") || nextLine.includes(\"revert\")) {\n      revertFrame.sourceReference.line += 1 + firstNonEmptyLine;\n    }\n  }\n\n  private _getLastInstructionWithValidLocationStepIndex(\n    trace: DecodedEvmMessageTrace\n  ): number | undefined {\n    for (let i = trace.steps.length - 1; i >= 0; i--) {\n      const step = trace.steps[i];\n\n      if (!isEvmStep(step)) {\n        return undefined;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      if (inst.location !== undefined) {\n        return i;\n      }\n    }\n\n    return undefined;\n  }\n\n  private _getLastInstructionWithValidLocation(\n    trace: DecodedEvmMessageTrace\n  ): Instruction | undefined {\n    const lastLocationIndex =\n      this._getLastInstructionWithValidLocationStepIndex(trace);\n\n    if (lastLocationIndex === undefined) {\n      return undefined;\n    }\n\n    const lastLocationStep = trace.steps[lastLocationIndex];\n    if (isEvmStep(lastLocationStep)) {\n      const lastInstructionWithLocation = trace.bytecode.getInstruction(\n        lastLocationStep.pc\n      );\n      return lastInstructionWithLocation;\n    }\n\n    return undefined;\n  }\n\n  private _callInstructionToCallFailedToExecuteStackTraceEntry(\n    bytecode: Bytecode,\n    callInst: Instruction\n  ): CallFailedErrorStackTraceEntry {\n    // Calls only happen within functions\n    return {\n      type: StackTraceEntryType.CALL_FAILED_ERROR,\n      sourceReference: sourceLocationToSourceReference(\n        bytecode,\n        callInst.location\n      )!,\n    };\n  }\n\n  private _getEntryBeforeFailureInModifier(\n    trace: DecodedEvmMessageTrace,\n    functionJumpdests: Instruction[]\n  ): CallstackEntryStackTraceEntry | InternalFunctionCallStackEntry {\n    // If there's a jumpdest, this modifier belongs to the last function that it represents\n    if (functionJumpdests.length > 0) {\n      return instructionToCallstackStackTraceEntry(\n        trace.bytecode,\n        functionJumpdests[functionJumpdests.length - 1]\n      );\n    }\n\n    // This function is only called after we jumped into the initial function in call traces, so\n    // there should always be at least a function jumpdest.\n    if (!isDecodedCreateTrace(trace)) {\n      throw new Error(\n        \"This shouldn't happen: a call trace has no functionJumpdest but has already jumped into a function\"\n      );\n    }\n\n    // If there's no jump dest, we point to the constructor.\n    return {\n      type: StackTraceEntryType.CALLSTACK_ENTRY,\n      sourceReference: this._getConstructorStartSourceReference(trace),\n      functionType: ContractFunctionType.CONSTRUCTOR,\n    };\n  }\n\n  private _failsRightAfterCall(\n    trace: DecodedEvmMessageTrace,\n    callSubtraceStepIndex: number\n  ): boolean {\n    const lastStep = trace.steps[trace.steps.length - 1];\n    if (!isEvmStep(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n    if (lastInst.opcode !== Opcode.REVERT) {\n      return false;\n    }\n\n    const callOpcodeStep = trace.steps[callSubtraceStepIndex - 1] as EvmStep;\n    const callInst = trace.bytecode.getInstruction(callOpcodeStep.pc);\n\n    return this._isLastLocation(\n      trace,\n      callSubtraceStepIndex + 1,\n      callInst.location! // Calls are always made from within functions\n    );\n  }\n\n  private _isCallFailedError(\n    trace: DecodedEvmMessageTrace,\n    instIndex: number,\n    callInstruction: Instruction\n  ): boolean {\n    const callLocation = callInstruction.location!; // Calls are always made from within functions\n    return this._isLastLocation(trace, instIndex, callLocation);\n  }\n\n  private _isLastLocation(\n    trace: DecodedEvmMessageTrace,\n    fromStep: number,\n    location: SourceLocation\n  ): boolean {\n    for (let i = fromStep; i < trace.steps.length; i++) {\n      const step = trace.steps[i];\n\n      if (!isEvmStep(step)) {\n        return false;\n      }\n\n      const stepInst = trace.bytecode.getInstruction(step.pc);\n\n      if (stepInst.location === undefined) {\n        continue;\n      }\n\n      if (!location.equals(stepInst.location)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private _isSubtraceErrorPropagated(\n    trace: DecodedEvmMessageTrace,\n    callSubtraceStepIndex: number\n  ): boolean {\n    const call = trace.steps[callSubtraceStepIndex] as MessageTrace;\n\n    if (!trace.returnData.equals(call.returnData)) {\n      return false;\n    }\n\n    if (\n      trace.error?.error === ERROR.OUT_OF_GAS &&\n      call.error?.error === ERROR.OUT_OF_GAS\n    ) {\n      return true;\n    }\n\n    return this._failsRightAfterCall(trace, callSubtraceStepIndex);\n  }\n\n  private _isProxyErrorPropagated(\n    trace: DecodedEvmMessageTrace,\n    callSubtraceStepIndex: number\n  ): boolean {\n    if (!isDecodedCallTrace(trace)) {\n      return false;\n    }\n\n    const callStep = trace.steps[callSubtraceStepIndex - 1];\n    if (!isEvmStep(callStep)) {\n      return false;\n    }\n\n    const callInst = trace.bytecode.getInstruction(callStep.pc);\n    if (callInst.opcode !== Opcode.DELEGATECALL) {\n      return false;\n    }\n\n    const subtrace = trace.steps[callSubtraceStepIndex];\n    if (isEvmStep(subtrace)) {\n      return false;\n    }\n\n    if (isPrecompileTrace(subtrace)) {\n      return false;\n    }\n\n    // If we can't recognize the implementation we'd better don't consider it as such\n    if (subtrace.bytecode === undefined) {\n      return false;\n    }\n\n    if (subtrace.bytecode.contract.type === ContractType.LIBRARY) {\n      return false;\n    }\n\n    if (!trace.returnData.equals(subtrace.returnData)) {\n      return false;\n    }\n\n    for (let i = callSubtraceStepIndex + 1; i < trace.steps.length; i++) {\n      const step = trace.steps[i];\n      if (!isEvmStep(step)) {\n        return false;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      // All the remaining locations should be valid, as they are part of the inline asm\n      if (inst.location === undefined) {\n        return false;\n      }\n\n      if (\n        inst.jumpType === JumpType.INTO_FUNCTION ||\n        inst.jumpType === JumpType.OUTOF_FUNCTION\n      ) {\n        return false;\n      }\n    }\n\n    const lastStep = trace.steps[trace.steps.length - 1] as EvmStep;\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n\n    return lastInst.opcode === Opcode.REVERT;\n  }\n\n  private _isContractCallRunOutOfGasError(\n    trace: DecodedEvmMessageTrace,\n    callStepIndex: number\n  ): boolean {\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    if (trace.error?.error !== ERROR.REVERT) {\n      return false;\n    }\n\n    const call = trace.steps[callStepIndex] as MessageTrace;\n    if (call.error?.error !== ERROR.OUT_OF_GAS) {\n      return false;\n    }\n\n    return this._failsRightAfterCall(trace, callStepIndex);\n  }\n\n  private _isPanicReturnData(returnData: Buffer): boolean {\n    return new ReturnData(returnData).isPanicReturnData();\n  }\n}\n\nexport function instructionToCallstackStackTraceEntry(\n  bytecode: Bytecode,\n  inst: Instruction\n): CallstackEntryStackTraceEntry | InternalFunctionCallStackEntry {\n  // This means that a jump is made from within an internal solc function.\n  // These are normally made from yul code, so they don't map to any Solidity\n  // function\n  if (inst.location === undefined) {\n    const location = bytecode.contract.location;\n    return {\n      type: StackTraceEntryType.INTERNAL_FUNCTION_CALLSTACK_ENTRY,\n      pc: inst.pc,\n      sourceReference: {\n        sourceName: bytecode.contract.location.file.sourceName,\n        sourceContent: bytecode.contract.location.file.content,\n        contract: bytecode.contract.name,\n        function: undefined,\n        line: bytecode.contract.location.getStartingLineNumber(),\n        range: [location.offset, location.offset + location.length],\n      },\n    };\n  }\n\n  const func = inst.location!.getContainingFunction();\n\n  if (func !== undefined) {\n    return {\n      type: StackTraceEntryType.CALLSTACK_ENTRY,\n      sourceReference: sourceLocationToSourceReference(\n        bytecode,\n        inst.location\n      )!,\n      functionType: func.type,\n    };\n  }\n\n  return {\n    type: StackTraceEntryType.CALLSTACK_ENTRY,\n    sourceReference: {\n      function: undefined,\n      contract: bytecode.contract.name,\n      sourceName: inst.location!.file.sourceName,\n      sourceContent: inst.location!.file.content,\n      line: inst.location!.getStartingLineNumber(),\n      range: [\n        inst.location!.offset,\n        inst.location!.offset + inst.location!.length,\n      ],\n    },\n    functionType: ContractFunctionType.FUNCTION,\n  };\n}\n\nfunction sourceLocationToSourceReference(\n  bytecode: Bytecode,\n  location?: SourceLocation\n): SourceReference | undefined {\n  if (location === undefined) {\n    return undefined;\n  }\n\n  const func = location.getContainingFunction();\n\n  if (func === undefined) {\n    return undefined;\n  }\n\n  let funcName = func.name;\n\n  if (func.type === ContractFunctionType.CONSTRUCTOR) {\n    funcName = CONSTRUCTOR_FUNCTION_NAME;\n  } else if (func.type === ContractFunctionType.FALLBACK) {\n    funcName = FALLBACK_FUNCTION_NAME;\n  } else if (func.type === ContractFunctionType.RECEIVE) {\n    funcName = RECEIVE_FUNCTION_NAME;\n  }\n\n  return {\n    function: funcName,\n    contract:\n      func.type === ContractFunctionType.FREE_FUNCTION\n        ? undefined\n        : bytecode.contract.name,\n    sourceName: func.location.file.sourceName,\n    sourceContent: func.location.file.content,\n    line: location.getStartingLineNumber(),\n    range: [location.offset, location.offset + location.length],\n  };\n}\n"]},"metadata":{},"sourceType":"script"}