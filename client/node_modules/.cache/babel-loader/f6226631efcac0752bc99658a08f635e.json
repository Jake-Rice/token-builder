{"ast":null,"code":"'use strict';\n\nconst Dispatcher = require('./dispatcher');\n\nconst {\n  ClientDestroyedError,\n  ClientClosedError,\n  InvalidArgumentError\n} = require('./core/errors');\n\nconst FixedQueue = require('./node/fixed-queue');\n\nconst {\n  kConnected,\n  kSize,\n  kRunning,\n  kPending,\n  kQueued,\n  kBusy,\n  kFree,\n  kUrl\n} = require('./core/symbols');\n\nconst PoolStats = require('./pool-stats');\n\nconst kClients = Symbol('clients');\nconst kNeedDrain = Symbol('needDrain');\nconst kQueue = Symbol('queue');\nconst kDestroyed = Symbol('destroyed');\nconst kClosedPromise = Symbol('closed promise');\nconst kClosedResolve = Symbol('closed resolve');\nconst kOnDrain = Symbol('onDrain');\nconst kOnConnect = Symbol('onConnect');\nconst kOnDisconnect = Symbol('onDisconnect');\nconst kOnConnectionError = Symbol('onConnectionError');\nconst kGetDispatcher = Symbol('get dispatcher');\nconst kAddClient = Symbol('add client');\nconst kRemoveClient = Symbol('remove client');\nconst kStats = Symbol('stats');\n\nclass PoolBase extends Dispatcher {\n  constructor() {\n    super();\n    this[kQueue] = new FixedQueue();\n    this[kClosedPromise] = null;\n    this[kClosedResolve] = null;\n    this[kDestroyed] = false;\n    this[kClients] = [];\n    this[kNeedDrain] = false;\n    this[kQueued] = 0;\n    const pool = this;\n\n    this[kOnDrain] = function onDrain(origin, targets) {\n      const queue = pool[kQueue];\n      let needDrain = false;\n\n      while (!needDrain) {\n        const item = queue.shift();\n\n        if (!item) {\n          break;\n        }\n\n        pool[kQueued]--;\n        needDrain = !this.dispatch(item.opts, item.handler);\n      }\n\n      this[kNeedDrain] = needDrain;\n\n      if (!this[kNeedDrain] && pool[kNeedDrain]) {\n        pool[kNeedDrain] = false;\n        pool.emit('drain', origin, [pool, ...targets]);\n      }\n\n      if (pool[kClosedResolve] && queue.isEmpty()) {\n        Promise.all(pool[kClients].map(c => c.close())).then(pool[kClosedResolve]);\n      }\n    };\n\n    this[kOnConnect] = (origin, targets) => {\n      pool.emit('connect', origin, [pool, ...targets]);\n    };\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      pool.emit('disconnect', origin, [pool, ...targets], err);\n    };\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      pool.emit('connectionError', origin, [pool, ...targets], err);\n    };\n\n    this[kStats] = new PoolStats(this);\n  }\n\n  get [kBusy]() {\n    return this[kNeedDrain];\n  }\n\n  get [kConnected]() {\n    return this[kClients].filter(client => client[kConnected]).length;\n  }\n\n  get [kFree]() {\n    return this[kClients].filter(client => client[kConnected] && !client[kNeedDrain]).length;\n  }\n\n  get [kPending]() {\n    let ret = this[kQueued];\n\n    for (const {\n      [kPending]: pending\n    } of this[kClients]) {\n      ret += pending;\n    }\n\n    return ret;\n  }\n\n  get [kRunning]() {\n    let ret = 0;\n\n    for (const {\n      [kRunning]: running\n    } of this[kClients]) {\n      ret += running;\n    }\n\n    return ret;\n  }\n\n  get [kSize]() {\n    let ret = this[kQueued];\n\n    for (const {\n      [kSize]: size\n    } of this[kClients]) {\n      ret += size;\n    }\n\n    return ret;\n  }\n\n  get stats() {\n    return this[kStats];\n  }\n\n  get destroyed() {\n    return this[kDestroyed];\n  }\n\n  get closed() {\n    return this[kClosedPromise] != null;\n  }\n\n  close(cb) {\n    try {\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError();\n      }\n\n      if (!this[kClosedPromise]) {\n        if (this[kQueue].isEmpty()) {\n          this[kClosedPromise] = Promise.all(this[kClients].map(c => c.close()));\n        } else {\n          this[kClosedPromise] = new Promise(resolve => {\n            this[kClosedResolve] = resolve;\n          });\n        }\n\n        this[kClosedPromise] = this[kClosedPromise].then(() => {\n          this[kDestroyed] = true;\n        });\n      }\n\n      if (cb) {\n        this[kClosedPromise].then(() => cb(null, null));\n      } else {\n        return this[kClosedPromise];\n      }\n    } catch (err) {\n      if (cb) {\n        cb(err);\n      } else {\n        return Promise.reject(err);\n      }\n    }\n  }\n\n  destroy(err, cb) {\n    this[kDestroyed] = true;\n\n    if (typeof err === 'function') {\n      cb = err;\n      err = null;\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError();\n    }\n\n    while (true) {\n      const item = this[kQueue].shift();\n\n      if (!item) {\n        break;\n      }\n\n      item.handler.onError(err);\n    }\n\n    const promise = Promise.all(this[kClients].map(c => c.destroy(err)));\n\n    if (cb) {\n      promise.then(() => cb(null, null));\n    } else {\n      return promise;\n    }\n  }\n\n  dispatch(opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object');\n    }\n\n    try {\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError();\n      }\n\n      if (this[kClosedPromise]) {\n        throw new ClientClosedError();\n      }\n\n      const dispatcher = this[kGetDispatcher]();\n\n      if (!dispatcher) {\n        this[kNeedDrain] = true;\n        this[kQueue].push({\n          opts,\n          handler\n        });\n        this[kQueued]++;\n      } else if (!dispatcher.dispatch(opts, handler)) {\n        dispatcher[kNeedDrain] = true;\n        this[kNeedDrain] = !this[kGetDispatcher]();\n      }\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method');\n      }\n\n      handler.onError(err);\n    }\n\n    return !this[kNeedDrain];\n  }\n\n  [kAddClient](client) {\n    client.on('drain', this[kOnDrain]).on('connect', this[kOnConnect]).on('disconnect', this[kOnDisconnect]).on('connectionError', this[kOnConnectionError]);\n    this[kClients].push(client);\n\n    if (this[kNeedDrain]) {\n      process.nextTick(() => {\n        if (this[kNeedDrain]) {\n          this[kOnDrain](client[kUrl], [this, client]);\n        }\n      });\n    }\n\n    return this;\n  }\n\n  [kRemoveClient](client) {\n    client.close(() => {\n      const idx = this[kClients].indexOf(client);\n\n      if (idx !== -1) {\n        this[kClients].splice(idx, 1);\n      }\n    });\n    this[kNeedDrain] = this[kClients].some(dispatcher => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);\n  }\n\n}\n\nmodule.exports = {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n};","map":{"version":3,"sources":["/Users/jake/workspace/token-builder/node_modules/undici/lib/pool-base.js"],"names":["Dispatcher","require","ClientDestroyedError","ClientClosedError","InvalidArgumentError","FixedQueue","kConnected","kSize","kRunning","kPending","kQueued","kBusy","kFree","kUrl","PoolStats","kClients","Symbol","kNeedDrain","kQueue","kDestroyed","kClosedPromise","kClosedResolve","kOnDrain","kOnConnect","kOnDisconnect","kOnConnectionError","kGetDispatcher","kAddClient","kRemoveClient","kStats","PoolBase","constructor","pool","onDrain","origin","targets","queue","needDrain","item","shift","dispatch","opts","handler","emit","isEmpty","Promise","all","map","c","close","then","err","filter","client","length","ret","pending","running","size","stats","destroyed","closed","cb","resolve","reject","destroy","onError","promise","dispatcher","push","on","process","nextTick","idx","indexOf","splice","some","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Dispatcher = require('./dispatcher')\nconst {\n  ClientDestroyedError,\n  ClientClosedError,\n  InvalidArgumentError\n} = require('./core/errors')\nconst FixedQueue = require('./node/fixed-queue')\nconst { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl } = require('./core/symbols')\nconst PoolStats = require('./pool-stats')\n\nconst kClients = Symbol('clients')\nconst kNeedDrain = Symbol('needDrain')\nconst kQueue = Symbol('queue')\nconst kDestroyed = Symbol('destroyed')\nconst kClosedPromise = Symbol('closed promise')\nconst kClosedResolve = Symbol('closed resolve')\nconst kOnDrain = Symbol('onDrain')\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kGetDispatcher = Symbol('get dispatcher')\nconst kAddClient = Symbol('add client')\nconst kRemoveClient = Symbol('remove client')\nconst kStats = Symbol('stats')\n\nclass PoolBase extends Dispatcher {\n  constructor () {\n    super()\n\n    this[kQueue] = new FixedQueue()\n    this[kClosedPromise] = null\n    this[kClosedResolve] = null\n    this[kDestroyed] = false\n    this[kClients] = []\n    this[kNeedDrain] = false\n    this[kQueued] = 0\n\n    const pool = this\n\n    this[kOnDrain] = function onDrain (origin, targets) {\n      const queue = pool[kQueue]\n\n      let needDrain = false\n\n      while (!needDrain) {\n        const item = queue.shift()\n        if (!item) {\n          break\n        }\n        pool[kQueued]--\n        needDrain = !this.dispatch(item.opts, item.handler)\n      }\n\n      this[kNeedDrain] = needDrain\n\n      if (!this[kNeedDrain] && pool[kNeedDrain]) {\n        pool[kNeedDrain] = false\n        pool.emit('drain', origin, [pool, ...targets])\n      }\n\n      if (pool[kClosedResolve] && queue.isEmpty()) {\n        Promise\n          .all(pool[kClients].map(c => c.close()))\n          .then(pool[kClosedResolve])\n      }\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      pool.emit('connect', origin, [pool, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      pool.emit('disconnect', origin, [pool, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      pool.emit('connectionError', origin, [pool, ...targets], err)\n    }\n\n    this[kStats] = new PoolStats(this)\n  }\n\n  get [kBusy] () {\n    return this[kNeedDrain]\n  }\n\n  get [kConnected] () {\n    return this[kClients].filter(client => client[kConnected]).length\n  }\n\n  get [kFree] () {\n    return this[kClients].filter(client => client[kConnected] && !client[kNeedDrain]).length\n  }\n\n  get [kPending] () {\n    let ret = this[kQueued]\n    for (const { [kPending]: pending } of this[kClients]) {\n      ret += pending\n    }\n    return ret\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const { [kRunning]: running } of this[kClients]) {\n      ret += running\n    }\n    return ret\n  }\n\n  get [kSize] () {\n    let ret = this[kQueued]\n    for (const { [kSize]: size } of this[kClients]) {\n      ret += size\n    }\n    return ret\n  }\n\n  get stats() {\n    return this[kStats];\n  }\n\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  get closed () {\n    return this[kClosedPromise] != null\n  }\n\n  close (cb) {\n    try {\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (!this[kClosedPromise]) {\n        if (this[kQueue].isEmpty()) {\n          this[kClosedPromise] = Promise.all(this[kClients].map(c => c.close()))\n        } else {\n          this[kClosedPromise] = new Promise((resolve) => {\n            this[kClosedResolve] = resolve\n          })\n        }\n        this[kClosedPromise] = this[kClosedPromise].then(() => {\n          this[kDestroyed] = true\n        })\n      }\n\n      if (cb) {\n        this[kClosedPromise].then(() => cb(null, null))\n      } else {\n        return this[kClosedPromise]\n      }\n    } catch (err) {\n      if (cb) {\n        cb(err)\n      } else {\n        return Promise.reject(err)\n      }\n    }\n  }\n\n  destroy (err, cb) {\n    this[kDestroyed] = true\n\n    if (typeof err === 'function') {\n      cb = err\n      err = null\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError()\n    }\n\n    while (true) {\n      const item = this[kQueue].shift()\n      if (!item) {\n        break\n      }\n      item.handler.onError(err)\n    }\n\n    const promise = Promise.all(this[kClients].map(c => c.destroy(err)))\n    if (cb) {\n      promise.then(() => cb(null, null))\n    } else {\n      return promise\n    }\n  }\n\n  dispatch (opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object')\n    }\n\n    try {\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosedPromise]) {\n        throw new ClientClosedError()\n      }\n\n      const dispatcher = this[kGetDispatcher]()\n\n      if (!dispatcher) {\n        this[kNeedDrain] = true\n        this[kQueue].push({ opts, handler })\n        this[kQueued]++\n      } else if (!dispatcher.dispatch(opts, handler)) {\n        dispatcher[kNeedDrain] = true\n        this[kNeedDrain] = !this[kGetDispatcher]()\n      }\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method')\n      }\n\n      handler.onError(err)\n    }\n\n    return !this[kNeedDrain]\n  }\n\n  [kAddClient] (client) {\n    client\n      .on('drain', this[kOnDrain])\n      .on('connect', this[kOnConnect])\n      .on('disconnect', this[kOnDisconnect])\n      .on('connectionError', this[kOnConnectionError])\n\n    this[kClients].push(client)\n\n    if (this[kNeedDrain]) {\n      process.nextTick(() => {\n        if (this[kNeedDrain]) {\n          this[kOnDrain](client[kUrl], [this, client])\n        }\n      })\n    }\n\n    return this\n  }\n\n  [kRemoveClient] (client) {\n    client.close(() => {\n      const idx = this[kClients].indexOf(client)\n      if (idx !== -1) {\n        this[kClients].splice(idx, 1)\n      }\n    })\n\n    this[kNeedDrain] = this[kClients].some(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n  }\n}\n\nmodule.exports = {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n}\n"]},"metadata":{},"sourceType":"script"}